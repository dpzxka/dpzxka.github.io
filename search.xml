<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android之广播机制(五)</title>
    <url>/2022/02/13/Android/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h2 id="五、广播机制"><a href="#五、广播机制" class="headerlink" title="五、广播机制"></a>五、广播机制</h2><blockquote>
<p>类型：</p>
<ul>
<li>标准广播：异步，没有先后顺序小路高，无法截断<ul>
<li><img src="C:\Users\xkadpz\AppData\Roaming\Typora\typora-user-images\image-20210713220135400.png" alt="image-20210713220135400"></li>
</ul>
</li>
<li>有序广播：同步，有先后顺序，有优先级，前面的广播可以拦截正在传递的广播。<ul>
<li><img src="C:\Users\xkadpz\AppData\Roaming\Typora\typora-user-images\image-20210713220402231.png" alt="image-20210713220402231"></li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="接收广播"><a href="#接收广播" class="headerlink" title="接收广播"></a>接收广播</h3><ul>
<li><p>动态注册监听网络变化</p>
<ul>
<li>动态注册：代码中</li>
<li>静态注册：AndroidManifest.xml注册</li>
</ul>
<p><strong>动态注册广播</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"><span class="comment">//    过滤器:IntentFilter</span></span><br><span class="line">    <span class="keyword">private</span> IntentFilter intentFilter;</span><br><span class="line">    <span class="keyword">private</span> NetworkChannelReceiver networkChannelReceiver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        intentFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line"><span class="comment">//        需要接收什么广播,就添加什么action</span></span><br><span class="line">        intentFilter.addAction(<span class="string">&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;</span>);</span><br><span class="line">        networkChannelReceiver = <span class="keyword">new</span> NetworkChannelReceiver();</span><br><span class="line"><span class="comment">//        注册广播,可以让NetworkChannelReceiver接收所有值为android.net.conn.CONNECTIVITY_CHANGE的广播</span></span><br><span class="line">        registerReceiver(networkChannelReceiver,intentFilter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line"><span class="comment">//        动态注册的广播,需要注销</span></span><br><span class="line">        unregisterReceiver(networkChannelReceiver);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//广播接收器：继承BroadcastReceiver，重写onReceive</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NetworkChannelReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">            ConnectivityManager connectivityManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">            NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();</span><br><span class="line">            <span class="keyword">if</span> (networkInfo != <span class="keyword">null</span> &amp;&amp; networkInfo.isAvailable())&#123;</span><br><span class="line">                Toast.makeText(context,<span class="string">&quot;network is available&quot;</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                Toast.makeText(context,<span class="string">&quot;network is unavailable&quot;</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>需要申请对应的权限。</p>
</blockquote>
<p><strong>静态注册实现开机启动</strong></p>
<p>右击 <code>com.example.broadcasttest包</code>-&gt;<code>New</code>-&gt;<code>Other</code>-&gt;<code>Broadcast Receiver</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootCompleteReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> This method is called when the BroadcastReceiver is receiving</span></span><br><span class="line">        <span class="comment">// an Intent broadcast.</span></span><br><span class="line">        Toast.makeText(context,<span class="string">&quot;Boot Complete&quot;</span>,Toast.LENGTH_LONG).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要在<code>AndroidManifest.xml</code>注册</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.zhangtao.broadcast&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.ACCESS_NETWORK_STATE&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.Broadcast&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;com.zhangtao.broadcast.BootCompleteReceiver&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.BOOT_COMPLETED0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之基础语法(一)</title>
    <url>/2020/02/14/Java/1%E3%80%81%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="Java-基础语法"><a href="#Java-基础语法" class="headerlink" title="Java 基础语法"></a>Java 基础语法</h2><h3 id="1-注释-标识符-关键字"><a href="#1-注释-标识符-关键字" class="headerlink" title="1.注释|标识符|关键字"></a>1.注释|标识符|关键字</h3><h4 id="注释"><a href="#注释" class="headerlink" title="注释:"></a>注释:</h4><p>单行注释</p>
<p>多行注释</p>
<p>文档注释</p>
<h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a><strong>标识符</strong></h4><p>Java所有的组成部分都需要名字.类名,变量名以及方法名都被成为标识符</p>
<blockquote>
<p>所有的标识符都应该以字母.美元符.下划线开始</p>
<p>首字符后,可以是字母,美元符,下划线或数字的任何字符组成</p>
<p>大小写敏感</p>
</blockquote>
<blockquote>
<p>String 不是关键字，是一个类</p>
</blockquote>
<h3 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h3><p><strong>强类型语言</strong></p>
<p>​        要求变量的使用严格符合规定,独有变量都必须先定义后才能使用</p>
<p><strong>弱类型语言</strong></p>
<p><strong>Java的数据类型分为两大类</strong></p>
<p>​        基本类型(primitive type)</p>
<p>​        引用类型(reference type)</p>
<p><img src="C:\Users\xkadpz\AppData\Roaming\Typora\typora-user-images\image-20210304134242704.png" alt="image-20210304134242704"></p>
<blockquote>
<p>float 有限 离散 舍入误差 大约 接近不等于</p>
<p>最好完全避免使用浮点数进行比较</p>
<p>所有的字符本质还是数字</p>
</blockquote>
<h3 id="3-数据转换"><a href="#3-数据转换" class="headerlink" title="3.数据转换"></a>3.数据转换</h3><p><strong>类型转换</strong></p>
<p>由于Java是强类型语言,所以 要进行有些运算的时候的,需要用到类型转换.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">低 ---------------------------------------&gt;高</span><br><span class="line">byte,short,char-&gt;int-&gt;long-&gt;float-&gt;double</span><br></pre></td></tr></table></figure>

<p><strong>运算中,不同类型的数据先转换为同一类型,然后进行运算.</strong></p>
<p><strong>强制类型转换</strong>（高-低）</p>
<p><strong>自动类型转换</strong>（低-高）</p>
<blockquote>
<ol>
<li>不能对布尔值进行转换</li>
<li>不能把对象类型转换为不相干的类型</li>
<li>把高容量转换为低容量的时候,强制转换</li>
<li>转换过程可能出现<code>内存溢出</code>,或精度问题</li>
</ol>
</blockquote>
<h3 id="4-变量-常量"><a href="#4-变量-常量" class="headerlink" title="4.变量|常量"></a>4.变量|常量</h3><h5 id="变量是什么"><a href="#变量是什么" class="headerlink" title="变量是什么?"></a>变量是什么?</h5><h5 id="Java是一种强类型语言-每个变量都必须声明其类型"><a href="#Java是一种强类型语言-每个变量都必须声明其类型" class="headerlink" title="Java是一种强类型语言,每个变量都必须声明其类型"></a>Java是一种强类型语言,每个变量都必须声明其类型</h5><h5 id="Java变量是程序中最基本的存储单元-其要素包括变量名-变量类型和作用域"><a href="#Java变量是程序中最基本的存储单元-其要素包括变量名-变量类型和作用域" class="headerlink" title="Java变量是程序中最基本的存储单元,其要素包括变量名,变量类型和作用域"></a>Java变量是程序中最基本的存储单元,其要素包括变量名,变量类型和作用域</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">type varName [=value] [&#123;,varName[=value]&#125;];</span><br><span class="line"><span class="comment">//数据类型  变量名 = 值;可以使用隔开来声明多个同类型变量</span></span><br><span class="line"><span class="comment">//不建议一行定义多个值</span></span><br></pre></td></tr></table></figure>

<p>变量作用 域:类变量\实例变量\局部变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Variable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> allClicks = <span class="number">0</span>;<span class="comment">//类变量,加关键字static,静态</span></span><br><span class="line">    String str =<span class="string">&quot;hello&quot;</span>;     <span class="comment">//实例变量,无static</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="常量-constant-初始化-initialize-后不能再该变量-不会变动的值"><a href="#常量-constant-初始化-initialize-后不能再该变量-不会变动的值" class="headerlink" title="常量(constant):初始化(initialize)后不能再该变量!不会变动的值"></a>常量(constant):初始化(initialize)后不能再该变量!不会变动的值</h5><p>理解为一种特殊的变量,值被设定后,在程序运行过程中不允许被改变.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> 常量名 = 值;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>

<p>常量名一般使用大写字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoOne</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14</span>;<span class="comment">//修饰符，不存在前后顺序</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> salary = <span class="number">12231</span>;<span class="comment">//类变量</span></span><br><span class="line">    String name;<span class="comment">//实例变量 从属对象；如果不自行初始化，类型变量默认值 0 0.0</span></span><br><span class="line">                <span class="comment">//布尔值：默认false</span></span><br><span class="line">                <span class="comment">//除了基本类型，其余的默认值都是null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//局部变量 必须声明和初始化</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(salary);</span><br><span class="line">        DemoOne demoOne = <span class="keyword">new</span> DemoOne();</span><br><span class="line">        System.out.println(demoOne.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项:</strong></p>
<p>每个变量都有类型,类型可以是基本类型,也可以是引用类型</p>
<p>变量名必须是合法的标识符</p>
<p>变量声明是一条完整的语句,因此每一个声明都必须以分号结束.</p>
<p><strong>变量的命名贵方</strong></p>
<p>所有变量\方法\类名:<code>见名知意</code></p>
<p>类成员变量:首字母小写和驼峰原则:monthSalary 除了第一个单词,后面的单词首字母大写</p>
<p>局部变量:首字母小写和驼峰原则</p>
<p>常量:大写字母和下划线:MAX_VALUE</p>
<p>类名:首字母大写和驼峰原则:Man,GoodMan</p>
<p>方法名:首字母小写和驼峰原则:run(),runRun();</p>
<h3 id="5-运算符"><a href="#5-运算符" class="headerlink" title="5.运算符"></a>5.运算符</h3><p><strong>Java语言支持如下运算符:</strong> <code>优先级:()</code></p>
<p>算术运算符：+，-，*<em>，/，%，++，- -<br>         赋值运算符 =<br>        关系运算符：&gt;，&lt;，&gt;=，&lt;=，==，!=  instanceof<br>         逻辑运算符：&amp;&amp;，||，！<br>         位运算符：&amp;，|，A，~，&gt;&gt;，&lt;&lt;，&gt;&gt;&gt;（了解！！！）<br>         条件运算符 ？：<br>         扩展赋值运算符：+=，-=，</em>=，/=</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//幂运算 Math</span></span><br><span class="line"><span class="keyword">double</span> pow = Math.pow(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//2*2*2</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>long int short byte 定义的变量相加时,如果存在long,结果则为Long类型,否则全为int,无论是否包含int计算</p>
<p>短路运算:&amp;&amp;运算过程中,前面为false时,后面不计算</p>
</blockquote>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="number">10</span>+<span class="number">20</span>+<span class="string">&quot;&quot;</span>); <span class="comment">//30</span></span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>+<span class="number">10</span>+<span class="number">20</span>); <span class="comment">//1020</span></span><br></pre></td></tr></table></figure>

<p>字符串在后,会先计算前面的;</p>
<p>字符在前,会自动把后面进行拼接</p>
</blockquote>
<h3 id="6-包机制-JavaDoc"><a href="#6-包机制-JavaDoc" class="headerlink" title="6.包机制|JavaDoc"></a>6.包机制|JavaDoc</h3><h5 id="包机制"><a href="#包机制" class="headerlink" title="包机制:"></a>包机制:</h5><p>为了更好的组织类,Java提供了包机制用于区别类名的命名空间.</p>
<p>包语句的语法格式:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg1[.pkg[.pkg...]]</span><br></pre></td></tr></table></figure>

<p><code>一般利用该公司域名倒置作为包名</code>:com.baidu.www</p>
<p>为了能够使用某一个包的成员,我们需要在Java程序中明确导入该包.使用”import”语句可完成此功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> package1[.package2...].(classname|*);</span><br></pre></td></tr></table></figure>

<h5 id="JavaDoc"><a href="#JavaDoc" class="headerlink" title="JavaDoc"></a>JavaDoc</h5><p>javadoc命令用来生成自己API文档</p>
<blockquote>
<p><em>API</em>（Application Programming Interface，应用程序接口）是一些预先定义的函数，或指软件系统不同组成部分衔接的约定</p>
</blockquote>
<p>参数信息:</p>
<p>@author 作者名</p>
<p>@version 版本号</p>
<p>@since 指名需要最早使用的JDK版本</p>
<p>@param 参数名</p>
<p>@return 返回值情况</p>
<p>@throws 异常抛出情况</p>
<blockquote>
<p>cmd: javadoc -encoding UTF-8 -charset UTF-8.demo12.java  //多显示中文</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之流程控制(二)</title>
    <url>/2020/02/14/Java/2%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2 id="java-流程控制"><a href="#java-流程控制" class="headerlink" title="java_流程控制"></a>java_流程控制</h2><h4 id="1、用户交互Scanner"><a href="#1、用户交互Scanner" class="headerlink" title="1、用户交互Scanner"></a>1、用户交互Scanner</h4><p><code>java.util.Scanner</code>&gt;是java5的新特征。可以通过<code>Scanner类来获取用户输入。</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br></pre></td></tr></table></figure>

<p>通过<code>Scanner</code>类的<code>next()</code>与next Line()方法获取输入的字符串，读取前，一般需要使用hasNext()与hasNextLine()判断是否还有输入的数据。</p>
<blockquote>
<p><code>next():</code></p>
<p>1、一定要读取到有效字符后才可以结束输入</p>
<p>2、对输入有效字符之前遇到空白，next（）方法会自动将其去掉</p>
<p>3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。</p>
<p><code>next（）不能得到带有空格的字符串</code></p>
</blockquote>
<blockquote>
<p><code>nextline():</code></p>
<p>1 以Enter为结束符,也就是说nextline()方法返回的是输入回车之前的所有字符.</p>
<p>2 可以获得空白</p>
</blockquote>
<h4 id="2、顺序结构"><a href="#2、顺序结构" class="headerlink" title="2、顺序结构"></a>2、顺序结构</h4><p>Java的基本结构就是顺序结构,除非特别指明,否则就按照顺序一句一句执行</p>
<p>顺序结构是最简单的算法结构</p>
<p>语句与语句之间,框与框之间是按从上到下的顺序进行的,它是由若干个一次执行的处理步骤.<code>它是任何一个算法都离不开的一种基本算法结构</code></p>
<blockquote>
<p>equal 判断字符串是否相等</p>
</blockquote>
<h4 id="3、选择结构"><a href="#3、选择结构" class="headerlink" title="3、选择结构"></a>3、选择结构</h4><p>**if单选择结构 **</p>
<p>判断是否可行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">    <span class="comment">//如果布尔表达式为true将执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>if双选择结构</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">    <span class="comment">//如果布尔表达式的值为true</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//如果布尔表达式的值为false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>if多选择结构</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//如果布尔表达式 1的值为true</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//如果布尔表达式 2的值为true</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//如果布尔表达式 3的值为true</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//如果以上布尔表达式都不为true的执行代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>嵌套的if结构</strong></p>
<p>使用嵌套的if…else语句是合法的.也就是说你可以在另外一个if或者else if语句中使用if或者else if.可以像if语句一样嵌套else if…else.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式 <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//如果布尔表达式的值为true</span></span><br><span class="line">	<span class="keyword">if</span>(布尔表达式 <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">//如果布尔表达式 2值为true执行的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>switch多选择结构</strong></p>
<p>switch 语句中的变量类型可以是：<br>                byte、short、int 或者char。<br>                <code>从Java SE7开始</code><br>                <code>switch 支持字符串 String 类型了</code><br>                同时 case标签必须为字符串常量或字面量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> value:</span><br><span class="line">        <span class="comment">//语句</span></span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">case</span> value:</span><br><span class="line">        <span class="comment">//语句</span></span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//可选</span></span><br><span class="line">     <span class="comment">//可以有任意多个case语句</span></span><br><span class="line">    <span class="keyword">default</span>:<span class="comment">//可选</span></span><br><span class="line">        <span class="comment">//语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4、循环结构"><a href="#4、循环结构" class="headerlink" title="4、循环结构"></a>4、循环结构</h4><p><strong>while循环</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(表达式)&#123;</span><br><span class="line">    <span class="comment">//循环内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要布尔表达式为true,循环就会一直执行下去.</p>
<p><code>需要一个让表达式失效的的方式来结束循环</code></p>
<p>少数情况需要循环一直执行,比如服务器的请求响应监听</p>
<p>循环条件一直为true就会造成无限循环(死循环),避免死循环,影响程序性能</p>
<p><strong>do…while循环</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>do…while循环至少会执行一次</p>
</blockquote>
<p>while与do-while区别​</p>
<p><code>while先判断后执行,do while是先执行后判断</code></p>
<p><code>do-while总是保证循环体会被至少执行一次</code></p>
<p><strong>for循环</strong></p>
<p>for循环语句是支持迭代的一种通用结构,</p>
<p><strong>是最有效、最灵活的循环结构</strong></p>
<p>for循环执行的次数是在执行前就确定的.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化;布尔表达式;更新)&#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><code>在java5中引入了一种主要用你与数组的增强型for循环</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(声明语句:表达式)&#123;</span><br><span class="line">    <span class="comment">//代码句子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明语句:声明新的局部变量,该变量的类型必须和数组元素的类型匹配.其作用域限定在循环句块,其值与此时数组元素的值相等.</p>
<p>表达式:表达式是要访问的数组名,或者是放回置为数组的方法</p>
<h4 id="5、break-amp-continue"><a href="#5、break-amp-continue" class="headerlink" title="5、break &amp; continue"></a>5、break &amp; continue</h4><p>break在任何循环语句的主体部分,均可用break控制循环的流程.break用于强行退出循环,不执行程序中中剩余的语句.(break语句也在switch语句中使用)</p>
<p>continue语句用在循环句体中,<code>用于终止某次循环过程</code>,即跳过循环体中尚未执行的语句,接着进行下一次是否执行循环的判定.</p>
<h4 id="6、练习"><a href="#6、练习" class="headerlink" title="6、练习"></a>6、练习</h4><p>打印三角形</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> DemoDayTwo.scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@BelongsProiect</span>：DemoJavaOne</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@BelongsPackage</span>：DemoDayTwo.scanner</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：xkadpz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span>：2022-01-22 15:54</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">sanjiaoxing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">5</span>; j &gt; i ; j--) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之方法详解(三)</title>
    <url>/2020/02/14/Java/3%E3%80%81%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Java-方法详解"><a href="#Java-方法详解" class="headerlink" title="Java_方法详解"></a>Java_方法详解</h2><h3 id="1-所谓方法"><a href="#1-所谓方法" class="headerlink" title="1.所谓方法"></a>1.所谓方法</h3><p><strong>Java方法是语句的集合,它们在一起执行一个功能</strong></p>
<p>方法是解决一类问题的步骤的有序组合</p>
<p>方法包含于类或对象中</p>
<p>方法在程序中被创建,在其他地方被引用</p>
<p><strong>设计方法原则</strong>:方法的本意是功能块,就是实现某个功能的语句块的集合.设计的时候保持方法的原子性.<code>即一个方法只完成一个功能,有利于后期拓展</code></p>
<h3 id="2-方法的定义及调用"><a href="#2-方法的定义及调用" class="headerlink" title="2.方法的定义及调用"></a>2.方法的定义及调用</h3><p><strong>方法包含一个方法头和一个方法体</strong></p>
<blockquote>
<p>**修饰符:**修饰符,可选,告诉编译器如何调用该方法.定义了该方法的访问类型</p>
<p>**返回值类型:**方法可能会返回值.returnValueType是方法返回值的数据类型.有些方法执行所需的操作,单没有返回值,在这种情况下,returnValueType是关键字void</p>
<p>**方法名:**是方法的实际名称.方法名和参数共同构成方法签名</p>
<p><strong>参数类型:<strong>参数像是一个占位符。当方法被调用时,传递值给参数,这个值被称为</strong>实参或变量</strong>.参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的,方法可以不包含任何参数</p>
<p>​    <strong>形式参数</strong>:在方法被调用时用于接收外界输入的数据</p>
<p>​    <strong>实参</strong>:调用方法时实际传递给方法的数据</p>
<p>**方法体:**方法体包含具体的语句,定义该方法的功能.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名)&#123;</span><br><span class="line">    ...</span><br><span class="line">        方法体</span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法调用</strong></p>
<p>调用方法:</p>
<blockquote>
<p>对象名.方法名(实参列表)</p>
</blockquote>
<p> Java支持两种调用方法的方式,根据方法是否返回值选择.</p>
<p>当方法返回值是数据类型时,方法调用通常被当作一个值.例如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> larger = max(<span class="number">30</span>,<span class="number">40</span>);</span><br></pre></td></tr></table></figure>

<p>如果方法返回值是void,方法调用是一条语句.(可以直接用,)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Hello,zhangtao&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>拓展:</p>
<p><a href="https://www.zhihu.com/question/20289916/answer/762221662">值传递和引用传递</a></p>
<h3 id="3-方法重载"><a href="#3-方法重载" class="headerlink" title="3.方法重载"></a>3.方法重载</h3><p>重载就是在一个类中,有相同的函数名称,单形参不同的函数</p>
<p><strong>方法的重载的规则:</strong></p>
<p>方法名称必须相同</p>
<p>参数列表必须不同(个数不同,或者类型不同,参数排列顺序不同等)</p>
<p><code>方法的返回类型可以相同也可以不相同</code></p>
<p>仅仅返回类型不同不足以构成方法重载</p>
<blockquote>
<p>实现理论:</p>
<p>方法名称相同时,编译器会根据调用方法的参数个数,参数类型等逐个匹配,以选择对应的方法,如果匹配失败,则编译器报错.</p>
</blockquote>
<h3 id="4-命令行传参"><a href="#4-命令行传参" class="headerlink" title="4.命令行传参"></a>4.命令行传参</h3><p>希望运行一个程序时候再传递给它消息.这要靠传递命令行参数给main(函数实现)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandLine</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;args.length;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;args[&quot;</span>+i+<span class="string">&quot;]&quot;</span>+args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\xkadpz\AppData\Roaming\Typora\typora-user-images\image-20210306165739729.png" alt="image-20210306165739729"></p>
<blockquote>
<p>G:\ide\src&gt;java com.zhangtao.Methed.Demo03 this s</p>
<p>在Method目录下编译,运行要退回到src目录下,在后面新增字符串</p>
</blockquote>
<h3 id="5-可变参数"><a href="#5-可变参数" class="headerlink" title="5.可变参数"></a>5.可变参数</h3><p>JDK 1.5开始,Java支持传递<code>同类型</code>的可变参数给一个方法</p>
<p>在方法生命中,在指定参数类型后加一个省略号(…)</p>
<p><code>一个方法中只能指定一个可变参数,它必须是方法的最后一个参数</code>。任何普通的参数必须在它之前声明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintMax</span><span class="params">(<span class="keyword">double</span>... numbers)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers.length == <span class="number">0</span> )&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;No argument passed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> result = numbers[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//排序;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i]&gt;result)&#123;</span><br><span class="line">           	result = numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;The max value is&quot;</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="6-递归"><a href="#6-递归" class="headerlink" title="6.递归"></a>6.递归</h3><p>A方法调用B方法，我们很容易理解！<br>         <strong>递归就是：A方法调用A方法！</strong>就是自己调用自己</p>
<p>利用递归可以用简单的程序来解决一些复杂的问题。它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。<strong>递归的能力在于用有限的语句来定义对象的无限集合。</strong></p>
<p>递归结构包括两个部分：<br>                 <strong>递归头：什么时候不调用自身方法。如果没有头，将陷入死循环。<br>                 递归体：什么时候需要调用自身方法。</strong></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之面向对象(五)</title>
    <url>/2020/02/14/Java/5%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%90Java%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9AOOP%E3%80%91/</url>
    <content><![CDATA[<h2 id="面向对象【Java的核心思想：OOP】"><a href="#面向对象【Java的核心思想：OOP】" class="headerlink" title="面向对象【Java的核心思想：OOP】"></a>面向对象【Java的核心思想：OOP】</h2><h3 id="1-初始面向对象"><a href="#1-初始面向对象" class="headerlink" title="1.初始面向对象"></a>1.初始面向对象</h3><p><strong>面向过程&amp;面向对象</strong></p>
<p><strong>面向过程思想</strong>：线性思维</p>
<blockquote>
<p>步骤清晰简单，第一步做什么，第二部做什么</p>
<p>面对过程适合处理一些较为简单的问题</p>
</blockquote>
<p><strong>面向对象思想</strong>（属性+方法=类）</p>
<blockquote>
<p>物以类聚，<code>分类</code>的思维模式。思考问题首先会解决问题需要那些分类，然后对这些风雷进行单独思考。最后，才对某个分类下的细节进行面向过程的思考</p>
<p>面向对象适合处理复杂的问题，适合处理需要多人写作的问题</p>
</blockquote>
<p><code>对于描述复杂的事物，为了从宏观上把握、从股整体上合理分析，我们需要使用面向对象的思路来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理</code></p>
<h4 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h4><p>面向对象编程(Object-Oriented Programming ,OOP)</p>
<p>面向对象编程的本质：<code>以类的方式组织代码，以对象的形式组织(封装)数据</code></p>
<p>抽象</p>
<p><em>三大特性：</em></p>
<p><code>封装</code></p>
<p><code>继承</code></p>
<p><code>多态</code>（对学习方法的掌握）</p>
<p>从认识论角度考虑是现有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象。</p>
<p>从代码运行角度考虑是先有类后有对象。类是对象的模板。</p>
<h3 id="2-方法回顾和加深"><a href="#2-方法回顾和加深" class="headerlink" title="2.方法回顾和加深"></a>2.方法回顾和加深</h3><p>方法的定义：</p>
<blockquote>
<p>修饰符</p>
<p>返回类型</p>
<p>break和return的区别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;break：跳出switch 结束循环</span><br><span class="line">&gt;return :返回值要和返回值类型要一致。结束方法，返回一个结果，可以为空！！！</span><br></pre></td></tr></table></figure>

<p>方法名：注意规范。见名知意</p>
<p>参数列表：参数类型，参数名</p>
<p>异常抛出：</p>
</blockquote>
<p>方法的调用</p>
<blockquote>
<p>静态方法</p>
<p>非静态的方法</p>
<p>形参和实参</p>
<p>值传递和引用传递</p>
<p>this关键字</p>
</blockquote>
<h3 id="3-对象的创建分析"><a href="#3-对象的创建分析" class="headerlink" title="3.对象的创建分析"></a>3.对象的创建分析</h3><p><code>类是一种抽象的数据类型，它是对某一类事物整体描述/定义，但是并不是代表某一个具体的事物。</code></p>
<p>（动物，植物，手机）；（ Person类、pet类、car类）这些类，都是用来描述/定义某一类具体的事物的特点和行为.</p>
<p><code>对象是抽象概念的具体实例</code></p>
<p>张三是一个具体实例</p>
<p>能够体现出特点，展现出功能的是具体的实例，而不是一个抽象的概念</p>
<p><code>使用new关键字创建对象</code></p>
<p>使用new关键字创建的时候，除了分配内存空间外，还有给创建好的对象进行默认的初始化以及对类中构造器的调用</p>
<p>类中的构造器也成为构造方法，是在进行创建对象的时候必须要调用的。并且构造器有一下俩个特点：</p>
<p>1.必须和类的名字相同</p>
<p>2.必须没有返回类型，也不能写void</p>
<p><code>构造器必须掌握</code></p>
<h3 id="4-面向对象三大特性"><a href="#4-面向对象三大特性" class="headerlink" title="4.面向对象三大特性"></a>4.面向对象三大特性</h3><h4 id="封装："><a href="#封装：" class="headerlink" title="封装："></a>封装：</h4><p>该露的露，该藏的藏</p>
<p>​      我们程序设计要追求“**<code>高内聚，低耦合</code>**”。高内聚就是类的内部数据操作细节自己完成，不允许外部干涉；低耦合：仅暴露少量的方法给外部使用。</p>
<p>封装（数据的隐藏）</p>
<p>​      通常，应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问，这成为信息隐藏。</p>
<p><strong><code>属性私有：get/set</code></strong></p>
<h4 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h4><p>继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。</p>
<p>**<code>extends</code>**的意思是“拓展”。子类是父类 的拓展。</p>
<p><strong>Java中类只有单继承，没有多继承！</strong></p>
<hr>
<p>继承是类和类之间的一种关系。除此之外，类和类之间的关系还有依赖、组合、聚合等。</p>
<p>继承关系的两个类，一个为子类（派生类）一个为父类（基类）。子类 继承父类使用关键字extends来表示。</p>
<p>子类和父类之间，从意义上讲应该具有“is a”的关系</p>
<p>Object类</p>
<p><strong>super</strong></p>
<blockquote>
<p><strong><code>super注意点：</code></strong></p>
<ol>
<li><p>Super调用父类的构造方法，必须在构造方法的第一个。</p>
</li>
<li><p>super必须只能出现在子类的方法或构造方法中！</p>
</li>
<li><p>super和this不能同时调用构造方法！</p>
</li>
</ol>
<blockquote>
<p><strong>代表的对象不同：</strong></p>
<p>this：本身调用者这个对象</p>
<p>super：代表父类对象的引用</p>
<p><strong>前提：</strong></p>
<p>this：没有继承也可以使用</p>
<p>super：只能在继承调条件才可以使用</p>
<p><strong>构造方法：</strong></p>
<p>this()：本类的构造</p>
<p>super()：父类的构造</p>
</blockquote>
</blockquote>
<p>​    </p>
<p><strong>方法重新</strong></p>
<blockquote>
<p>重写：需要有继承关系，子类重写父类的方法</p>
<ol>
<li>方法名必须相同</li>
<li>参数列表列表必须相同</li>
<li>修饰符：方位可以扩大但不能缩小：public&gt;Protected&gt;default&gt;private</li>
<li>抛出异常：方位，范围可以被缩小，但不能扩大；ClassNotFoundException——&gt;Exceotion(大)</li>
</ol>
<p>重写，子类的方法和父类必须一致：方法体不同！</p>
<p>为社么重写：</p>
<ol>
<li>父类的功能，子类不一定不要或者不一定满足</li>
<li>ALt+insert：override</li>
</ol>
</blockquote>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>动态编译：类型：可扩展性</p>
<p>即同一方法可以根据发送对象的不同而采用多种不同的行为方式。</p>
<p>一个对象的实际类型是确定的，但可以指向对象的引用的类型有很多</p>
<p>多态存在的条件</p>
<p>​        有继承关系<br>​                 子类重写父类方法<br>​                 父类引用指向子类对象</p>
<p><code>注意：多态是方法的多态，属性没有多态性。</code></p>
<p><strong>Instanceof</strong>（类型转换） 引用类型：判断一个对象是什么类型</p>
<h3 id="5-抽象类和接口"><a href="#5-抽象类和接口" class="headerlink" title="5.抽象类和接口"></a>5.抽象类和接口</h3><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>**<code>abstract</code>**修饰符可以用来<code>修饰方法</code>也可以<code>修饰类</code>，如果修饰方法，那么该方法就是<code>抽象方法</code>；如果修饰类，那么该类就是<code>抽象类</code>。</p>
<p>抽象类中可以没有抽象方法，但是有<code>抽象方法的类一定要声明为抽象类</code>。</p>
<p>抽象类，不能使用new关键字来创建对象，它是用来让子类继承的。</p>
<p>抽象方法，只有方法的声明，没有方法的实现，它是用来让子类实现的。</p>
<p>子类继承抽象类，那么就必须要实现抽象类没有实现的抽象方法，否则该子类也要声明为抽象类。</p>
<p>思考：<a href="https://blog.csdn.net/u011514810/article/details/51232673">抽象类不能new，可以存在构造器吗</a></p>
<p>​                <a href="https://blog.csdn.net/weixin_30391339/article/details/96305779">抽象类存在的意义</a>:提高开卡效率</p>
<h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p><strong>普通类：只有具体实现</strong></p>
<p><strong>抽象类：具体实现和规范（抽象方法）都有！</strong></p>
<p><strong>接口：只有规范！自己无法写方法，约束和实现分离：面向接口编程</strong></p>
<p>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是..…则必须能.…”的思想。如果你是天使，则必须能飞。如果你是汽车，则必须能跑。如果你好人，则必须干掉坏人；如果你是坏人，则必须欺负好人</p>
<p>接口的本质是契约，就像我们人间的法律一样。制定好后大家都遵守。</p>
<p>OO的精髓，是对对象的抽象，最能体现这一点的就是接口。为什么我们讨论设计模式都只针对具备了抽多能力的语言（比如c++、java、c#等），就是因为设计模式所研究的，实际上就是如何合理的去抽象。</p>
<blockquote>
<p>声明类的关键字是class，声明接口的关键字是interface</p>
</blockquote>
<h3 id="6-内部类及OPP实战"><a href="#6-内部类及OPP实战" class="headerlink" title="6.内部类及OPP实战"></a>6.内部类及OPP实战</h3><h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><p>内部类就是在一个类的内部在定义一个类，比如，A类中定义一个B类，那么B类相对A类来说就称为内部类，而A类相对B类来说就是外部类了。</p>
<p>1.成员内部类</p>
<p>2.静态内部类</p>
<p>3.局部内部类</p>
<p>4.匿名内部类</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之数组(四)</title>
    <url>/2020/02/14/Java/4%E3%80%81%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="Java-数组"><a href="#Java-数组" class="headerlink" title="Java_数组"></a>Java_数组</h2><p>1、<strong>数组概述</strong></p>
<p>数组是相同类型数据的有序集合</p>
<p>数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成。</p>
<p>其中，每一个数据称作一个数据元素，每个数组元素可以通过一个下标来访问它们。</p>
<p>2、<strong>数组声明创建</strong></p>
<p>首先必须声明数组变量，才能在程序中使用数组。声明数组变量的语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataType[] arrayRefVar;<span class="comment">//首选的方法</span></span><br><span class="line">或</span><br><span class="line">dataType arrayReVar[];<span class="comment">//效果相同，单不是首选方法</span></span><br></pre></td></tr></table></figure>

<p>Java语言使用new操作来创建数组，语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataType[] arrayRefVar = <span class="keyword">new</span> dataType[arraySize];</span><br></pre></td></tr></table></figure>

<p>数组的元素是通过索引访问的，数组索引从0开始。</p>
<p>获取数组长度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">arrays.length</span><br></pre></td></tr></table></figure>

<p>Java内存分析：</p>
<p><img src="C:\Users\xkadpz\AppData\Roaming\Typora\typora-user-images\image-20210309100828465.png" alt="image-20210309100828465"></p>
<p><img src="C:\Users\xkadpz\AppData\Roaming\Typora\typora-user-images\image-20210309105846953.png" alt="image-20210309105846953"></p>
<p><strong>三种初始化</strong></p>
<p>静态初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">Man[] mans= &#123;<span class="keyword">new</span> Man(<span class="number">1</span>,<span class="number">1</span>),<span class="keyword">new</span> Man(<span class="number">2</span>,<span class="number">2</span>)&#125;;</span><br></pre></td></tr></table></figure>

<p>动态初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>数组的默认初始化</p>
<p>​    数组是引用类型，它的元素相当于类的实例变量，因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化。</p>
<p>数组的四个基本特点：</p>
<blockquote>
<p>其长度是确定的。数组一旦被创建，它的大小就是不可改变的</p>
<p>其元素必须是相同类型，不允许出现混合类型</p>
<p>数组中的元素可以是任何数据类型，包括<code>基本类型</code>和<code>引用类型</code></p>
<p>数组变量属引用类型，数组也可以看成对象，数组中的每个元素相当于该对象的成员变量。数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，<code>数组对象本身是在堆中的</code></p>
</blockquote>
<p><strong>数组边界</strong></p>
<p>下标的合法区间：{0，length-1}，如果越界就会报错；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> [] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    System.out.println(a[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ArraylndexOutOfBoundsException：数组下标越界异常</code></p>
<p><strong>小结：</strong></p>
<p>数组是相同数据类型（数据类型可以为任意类型）的有序集合</p>
<p>数组也是对象。数组元素相当于对象的成员变量</p>
<p>数组长度是确定的，不可变的。如果越界，则报：<code>ArraylndexOutOfBoundsException</code></p>
<p>3、<strong>数组使用</strong><br>                    For-Each循环</p>
<p>​          数组作方法入参</p>
<p>​           数组作放回值</p>
<p>4、<strong>多维数组</strong></p>
<p>​    多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组。</p>
<p>二维数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>解析：以上二位数组a可以看成一个两行五列的数组。</p>
<p>思考：多为数组的使用？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">num[<span class="number">1</span>][<span class="number">0</span>];</span><br></pre></td></tr></table></figure>



<p>5、<strong>Arrays类</strong></p>
<p>数组的工具类Java.util.Arrays</p>
<p>由于数组对象本身并没有什么方法可以供我们调用，但API中提供了一个工具类Arrays供我们使用，从而可以对数据对象进行一些基本的操作。</p>
<p><code>查看JDK帮助文档</code></p>
<p>Arrays类中的方法都是static修饰的静态方法，在使用的时候可以直接使用类名进行调用，而”不用“使用对象来调用（注意：是“不用”而不是“不能”）</p>
<p>具有以下常用功能：</p>
<p>​    给数组赋值：通过fill方法。</p>
<p>​    对数组排序：通过 sort 方法，按升序。</p>
<p>​    比较数组：通过equals方法比较数组中元素值是否相等。</p>
<p>​    查找数组元素：通过binarySearch 方法能对排序好的数组进    行二分查找法操作。</p>
<p><strong>冒泡排序</strong></p>
<p>冒泡的代码还是相当简单的，两层循环，外层冒泡轮数，里层依次比较，江湖中人人尽皆知。</p>
<p>我们看到嵌套循环，应该立马就可以得出这个算法的时间复杂度为0（n2）。</p>
<p>思考：如何优化？</p>
<p>6、<strong>稀疏数组</strong></p>
<p>当一个数组中大部分元素为0，或者为同一值的数组时，可以使用稀疏数组来保存该数组。</p>
<p>稀疏数组的处理方式是：</p>
<p>​        记录数组一共有几行几列，有多少个不同值</p>
<p>​        把具有不同值的元素和行列及值记录在一个小规模的数组中，从而缩小程序的规模</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> DemoDayFour;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@BelongsProiect</span>：DemoJavaOne</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@BelongsPackage</span>：DemoDayFour</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>：xkadpz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span>：2022-01-23 18:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">arrayDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        array[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        array[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : array) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//转换为稀疏数组保存</span></span><br><span class="line">        <span class="comment">//获取有限值的个数</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i][j] !=<span class="number">0</span>)&#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;有效的值&quot;</span>);</span><br><span class="line">        <span class="comment">//2创建稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] array2 = <span class="keyword">new</span> <span class="keyword">int</span>[sum+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        array2[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        array2[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        array2[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历二位数组，存储非0</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i][j]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    array2[count][<span class="number">0</span>]=i;</span><br><span class="line">                    array2[count][<span class="number">1</span>]=j;</span><br><span class="line">                    array2[count][<span class="number">2</span>]=array[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : array2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//还原</span></span><br><span class="line">        <span class="keyword">int</span>[][] array3 = <span class="keyword">new</span> <span class="keyword">int</span>[array2[<span class="number">0</span>][<span class="number">0</span>]][array2[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array2.length; i++) &#123;</span><br><span class="line">            array3[array2[i][<span class="number">0</span>]][array2[i][<span class="number">1</span>]] = array2[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : array3) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.print(anInt+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之异常机制(六)</title>
    <url>/2020/02/14/Java/6%E3%80%81%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6(Exception)/</url>
    <content><![CDATA[<h2 id="Java-异常机制-Exception"><a href="#Java-异常机制-Exception" class="headerlink" title="Java_异常机制(Exception)"></a>Java_异常机制(Exception)</h2><h3 id="1、什么是异常"><a href="#1、什么是异常" class="headerlink" title="1、什么是异常"></a>1、什么是异常</h3><p>软件程序在运行过程中，非常可能遇到刚刚提到的这些异常问题，我们叫异常，英文是：Exception，意思是例外。这些，例外情况，或者叫异常，怎么让我们写的程序做出合理的处理。而不至于程序崩溃。</p>
<p>异常指程序运行中出现的不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。</p>
<p>异常发生在程序运行期间，它影响了正常的程序执行流程。</p>
<h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a><strong>分类：</strong></h4><blockquote>
<p>检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</p>
<p>运行时异常：运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</p>
<p>错误ERROR：错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</p>
</blockquote>
<h3 id="2、异常体系结构："><a href="#2、异常体系结构：" class="headerlink" title="2、异常体系结构："></a>2、异常体系结构：</h3><p>Java把异常当对象来处理，并定义一个基类java.lang.Throwable作为所有是常的超类。</p>
<p>在Java API中已经定义了许多异常类，这些异常类分为两大类，错误Error和异常Exception。</p>
<p><img src="C:\Users\xkadpz\AppData\Roaming\Typora\typora-user-images\image-20210310114316718.png" alt="image-20210310114316718"></p>
<h4 id="Error："><a href="#Error：" class="headerlink" title="Error："></a>Error：</h4><p>Error类对象由Java虚拟机生成抛出，大多数错误与代码编写者所执行的操作无关。</p>
<p>Java虚拟机运行错误（Virtual MachineError），当JVM不再有继续执行操作所需的内存资源时，将出现**<code>OutOfMemoryError</code>**。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止；</p>
<p>还有发生在虚拟机试图执行应用时，如类定义错误（NoClassDefFoundError）、链接错误（LinkageError）。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。</p>
<h4 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h4><p>在Exception分支中有一个重要的子类RuntimeException（运行时异常）</p>
<p>ArraylndexOutOfBoundsException（数组下标越界）</p>
<p>NullPointerException（空指针异常）</p>
<p>ArithmeticException（算术异常）</p>
<p>MissingResourceException（丢失资源）</p>
<p>ClassNotFoundException（找不到类）等异常，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。</p>
<p>这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生；</p>
<p>Error和Exception的区别：Error通常是灾难性的致命的错误，是程序无法控制和处理的，当出现这些异常时，Java虚拟机（JVM）一般会选择终止线程；Exception通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常。</p>
<h3 id="3、Java异常处理机制"><a href="#3、Java异常处理机制" class="headerlink" title="3、Java异常处理机制"></a>3、Java异常处理机制</h3><p>抛出异常</p>
<p>捕获异常</p>
<p>异常处理五个关键字：</p>
<blockquote>
<p>try catch finally throw throws</p>
</blockquote>
<h3 id="4、处理异常"><a href="#4、处理异常" class="headerlink" title="4、处理异常"></a>4、处理异常</h3><h3 id="5、自定义异常"><a href="#5、自定义异常" class="headerlink" title="5、自定义异常"></a>5、自定义异常</h3><p>使用Java内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需继承Exception类即可。</p>
<p>在程序中使用自定义异常类，大体可分为以下几个步骤：</p>
<ol>
<li><p>创建自定义异常类。</p>
</li>
<li><p>在方法中通过throw关键字抛出异常对象。</p>
</li>
<li><p>如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理；否则在方法的声明处通过throws关键字指阳要抛出给方法调用者的异常，继续进行下一步操作。 </p>
</li>
<li><p>在出现异常方法的调用者中捕，处理异常。</p>
</li>
</ol>
<p>实际应用中的经验总结：</p>
<p>处理运行时异常时，采用逻辑去合理规避同时辅助try-catch处理</p>
<p>在多重catch块后面，可以加一个catch（Exception）来处理可能会被遗漏的异常</p>
<p>对于不确定的代码，也可以加上try-catch，处理潜在的异常</p>
<p>尽量去处理异常，切忌只是简单地调用printStack Trace）去打印输出</p>
<p>具体如何处理异常，要根据不同的业务需求和异常类型去决定</p>
<p>尽量添加finally语句块去释放占用的资源</p>
<h3 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h3>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Android之数据存储(六)</title>
    <url>/2022/02/13/Android/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h2 id="第六章-数据存储"><a href="#第六章-数据存储" class="headerlink" title="第六章 数据存储"></a>第六章 数据存储</h2><blockquote>
<p>数据持久化：内存中瞬时数据保存到存储设备中，保证临时数据不丢失。</p>
</blockquote>
<p>三种实现可持续化方式：文件存储、<code>SharedPreferences</code>存储以及数据库存储。</p>
<h3 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h3><blockquote>
<p>最基本的一种数据存储方式，不对存储的数据进行任何的格式化处理，所有的数据原封不动保存到文件中。适用于存储一些简单的文件数据或二进制数据。</p>
</blockquote>
<h4 id="将数据存储到文件"><a href="#将数据存储到文件" class="headerlink" title="将数据存储到文件"></a>将数据存储到文件</h4><blockquote>
<p>Context 类提供一个<code>openFileOutput()</code>方法，将数据存储到指定的文件中，接收两个参数，<code>per1</code>：文件名，将数据存储到指定的文件中，不包含路径，默认储存到/data/data/<packagename>/files/目录下。<code>per2</code>:文件的操作模式，MODE_PRIVATE[默认模式，当指定同文件名时，所写入的内容将会覆盖原文件的内容]|MODE_APPEND[如果文件已存在，往文件中追加内容，不存在就创建文件]。</p>
<p><code>openFileOutput()</code>方法返回的是一个<code>FileOutputStream</code>对象，得到这个对象，使用<code>java</code>流的方式将书写入到文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123;</span><br><span class="line">	String data = <span class="string">&quot;Data to save&quot;</span>;</span><br><span class="line">	FileOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">	BufferedWriter writer = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">       <span class="comment">//得到一个 FileOutputStream对象</span></span><br><span class="line">		out = openFileOutput(<span class="string">&quot;data&quot;</span>,Context.MODE_PRIVATE);</span><br><span class="line">        <span class="comment">//借助out得到OutPutSteamWriter对象，再借助此得到BufferedWriter对象，通过BufferedWriter将文本内容写入到文件。</span></span><br><span class="line">		writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(out));</span><br><span class="line">		writer.write(data);</span><br><span class="line">	&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(writer != <span class="keyword">null</span>)&#123;</span><br><span class="line">			writer.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<p><strong>将数据存储到文件中</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EditText editText;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        editText = (EditText) findViewById(R.id.edit);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        String inputText = editText.getText().toString();</span><br><span class="line">        save(inputText);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(String inputText)</span></span>&#123;</span><br><span class="line">        FileOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        BufferedWriter writer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//得到一个 FileOutputStream对象</span></span><br><span class="line">            out = openFileOutput(<span class="string">&quot;data&quot;</span>, Context.MODE_PRIVATE);</span><br><span class="line">            <span class="comment">//借助out得到OutPutSteamWriter对象，再借助此得到BufferedWriter对象，通过BufferedWriter将文本内容写入到文件。</span></span><br><span class="line">            writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(out));</span><br><span class="line">            writer.write(inputText);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(writer != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>onCreate</code>方法中，获取<code>EditText</code>的实例，在<code>onDestroy</code>方法中，保证活动在销毁之前。</p>
</blockquote>
<p><strong>在文件中读取数据</strong></p>
<blockquote>
<p>Context 类还提供了一个<code>openFileInput()方法</code>，用于从文件中读取数据。<code>per1</code>：读取的文件名。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FileInputStream in = <span class="keyword">null</span>;</span><br><span class="line">    BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">    StringBuilder content = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        in = openFileInput(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">        reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</span><br><span class="line">        String line = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = reader.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            content.append(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (reader != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> content.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SQLite数据库存储"><a href="#SQLite数据库存储" class="headerlink" title="SQLite数据库存储"></a><code>SQLite</code>数据库存储</h3><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><blockquote>
<p>提供一个<code>SQLiteOpenHelper</code>帮助类(抽象类)，借助这个类可以简单对数据库进行创建和升级。这个类，有两个抽象方法：<code>onCreate</code>方法和<code>onUpgrade</code>，重写这两个方法，分别在方法里面实现创建、升级数据库的逻辑。</p>
<p><code>SQLiteOpenHelper</code>还有两个非常重要的实例方法，<code>getReadableDatabase</code>和<code>getWritableDatabase</code>。这两个方法都可以创建或打开一个现有的数据库(如果数据库已存在则直接打开，否则创建一个新的数据库)，并返回一个可对数据库进行读写操作的对象。当数据库不可写入的时候(如磁盘空间已满)，<code>getReadableDatabase</code>方法返回的对象将以只读的方式打开数据库，而<code>getWritableDatabase</code>方法则将出现异常。</p>
<p><code>SQLiteOpenHelper</code>中有两个构造方法可供重写。其中一个接收4个参数，<code>per1</code>：Context。<code>per2</code>：数据库名，创建数据库时使用的就是这里指定的名称。<code>per3</code>：允许查询数据库的时候返回一个自定义的Cursor，一般传入null。<code>per4</code>：当前数据库的版本 ，可用于对数据库进行升级操作。</p>
<p>构建出<code>SQLiteOpenHelper</code>实例后，调用<code>getReadableDatabase</code>或<code>getWritableDatabase</code>方法创建数据库，默认存储在/data/data/<package name>/databases/目录下。</p>
</blockquote>
<p><code>SQLite</code>数据类型：</p>
<ul>
<li>integer：整型</li>
<li>real：浮点型</li>
<li>text：文本类型</li>
<li>blob：二进制类型</li>
<li>primary key：主键</li>
<li>auto-increment ：id列自增长</li>
</ul>
<p><strong>新建<code>MyDatabaseHelper</code>类继承<code>SQLiteOpenHelper</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDatabaseHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CREATE_BOOK = <span class="string">&quot;create table Book (&quot;</span></span><br><span class="line">            + <span class="string">&quot;id integer primary key autoincrement, &quot;</span></span><br><span class="line">            + <span class="string">&quot;author text, &quot;</span></span><br><span class="line">            + <span class="string">&quot;price real, &quot;</span></span><br><span class="line">            + <span class="string">&quot;pages integer, &quot;</span></span><br><span class="line">            + <span class="string">&quot;name text)&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDatabaseHelper</span><span class="params">(<span class="meta">@Nullable</span> Context context, <span class="meta">@Nullable</span> String name, <span class="meta">@Nullable</span> SQLiteDatabase.CursorFactory factory, <span class="keyword">int</span> version)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, name, factory, version);</span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        建表，保证在数据库创建完成的同时还能成功创建Book表</span></span><br><span class="line">        db.execSQL(CREATE_BOOK);</span><br><span class="line">        Toast.makeText(mContext,<span class="string">&quot;Create succeeded&quot;</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MainActivity</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyDatabaseHelper dbHelper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">//指定数据库名：BookStore.db 版本号：1 </span></span><br><span class="line">        dbHelper = <span class="keyword">new</span> MyDatabaseHelper(<span class="keyword">this</span>,<span class="string">&quot;BookStore.db&quot;</span>,<span class="keyword">null</span>,<span class="number">1</span>);</span><br><span class="line">        Button createDatabase = (Button)findViewById(R.id.create_database);</span><br><span class="line">        createDatabase.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//调用getWritableDatabase方法，创建数据库。（无则新建，有则不建）</span></span><br><span class="line">                dbHelper.getWritableDatabase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看创建的数据库：</p>
<ol>
<li>adb shell（su，进入超级管理员[#]，普通用户[$$]）</li>
<li>进入/data/data/com.zhangtao.databasetest/databases/目录下。<ol>
<li>BookStore.db：创建的数据库，BookStore.db-journal：为了让数据库能够支持事务而产生的临时日志文件。通过文件大小为0.</li>
</ol>
</li>
<li>sqlite3 Bookstore.db打开数据库。</li>
<li>.table查看数据库中的表<ol>
<li>android——metadata表是每个数据库中都会自动生成的</li>
</ol>
</li>
<li>.schema查看建表语句。</li>
</ol>
</blockquote>
<h4 id="升级数据库"><a href="#升级数据库" class="headerlink" title="升级数据库"></a>升级数据库</h4><blockquote>
<p>onUpgrade()方法用于对数据库进行升级。</p>
</blockquote>
<p><code>MyDatabaseHelper</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDatabaseHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CREATE_BOOK = <span class="string">&quot;create table Book (&quot;</span></span><br><span class="line">            + <span class="string">&quot;id integer primary key autoincrement, &quot;</span></span><br><span class="line">            + <span class="string">&quot;author text, &quot;</span></span><br><span class="line">            + <span class="string">&quot;price real, &quot;</span></span><br><span class="line">            + <span class="string">&quot;pages integer, &quot;</span></span><br><span class="line">            + <span class="string">&quot;name text)&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CREATE_CATEGORY = <span class="string">&quot;create table Category (&quot;</span></span><br><span class="line">            + <span class="string">&quot;id integer primary key autoincrement, &quot;</span></span><br><span class="line">            + <span class="string">&quot;category_name text, &quot;</span></span><br><span class="line">            + <span class="string">&quot;category_code integer)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDatabaseHelper</span><span class="params">(<span class="meta">@Nullable</span> Context context, <span class="meta">@Nullable</span> String name, <span class="meta">@Nullable</span> SQLiteDatabase.CursorFactory factory, <span class="keyword">int</span> version)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, name, factory, version);</span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        建表，保证在数据库创建完成的同时还能成功创建Book表</span></span><br><span class="line">        db.execSQL(CREATE_BOOK);</span><br><span class="line">        db.execSQL(CREATE_CATEGORY);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Toast.makeText(mContext,<span class="string">&quot;Create succeeded&quot;</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果数据库存在则删除</span></span><br><span class="line">        db.execSQL(<span class="string">&quot;drop table if exists Book&quot;</span>);</span><br><span class="line">        db.execSQL(<span class="string">&quot;drop table if exists Category&quot;</span>);</span><br><span class="line">        <span class="comment">//重建数据库</span></span><br><span class="line">        onCreate(db);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>MainActivity</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyDatabaseHelper dbHelper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"><span class="comment">//        dbHelper = new MyDatabaseHelper(this,&quot;BookStore.db&quot;,null,1);</span></span><br><span class="line">        <span class="comment">//传入大于前一个版本的数字，</span></span><br><span class="line">        dbHelper = <span class="keyword">new</span> MyDatabaseHelper(<span class="keyword">this</span>,<span class="string">&quot;BookStore.db&quot;</span>,<span class="keyword">null</span>,<span class="number">5</span>);</span><br><span class="line">        Button createDatabase = (Button)findViewById(R.id.create_database);</span><br><span class="line">        createDatabase.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                dbHelper.getWritableDatabase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="添加数据库"><a href="#添加数据库" class="headerlink" title="添加数据库"></a>添加数据库</h4><blockquote>
<p>CRUD:</p>
<ul>
<li>C：<code>Create</code> 添加</li>
<li>R：<code>Retrieve</code> 查询</li>
<li>U：<code>Update</code> 更新</li>
<li>D：<code>Delete</code> 删除</li>
</ul>
<p>Insert方法，接收三个参数。<code>per1</code>：表名。<code>per2</code>：在未指定数据的情况下，给某些可为空的列自动赋值NULL，一般直接传入NULL，<code>per3</code>：是一个<code>ContentValues</code>对象，提供一系列的put方法重载。可用于向<code>ContentValues</code>中添加数据，只需要将表中的每个列名以及相应的待添加数据传入即可。</p>
</blockquote>
<ul>
<li>修改xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/create_database&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Create database&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/add_data&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Add data&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>修改<code>MainActivity</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;MainActivity&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> MyDatabaseHelper dbHelper;</span><br><span class="line">    <span class="keyword">private</span> SQLiteDatabase db;</span><br><span class="line">    <span class="keyword">private</span> ContentValues values;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"><span class="comment">//        dbHelper = new MyDatabaseHelper(this,&quot;BookStore.db&quot;,null,1);</span></span><br><span class="line">        <span class="comment">//传入大于前一个版本的数字，</span></span><br><span class="line">        dbHelper = <span class="keyword">new</span> MyDatabaseHelper(<span class="keyword">this</span>,<span class="string">&quot;BookStore.db&quot;</span>,<span class="keyword">null</span>,<span class="number">5</span>);</span><br><span class="line">        Button createDatabase = (Button)findViewById(R.id.create_database);</span><br><span class="line">        Button addData = (Button)findViewById(R.id.add_data);</span><br><span class="line"></span><br><span class="line">        createDatabase.setOnClickListener(<span class="keyword">this</span>::onClick);</span><br><span class="line">        addData.setOnClickListener(<span class="keyword">this</span>::onClick);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        db = dbHelper.getWritableDatabase();</span><br><span class="line">        values = <span class="keyword">new</span> ContentValues();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (v.getId())&#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.create_database:</span><br><span class="line">                dbHelper.getWritableDatabase();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.add_data:</span><br><span class="line">                values.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;The Da Vinci Code&quot;</span>);</span><br><span class="line">                values.put(<span class="string">&quot;author&quot;</span>,<span class="string">&quot;Dan Brown&quot;</span>);</span><br><span class="line">                values.put(<span class="string">&quot;pages&quot;</span>,<span class="number">454</span>);</span><br><span class="line">                values.put(<span class="string">&quot;price&quot;</span>,<span class="number">16.96</span>);</span><br><span class="line">                db.insert(<span class="string">&quot;Book&quot;</span>,<span class="keyword">null</span>,values);</span><br><span class="line">                values.clear();</span><br><span class="line"></span><br><span class="line">                values.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;The Lost Symbol&quot;</span>);</span><br><span class="line">                values.put(<span class="string">&quot;author&quot;</span>,<span class="string">&quot;Dan Brown&quot;</span>);</span><br><span class="line">                values.put(<span class="string">&quot;pages&quot;</span>,<span class="number">511</span>);</span><br><span class="line">                values.put(<span class="string">&quot;price&quot;</span>,<span class="number">19.95</span>);</span><br><span class="line">                db.insert(<span class="string">&quot;Book&quot;</span>,<span class="keyword">null</span>,values);</span><br><span class="line">                values.clear();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="更新数据库"><a href="#更新数据库" class="headerlink" title="更新数据库"></a>更新数据库</h4><blockquote>
<p>SQLiteDatabase提供了一个update()方法，per1：表名，per2：ContentValues对象，需要把更新的数据组装进去。per3、per4：用于约束更新某一行或某几行中的数据，不指定，默认更新所有行。</p>
</blockquote>
<ul>
<li>修改xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;SQLiteDatabase&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;@color/design_default_color_error&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/create_database&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Create database&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/add_data&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Add data&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/update_data&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Update data&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>修改MainActivity</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;MainActivity&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> MyDatabaseHelper dbHelper;</span><br><span class="line">    <span class="keyword">private</span> SQLiteDatabase db;</span><br><span class="line">    <span class="keyword">private</span> ContentValues values;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"><span class="comment">//        dbHelper = new MyDatabaseHelper(this,&quot;BookStore.db&quot;,null,1);</span></span><br><span class="line">        <span class="comment">//传入大于前一个版本的数字，</span></span><br><span class="line">        dbHelper = <span class="keyword">new</span> MyDatabaseHelper(<span class="keyword">this</span>,<span class="string">&quot;BookStore.db&quot;</span>,<span class="keyword">null</span>,<span class="number">5</span>);</span><br><span class="line">        Button createDatabase = (Button)findViewById(R.id.create_database);</span><br><span class="line">        Button addData = (Button)findViewById(R.id.add_data);</span><br><span class="line">        Button updateData = (Button)findViewById(R.id.update_data);</span><br><span class="line"></span><br><span class="line">        createDatabase.setOnClickListener(<span class="keyword">this</span>::onClick);</span><br><span class="line">        addData.setOnClickListener(<span class="keyword">this</span>::onClick);</span><br><span class="line">        updateData.setOnClickListener(<span class="keyword">this</span>::onClick);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        db = dbHelper.getWritableDatabase();</span><br><span class="line">        values = <span class="keyword">new</span> ContentValues();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (v.getId())&#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.create_database:</span><br><span class="line">                dbHelper.getWritableDatabase();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.add_data:</span><br><span class="line">                values.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;The Da Vinci Code&quot;</span>);</span><br><span class="line">                values.put(<span class="string">&quot;author&quot;</span>,<span class="string">&quot;Dan Brown&quot;</span>);</span><br><span class="line">                values.put(<span class="string">&quot;pages&quot;</span>,<span class="number">454</span>);</span><br><span class="line">                values.put(<span class="string">&quot;price&quot;</span>,<span class="number">16.96</span>);</span><br><span class="line">                db.insert(<span class="string">&quot;Book&quot;</span>,<span class="keyword">null</span>,values);</span><br><span class="line">                values.clear();</span><br><span class="line"></span><br><span class="line">                values.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;The Lost Symbol&quot;</span>);</span><br><span class="line">                values.put(<span class="string">&quot;author&quot;</span>,<span class="string">&quot;Dan Brown&quot;</span>);</span><br><span class="line">                values.put(<span class="string">&quot;pages&quot;</span>,<span class="number">511</span>);</span><br><span class="line">                values.put(<span class="string">&quot;price&quot;</span>,<span class="number">19.95</span>);</span><br><span class="line">                db.insert(<span class="string">&quot;Book&quot;</span>,<span class="keyword">null</span>,values);</span><br><span class="line">                values.clear();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.update_data:</span><br><span class="line">                values.put(<span class="string">&quot;price&quot;</span>,<span class="number">10.99</span>);</span><br><span class="line">                db.update(<span class="string">&quot;Book&quot;</span>,values,<span class="string">&quot;name = ?&quot;</span>,<span class="keyword">new</span> String[]&#123;<span class="string">&quot;The Da Vinci Code&quot;</span>&#125;);</span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>per3:对应SQL的where部分，表示更新素有的name等于？的行，而？是一个占位符，可以通过per4提供一个字符串数组作为第三个参数的每个占位符指定的响应的内容。</p>
</blockquote>
<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><blockquote>
<p>SQLiteDatabase提供一个delete的方法，专门用于删除数据，per1：表名，per2、per3：用于约束删除某一行或某几行的数据，不指定的话默认就是删除所有的行。</p>
</blockquote>
<ul>
<li>修改xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/create_database&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Create database&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/add_data&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Add data&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/update_data&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Update data&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/delete_data&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Delete data&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>修改MainActivity</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;MainActivity&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> MyDatabaseHelper dbHelper;</span><br><span class="line">    <span class="keyword">private</span> SQLiteDatabase db;</span><br><span class="line">    <span class="keyword">private</span> ContentValues values;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"><span class="comment">//        dbHelper = new MyDatabaseHelper(this,&quot;BookStore.db&quot;,null,1);</span></span><br><span class="line">        <span class="comment">//传入大于前一个版本的数字，</span></span><br><span class="line">        dbHelper = <span class="keyword">new</span> MyDatabaseHelper(<span class="keyword">this</span>,<span class="string">&quot;BookStore.db&quot;</span>,<span class="keyword">null</span>,<span class="number">5</span>);</span><br><span class="line">        Button createDatabase = (Button)findViewById(R.id.create_database);</span><br><span class="line">        Button addData = (Button)findViewById(R.id.add_data);</span><br><span class="line">        Button updateData = (Button)findViewById(R.id.update_data);</span><br><span class="line">        Button deleteData = (Button)findViewById(R.id.delete_data);</span><br><span class="line"></span><br><span class="line">        createDatabase.setOnClickListener(<span class="keyword">this</span>::onClick);</span><br><span class="line">        addData.setOnClickListener(<span class="keyword">this</span>::onClick);</span><br><span class="line">        updateData.setOnClickListener(<span class="keyword">this</span>::onClick);</span><br><span class="line">        deleteData.setOnClickListener(<span class="keyword">this</span>::onClick);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        db = dbHelper.getWritableDatabase();</span><br><span class="line">        values = <span class="keyword">new</span> ContentValues();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (v.getId())&#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.create_database:</span><br><span class="line">                dbHelper.getWritableDatabase();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.add_data:</span><br><span class="line">                values.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;The Da Vinci Code&quot;</span>);</span><br><span class="line">                values.put(<span class="string">&quot;author&quot;</span>,<span class="string">&quot;Dan Brown&quot;</span>);</span><br><span class="line">                values.put(<span class="string">&quot;pages&quot;</span>,<span class="number">454</span>);</span><br><span class="line">                values.put(<span class="string">&quot;price&quot;</span>,<span class="number">16.96</span>);</span><br><span class="line">                db.insert(<span class="string">&quot;Book&quot;</span>,<span class="keyword">null</span>,values);</span><br><span class="line">                values.clear();</span><br><span class="line"></span><br><span class="line">                values.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;The Lost Symbol&quot;</span>);</span><br><span class="line">                values.put(<span class="string">&quot;author&quot;</span>,<span class="string">&quot;Dan Brown&quot;</span>);</span><br><span class="line">                values.put(<span class="string">&quot;pages&quot;</span>,<span class="number">511</span>);</span><br><span class="line">                values.put(<span class="string">&quot;price&quot;</span>,<span class="number">19.95</span>);</span><br><span class="line">                db.insert(<span class="string">&quot;Book&quot;</span>,<span class="keyword">null</span>,values);</span><br><span class="line">                values.clear();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.update_data:</span><br><span class="line">                values.put(<span class="string">&quot;price&quot;</span>,<span class="number">10.99</span>);</span><br><span class="line">                db.update(<span class="string">&quot;Book&quot;</span>,values,<span class="string">&quot;name = ?&quot;</span>,<span class="keyword">new</span> String[]&#123;<span class="string">&quot;The Da Vinci Code&quot;</span>&#125;);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.delete_data:</span><br><span class="line">                db.delete(<span class="string">&quot;Book&quot;</span>,<span class="string">&quot;author = ?&quot;</span>,<span class="keyword">new</span> String[]&#123;<span class="string">&quot;Dan Brown&quot;</span>&#125;);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><blockquote>
<p>SQLiteDatabase提供一个query()方法，用于对数据的查询。per1：表名。per2：指定去查询哪几列，不指定默认查询所有的列。per3、per4：用于约束查询某一行或某几行的数据，不指定默认查询所有行。per5：指定需要去group by的列。不指定不对查询结果group by。per6：对group by之后的数据进行进一步的过滤，不指定则不进行过滤。per7：指定查询结果的排序方式，不指定则表示使用的排序方式。</p>
</blockquote>
<ul>
<li>修改xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;SQLiteDatabase&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;@color/design_default_color_error&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/create_database&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Create database&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/add_data&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Add data&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/update_data&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Update data&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/delete_data&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Delete data&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/query_data&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Query data&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>修改MainActivity</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhangtao.databasetest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.ContentValues;</span><br><span class="line"><span class="keyword">import</span> android.database.Cursor;</span><br><span class="line"><span class="keyword">import</span> android.database.sqlite.SQLiteDatabase;</span><br><span class="line"><span class="keyword">import</span> android.database.sqlite.SQLiteOpenHelper;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;MainActivity&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> MyDatabaseHelper dbHelper;</span><br><span class="line">    <span class="keyword">private</span> SQLiteDatabase db;</span><br><span class="line">    <span class="keyword">private</span> ContentValues values;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"><span class="comment">//        dbHelper = new MyDatabaseHelper(this,&quot;BookStore.db&quot;,null,1);</span></span><br><span class="line">        <span class="comment">//传入大于前一个版本的数字，</span></span><br><span class="line">        dbHelper = <span class="keyword">new</span> MyDatabaseHelper(<span class="keyword">this</span>,<span class="string">&quot;BookStore.db&quot;</span>,<span class="keyword">null</span>,<span class="number">5</span>);</span><br><span class="line">        Button createDatabase = (Button)findViewById(R.id.create_database);</span><br><span class="line">        Button addData = (Button)findViewById(R.id.add_data);</span><br><span class="line">        Button updateData = (Button)findViewById(R.id.update_data);</span><br><span class="line">        Button deleteData = (Button)findViewById(R.id.delete_data);</span><br><span class="line">        Button queryData = (Button)findViewById(R.id.query_data);</span><br><span class="line"></span><br><span class="line">        createDatabase.setOnClickListener(<span class="keyword">this</span>::onClick);</span><br><span class="line">        addData.setOnClickListener(<span class="keyword">this</span>::onClick);</span><br><span class="line">        updateData.setOnClickListener(<span class="keyword">this</span>::onClick);</span><br><span class="line">        deleteData.setOnClickListener(<span class="keyword">this</span>::onClick);</span><br><span class="line">        queryData.setOnClickListener(<span class="keyword">this</span>::onClick);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        db = dbHelper.getWritableDatabase();</span><br><span class="line">        values = <span class="keyword">new</span> ContentValues();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (v.getId())&#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.create_database:</span><br><span class="line">                dbHelper.getWritableDatabase();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.add_data:</span><br><span class="line">                values.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;The Da Vinci Code&quot;</span>);</span><br><span class="line">                values.put(<span class="string">&quot;author&quot;</span>,<span class="string">&quot;Dan Brown&quot;</span>);</span><br><span class="line">                values.put(<span class="string">&quot;pages&quot;</span>,<span class="number">454</span>);</span><br><span class="line">                values.put(<span class="string">&quot;price&quot;</span>,<span class="number">16.96</span>);</span><br><span class="line">                db.insert(<span class="string">&quot;Book&quot;</span>,<span class="keyword">null</span>,values);</span><br><span class="line">                values.clear();</span><br><span class="line"></span><br><span class="line">                values.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;The Lost Symbol&quot;</span>);</span><br><span class="line">                values.put(<span class="string">&quot;author&quot;</span>,<span class="string">&quot;Dan Brown&quot;</span>);</span><br><span class="line">                values.put(<span class="string">&quot;pages&quot;</span>,<span class="number">511</span>);</span><br><span class="line">                values.put(<span class="string">&quot;price&quot;</span>,<span class="number">19.95</span>);</span><br><span class="line">                db.insert(<span class="string">&quot;Book&quot;</span>,<span class="keyword">null</span>,values);</span><br><span class="line">                values.clear();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.update_data:</span><br><span class="line">                values.put(<span class="string">&quot;price&quot;</span>,<span class="number">10.99</span>);</span><br><span class="line">                db.update(<span class="string">&quot;Book&quot;</span>,values,<span class="string">&quot;name = ?&quot;</span>,<span class="keyword">new</span> String[]&#123;<span class="string">&quot;The Da Vinci Code&quot;</span>&#125;);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.delete_data:</span><br><span class="line">                db.delete(<span class="string">&quot;Book&quot;</span>,<span class="string">&quot;author = ?&quot;</span>,<span class="keyword">new</span> String[]&#123;<span class="string">&quot;Dan Brown&quot;</span>&#125;);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.query_data:</span><br><span class="line">                Cursor cursor = db.query(<span class="string">&quot;Book&quot;</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">                 </span><br><span class="line">                <span class="keyword">if</span> (cursor.moveToFirst())&#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        String name = cursor.getString(cursor.getColumnIndex(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">                        String author = cursor.getString(cursor.getColumnIndex(<span class="string">&quot;author&quot;</span>));</span><br><span class="line">                        <span class="keyword">int</span> pages = cursor.getInt(cursor.getColumnIndex(<span class="string">&quot;pages&quot;</span>));</span><br><span class="line">                        <span class="keyword">double</span> price = cursor.getDouble(cursor.getColumnIndex(<span class="string">&quot;price&quot;</span>));</span><br><span class="line"></span><br><span class="line">                        Log.d(TAG, <span class="string">&quot;Book name is : &quot;</span>+name);</span><br><span class="line">                        Log.d(TAG, <span class="string">&quot;Book author is : &quot;</span>+author);</span><br><span class="line">                        Log.d(TAG, <span class="string">&quot;Book pages is : &quot;</span>+pages);</span><br><span class="line">                        Log.d(TAG, <span class="string">&quot;Book price is : &quot;</span>+price);</span><br><span class="line">                    &#125;<span class="keyword">while</span> (cursor.moveToNext());</span><br><span class="line">                &#125;</span><br><span class="line">                cursor.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 知识点</title>
    <url>/2022/04/22/Android/Android%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2 id="Android-知识点"><a href="#Android-知识点" class="headerlink" title="Android 知识点"></a>Android 知识点</h2><p><strong>算法部分</strong></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Algorithm/%E6%89%93%E9%81%8D%E5%A4%A9%E4%B8%8B%E4%BA%8C%E5%8F%89%E6%A0%91.md">打遍天下二叉树</a></p>
<p><a href="https://github.com/labuladong/fucking-algorithm">labuladong的fucking-algorithm</a></p>
<p><strong>Java基础</strong></p>
<p>Java集合源码复习一遍</p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Java/%E9%9B%86%E5%90%88/ArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">ArrayList源码解析</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Java/%E9%9B%86%E5%90%88/LinkedList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">LinkedList源码解析</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Java/%E9%9B%86%E5%90%88/CopyOnWriteArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">CopyOnWriteArrayList源码解析</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Java/%E9%9B%86%E5%90%88/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">HashMap源码解析</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Java/%E9%9B%86%E5%90%88/ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">ConcurrentHashMap源码解析</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Java/%E9%9B%86%E5%90%88/TreeMap%E5%92%8CLinkedHashMap.md">TreeMap 和 LinkedHashMap</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Java/%E9%9B%86%E5%90%88/HashSet%E5%92%8CTreeSet.md">HashSet 和 TreeSet</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Java/%E9%9B%86%E5%90%88/Android%E4%B8%AD%E7%9A%84Bundle,SparseArray%E5%92%8CArrayMap.md">Android中的Bundle,SparseArray和ArrayMap</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Java/%E5%9F%BA%E7%A1%80/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82String,StringBuffer,StringBuilder_20180420.md">从源码角度彻底搞懂String,StringBuffer,StringBuilder_20180420</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Java/%E5%9F%BA%E7%A1%80/String.md">String</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Java/%E5%9F%BA%E7%A1%80/%E6%B3%9B%E5%9E%8B.md">泛型</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Java/%E5%9F%BA%E7%A1%80/%E5%BC%82%E5%B8%B8.md">异常</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Java/%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84.md">反射</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Java/%E5%9F%BA%E7%A1%80/%E6%B3%A8%E8%A7%A3.md">注解</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Java/%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84%E6%80%A7%E8%83%BD%E5%BC%80%E9%94%80%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96.md">反射性能开销原理及优化</a></p>
<p>《深入理解Java虚拟机》</p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Java/JVM/1.JVM%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.md">JVM内存数据区域</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Java/JVM/2.HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1.md">HotSpot虚拟机对象</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Java/JVM/3.%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.md">垃圾收集器与内存分配策略</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Java/JVM/4.Java%E5%AD%97%E8%8A%82%E7%A0%81(class%E6%96%87%E4%BB%B6)%E8%A7%A3%E8%AF%BB.md">Java字节码(class文件)解读</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Java/JVM/5.%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%AE%80%E4%BB%8B.md">字节码指令简介</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Java/JVM/6.%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.md">虚拟机类加载机制</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Java/JVM/7.%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.md">虚拟机字节码执行引擎</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Java/JVM/8.%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96.md">前端编译与优化</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Java/JVM/9.%E5%90%8E%E7%AB%AF%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96.md">后端编译与优化</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Java/JVM/10.Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.md">Java内存模型与线程</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Java/JVM/11.%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96.md">线程安全与锁优化</a></p>
<p>拉钩教育-《Android 工程师进阶34讲》</p>
<p>拉钩教育-《Java 并发编程 78 讲》</p>
<ol>
<li></li>
</ol>
<p><strong>Android</strong></p>
<p>《安卓开发艺术探索》</p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%AD%BB%E7%A3%95Android_View%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E5%88%87.md">死磕Android_View工作原理你需要知道的一切</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%AD%BB%E7%A3%95Android_App_%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%EF%BC%88%E5%90%AB_Activity_%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%EF%BC%89.md">死磕Android_App_启动过程（含_Activity_启动过程）</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%AD%BB%E7%A3%95Android_Service%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(%E4%B8%80).md">死磕Android_Service启动流程分析(一)</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%AD%BB%E7%A3%95Android_Service%E7%BB%91%E5%AE%9A%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90(%E4%BA%8C).md">死磕Android_Service绑定流程分析(二)</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%AD%BB%E7%A3%95Android_BroadcastReceiver_%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.md">死磕Android_BroadcastReceiver_工作过程</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Lifecycle_%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90.md">Lifecycle_原理解析</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/ViewModel_%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90.md">ViewModel_使用及原理解析</a></p>
<p><a href="https://juejin.cn/post/7013640663824597005">Jetpack全家桶</a></p>
<p><a href="https://juejin.cn/post/6844903889574051848">学习Android Jetpack? 实战和教程这里全都有！</a></p>
<p><a href="https://juejin.cn/post/6893870636733890574">Lifecycle</a></p>
<p><a href="https://juejin.cn/post/6903143273737814029">LiveData</a></p>
<p><a href="https://juejin.cn/post/6915012483421831175">ViewModel</a></p>
<p><a href="https://juejin.cn/post/6921321173661777933">MVVM</a></p>
<p><a href="https://juejin.cn/post/6923859213403979789">DataBinding</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Handler%E6%9C%BA%E5%88%B6%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E5%88%87.md">Handler机制你需要知道的一切</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/%E6%AD%BB%E7%A3%95Android_ContentProvider_%E5%90%AF%E5%8A%A8.md">死磕Android_ContentProvider_启动 </a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/LiveData_%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90.md">LiveData_使用及原理解析</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Window,Activity,View%E4%B8%89%E8%80%85%E5%85%B3%E7%B3%BB.md">Window,Activity,View三者关系</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Handler%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9C.md">Handler同步屏障</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Choreographer%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8.md">Choreographer原理及应用</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Handler%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%A7%E5%85%A8.md">Handler相关知识点大全</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/%E4%B8%89%E6%96%B9%E5%BA%93%E5%8E%9F%E7%90%86/LeakCanary_%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6.md">LeakCanary 原理探究</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/%E4%B8%89%E6%96%B9%E5%BA%93%E5%8E%9F%E7%90%86/OkHttp3_%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6.md">OkHttp3 原理探究</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/%E4%B8%89%E6%96%B9%E5%BA%93%E5%8E%9F%E7%90%86/Retrofit_%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90.md">Retrofit 原理解析</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/%E4%B8%89%E6%96%B9%E5%BA%93%E5%8E%9F%E7%90%86/Glide%E4%B8%BB%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md">Glide主流程源码解析</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/%E4%B8%89%E6%96%B9%E5%BA%93%E5%8E%9F%E7%90%86/RxJava3%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90.md">RxJava3原理解析</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/%E4%B8%89%E6%96%B9%E5%BA%93%E5%8E%9F%E7%90%86/Android-skin-support%E6%8D%A2%E8%82%A4%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3.md">Android-skin-support 换肤原理详解</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/%E5%AE%9E%E6%88%98%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D.md">屏幕适配</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/%E5%AE%9E%E6%88%98%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E6%8F%92%E4%BB%B6%E5%8C%96.md">插件化</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/%E5%AE%9E%E6%88%98%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E7%83%AD%E6%9B%B4%E6%96%B0.md">热更新</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/Gradle/Gradle%E7%B3%BB%E5%88%97(%E4%B8%80)_Groovy_%E5%9F%BA%E7%A1%80.md">Gradle系列(一) Groovy 基础</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/Gradle/Gradle%E7%B3%BB%E5%88%97(%E4%BA%8C)_Gradle%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%92%8Ctask.md">Gradle系列(二) Gradle执行顺序和task</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/Gradle/Gradle%E7%B3%BB%E5%88%97(%E4%B8%89)_Gradle%E9%85%8D%E7%BD%AE%E6%9E%84%E5%BB%BA%E5%92%8C%E6%B8%A0%E9%81%93%E5%8C%85.md">Gradle系列(三) Gradle配置构建和渠道包</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/Gradle/Gradle%E7%B3%BB%E5%88%97(%E5%9B%9B)_Gradle%E6%8F%92%E4%BB%B6.md">Gradle系列(四) Gradle插件</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/Gradle/Gradle%E7%B3%BB%E5%88%97_%E6%8F%92%E4%BB%B6%E7%BB%83%E4%B9%A0-%E5%8A%A8%E6%80%81%E7%A7%BB%E9%99%A4%E6%9D%83%E9%99%90.md">Gradle系列 插件练习-动态移除权限</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/Gradle/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E5%A4%A7%E5%AE%B6%E7%94%A8Transform_API%E5%92%8CASM%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%B2%E5%BF%AB%E9%80%9F%E7%82%B9%E5%87%BB%E6%A1%88%E4%BE%8B.md">手把手教大家用Transform API和ASM实现一个防快速点击案例</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/%E5%A4%9A%E8%BF%9B%E7%A8%8B/AIDL%E8%AF%A6%E8%A7%A3.md">Android进程间通信: 深入浅出AIDL</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/%E5%A4%9A%E8%BF%9B%E7%A8%8B/Messenger%E8%AF%A6%E8%A7%A3.md">Android进程间通信: Messenger详解</a></p>
<p><a href="https://github.com/xfhy/Android-Notes/blob/master/Blogs/Android/%E5%A4%9A%E8%BF%9B%E7%A8%8B/Binder%E8%AF%A6%E8%A7%A3.md">Android进程间通信: Binder详解</a></p>
<p><a href="https://mp.weixin.qq.com/s/b6-leHKQZkuxkjll-1109A">硬核！Android 应用启动全流程深度剖析！（进程创建+消息机制+Activity组件管理+Application和Activity初始化+UI布局与绘制+RenderThread渲染+SurfaceFlinger合成）</a></p>
<p><a href="https://blog.csdn.net/xfhy_/article/details/115436765?spm=1001.2014.3001.5502">Choreographer原理及应用</a></p>
<p><a href="https://juejin.cn/post/6863756420380196877">终于懂了，屏幕刷新</a></p>
<p><a href="https://juejin.cn/post/6854573212374663182">View工作原理</a></p>
<p><a href="https://juejin.cn/post/6844904106545414157">编译基础</a></p>
<p><a href="https://juejin.cn/post/6844903613865672718">Android插件化原理（一）Activity插件化</a></p>
<p><a href="http://liuwangshu.cn/tags/ClassLoader/">ClassLoader</a></p>
<p><a href="https://rengwuxian.com/tag/kotlin/">hencoder全部Kotlin部分</a></p>
<p><a href="https://rengwuxian.com/tag/custom-view/">hencoder全部自定义View部分</a></p>
<p><a href="https://juejin.cn/post/6862548590092140558">协程原理</a></p>
<p><a href="https://juejin.cn/post/6914802148614242312">flow</a></p>
<p><a href="https://juejin.cn/post/6884505736836022280">反思｜官方也无力回天？Android SharedPreferences的设计与实现</a></p>
<p><a href="https://blog.csdn.net/hzwailll/article/details/85339714">ActivityThread的理解</a></p>
<p><a href="http://liuwangshu.cn/tags/ActivityManagerService/">了解AMS</a></p>
<p><a href="https://blog.csdn.net/zhaoyanjun6/article/details/76408024">Android Gradle 自定义Task 详解</a></p>
<p><a href="https://juejin.cn/post/6844904106545414157">编译打包流程</a></p>
<p><a href="https://juejin.cn/post/6844903446814916621#comment">Android Gradle 看这一篇就够了</a></p>
<p>真题：</p>
<p>/  面试真题  /</p>
<p>只记录了部分公司和部分题目，有时候面试完忘记记录了，后面就想不起来了。</p>
<p><strong>公司1：</strong></p>
<ul>
<li>包体积优化</li>
<li>handler原理</li>
<li>如何退出app</li>
<li>synchronized和lock</li>
<li>鸿蒙了解过吗</li>
<li>flutter了解过吗，compose呢</li>
<li>跨进程通信，线程通信</li>
<li>组件化是怎么做的</li>
<li>做过的项目，主要负责什么</li>
<li>担任的角色</li>
<li>最难的是什么？怎么解决的</li>
<li>开发流程是怎么样的？有做设计文档吗？</li>
<li>职业规划，为什么做安卓？鸿蒙有了解吗？</li>
<li>平时怎么学习的？最近学了什么？给工作带来了哪些好处？</li>
<li>看过哪些技术书籍</li>
<li>平时有什么爱好</li>
<li>对你想要去的公司团队有什么要求？或者说你想去什么氛围的项目组？</li>
</ul>
<p><strong>公司2：</strong></p>
<ul>
<li>sleep和wait区别</li>
<li>mvp</li>
<li>组件化</li>
<li>livedata，viewmodel原理</li>
<li>内存优化</li>
<li>启动优化</li>
<li>leakcanary原理</li>
<li>换肤原理</li>
<li>怎么hook ams</li>
</ul>
<p><strong>公司3：</strong></p>
<ul>
<li>volatile、synchronized、原子类的原理</li>
<li>数据库优化是怎么做的</li>
<li>性能优化</li>
<li>kotlin伴生对象和init</li>
<li>斐波拉契序列</li>
<li>反转链表</li>
</ul>
<p><strong>公司4：</strong></p>
<ul>
<li>fragment生命周期</li>
<li>屏幕刷新机制</li>
<li>binder理解</li>
<li>bindService校验: 权限，包名</li>
<li>https的原理</li>
<li>热修复:class和资源</li>
<li>invalidate 和 postInvalidate区别</li>
<li>handler原理，sendMessageDelayed是怎么实现的，为什么不卡主线程，底层是如何通知进程这边恢复阻塞的</li>
<li>java掌握到什么程度了，kotlin呢？android呢？</li>
<li>响应式编程</li>
<li>看过哪些书？推荐一本你觉得不错的书，为什么不错</li>
<li>android最近这2年值得关注的框架</li>
<li>敏捷开发模式</li>
<li>你给你自己的水平打分，计划怎么完善和精进自己的技术栈</li>
</ul>
<p><strong>公司5：</strong></p>
<ul>
<li>app启动过程+activity启动过程，activity启动过程中的launchmode的原理</li>
<li>handler</li>
<li>java 方法重载问题，泛型相关</li>
<li>卡顿优化，冷启动优化，线上监控方式</li>
<li>慢函数线上监控</li>
</ul>
<p><strong>公司6：</strong></p>
<ul>
<li>3个线程如何依次执行</li>
<li>设计一个图片加载库，lrucache原理，linkedhashmap实现</li>
<li>lifecycle,viewmodel原理</li>
<li>view事件分发</li>
</ul>
<p><strong>公司7：</strong></p>
<ul>
<li>gc roots</li>
<li>JVM垃圾回收算法，Android虚拟机垃圾回收算法</li>
<li>分代回收思想</li>
<li>Java类加载机制</li>
<li>线程池有几种，分别是什么特征，自定义线程池需要注意什么，核心线程数是多少</li>
<li>hashmap原理（红黑树会退成链表吗？什么情况下？），ConcurrentHashMap原理，Hashtable原理</li>
<li>StringBuilder和StringBuffer原理</li>
<li>反射原理及其优缺点</li>
<li>泛型拿来做什么的</li>
<li>synchronized用法及原理，1.6做了哪些优化，Mark word</li>
<li>常用的三方库原理，随便挑一个说</li>
<li>换肤原理</li>
<li>动画有哪几种，属性动画原理,vsync</li>
<li>View绘制流程</li>
<li>短时间内多次调用requestLayout，哪些View会重绘</li>
<li>冷启动优化</li>
<li>包体积优化</li>
<li>插件化原理，startActivity</li>
<li>mvc,mvp,mvvm</li>
<li>requestLayout流程</li>
<li>算法1：反转单词</li>
<li>算法2：环形链表求环入口节点，不准用快慢指针，O(1)空间复杂度，O(n)时间复杂度，可修改链表节点的指针和数据。不能在链表节点中新增属性</li>
</ul>
<p><strong>公司8：</strong></p>
<ul>
<li>说一下项目的架构，哪一块是你主要负责的？说一下是怎么设计的</li>
<li>livedata原理</li>
<li>handler原理</li>
<li>组件化传递大数据</li>
<li>单例里面的数据线程安全</li>
<li>内存优化，卡顿优化，冷启动优化</li>
<li>怎么检测已发生了内存泄露的对象？不知道那个对象是谁</li>
<li>协程和RxJava原理，区别</li>
</ul>
<p><strong>公司9：</strong></p>
<ul>
<li>view绘制流程</li>
<li>事件分发流程，外部拦截法，内部拦截法</li>
<li>Kotlin协程，协程原理，怎么开协程，怎么切线程</li>
<li>viewpager内部view高度不一致，怎么解决</li>
<li>startActivity流程</li>
<li>启动优化，包体积优化</li>
<li>livedata原理</li>
<li>gradle 马甲包</li>
<li>换肤原理</li>
<li>协程状态机</li>
<li>let和also区别</li>
<li>mvvm</li>
</ul>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 面试宝典</title>
    <url>/2022/07/08/Android/Android%20%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<hr>
<p><a href="https://blog.csdn.net/qq_34512207/category_11650741.html?spm=1001.2014.3001.5482">面试专栏</a></p>
<p><a href="https://blog.csdn.net/qq_45485851/article/details/116099126">面试总结</a></p>
<p><a href="https://binkery.com/archives/11.html">Android面试题目</a></p>
<hr>
<p><a href="https://www.jianshu.com/p/80684557fa42">Android中高级面试题合集，含答案</a></p>
<p><a href="https://github.com/JsonChao/Awesome-Android-Interview/blob/master/Android%E7%9B%B8%E5%85%B3/Android%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98.md">Android基础面试题</a></p>
<p><a href="https://blog.csdn.net/xiangzhihong8/category_9266355.html">深入Android应用开发</a></p>
<p>###博客<br><a href="https://blog.csdn.net/guolin_blog/">guolin</a></p>
<p><a href="https://blog.csdn.net/carson_ho/category_9270381.html?spm=1001.2014.3001.5482">Carson带你学Android</a></p>
<p><a href="https://www.zhangshengrong.com/category/android/2/">张生荣</a></p>
<p><a href="https://shoewann0402.github.io/categories/">shoewann</a></p>
<p><a href="https://yuweiguocn.github.io/">android分析</a></p>
<p><a href="https://tobebetterjavaer.com/home.html">Java进阶</a></p>
<p><a href="https://blog.csdn.net/callmezhe/category_7430857.html?spm=1001.2014.3001.5482">CallmeZhe</a></p>
<p><a href="https://blog.csdn.net/huangqili1314/article/details/79824830">Android(2017-2018)BAT面试题整理</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 33讲</title>
    <url>/2022/07/28/Android/Android%2033%E8%AE%B2/</url>
    <content><![CDATA[<hr>
<h2 id="Android进阶34讲"><a href="#Android进阶34讲" class="headerlink" title="Android进阶34讲"></a>Android进阶34讲</h2><h2 id="Android进阶34讲-1"><a href="#Android进阶34讲-1" class="headerlink" title="Android进阶34讲"></a>Android进阶34讲</h2><h2 id="1、运行时内存分配"><a href="#1、运行时内存分配" class="headerlink" title="1、运行时内存分配"></a>1、运行时内存分配</h2><blockquote>
<p>将Java的内存分为堆（heap）内存和栈内存（stack）实际上，Java虚拟机在执行java程序的过程钟，会把它所管理的内存划分为不同的数据区域</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/08/07/rft6ZoBQGeph1un.png" alt="image-20220703175531282"></p>
<ul>
<li><p><code>程序计数器</code>：Java程序是多线程的，CPU可以在多个线程中分配执行的时间片段</p>
<ul>
<li>作用：当某一个线程被CPU挂起时，需要记录代码已经执行的位置，方便CPU重新执行此线程时，知道从哪行指令开始执行</li>
<li>是虚拟机中一块较小的内存空间，主要用于记录当前线程执行的位置</li>
<li><img src="https://s2.loli.net/2022/08/07/WBNYa5wbVMpXmqC.png" alt="image-20220703175822819"></li>
</ul>
<p><strong>关于程序计数器的几点注意：</strong></p>
<ol>
<li><p>在Java虚拟机规范中对程序计数器这一区域没有规定任何OutOfMemoryError情况</p>
</li>
<li><p>程序计数器是线程私有的，每条线程内部都有一个私有程序计数器它的生命周期随着线程的创建而创建，随着线程的结束而死亡3.当一个线程正在执行一个Java方法的时候，这个计数器记录的是正在执行的虚拟机字节码指令的地址如果正在执行的是Native方法，这个计数器值则为空（Undefined）</p>
</li>
</ol>
</li>
<li><p><code>虚拟机栈</code>：是线程私有的，与线程的生命周期同步。在java虚拟机中规范中，对这个去域规定了两种异常情况：</p>
<ul>
<li>**<code>StackOverflowError</code>**：当线程请求栈深度超过虚拟机栈所允许的深度时抛出</li>
<li>**<code>OutOfMemoryError</code>**：当Java虚拟机动态扩展到无法申请足够内容时抛出</li>
</ul>
</li>
<li><p><code>Java堆（Heap）</code></p>
<ul>
<li><p>是JVM所管理的内存中最大的一块，该区域唯一目的就是存放对象实例</p>
</li>
<li><p>是Java垃圾收集器（GC）管理的主要区域，有时候也叫作“GC堆”</p>
</li>
<li><p>是所有线程共享的内存区域</p>
<p>被分配在此区域的对象如果被多个线程访问，需要考虑线程安全问题</p>
</li>
</ul>
<p>按照对象存储时间的不同，可分为：</p>
<p><img src="https://s2.loli.net/2022/08/24/PBwte9SXdoARMcz.png" alt="image-20220821210700053.png"></p>
</li>
<li><p><code>方法区（Method Area）</code>是JVM规范里规定的一块运行时数据区<br>方法区主要是存储：</p>
<ul>
<li>已经被JVM加载的类信息（版本、字段、方法、接口）</li>
<li>常量</li>
<li>静态变量</li>
<li>即时编译器编译后的代码</li>
<li>数据<br><strong>该区域是被各个线程共享的内存区域</strong></li>
</ul>
<p><strong>总结：</strong><br><code>方法区</code>：是规范层面的东西，规定了这一个区域要存放哪些数据</p>
<p><code>永久区或者是metaspace</code>：是对方法区的不同实现，是实现层面的东西</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/08/24/iIeWLFAtZYPHfJ1.png" alt="image-20220821211309132.png"></p>
<h2 id="2、GC回收机制与分代回收策略"><a href="#2、GC回收机制与分代回收策略" class="headerlink" title="2、GC回收机制与分代回收策略"></a>2、GC回收机制与分代回收策略</h2><blockquote>
<p>垃圾回收(Grabage Collection,GC)</p>
<p>程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作这几个区域内不需要过多考虑回收的问题</p>
<p>堆和方法区需要回收，垃圾就是内存中已经没有用的对象</p>
<p>Java虚拟机中使用一种叫作”<code>可达性分析</code>”的算法<code>来决定对象是否可以被回收</code></p>
</blockquote>
<p><img src="https://s2.loli.net/2022/08/24/sCq1xofcWFH4MV3.png" alt="image-20220821211722392.png"></p>
<p>在Java中，有以下几种对象可以作为GC Root：</p>
<ol>
<li>Java虚拟机栈（局部变量表）中的引用的对象</li>
<li>方法区中静态引用指向的对象</li>
<li>仍处于存活状态中的线程对象</li>
<li>Native方法中JNI引用的对象</li>
</ol>
<p><strong><code>不同的虚拟机实现有着不同的GC实现机制</code></strong></p>
<p>一般情况下每一种GC实现都会在以下两种情况下触发垃圾回收：</p>
<ol>
<li><strong>Allocation Failure</strong>：在堆内存中分配时，如果因为可用剩余空间不足导致对象内存分配失败这时系统会触发一次GC</li>
<li><strong>System.gc（）</strong>：在应用层，Java 开发工程师可以主动调用此API来请求一次GC</li>
</ol>
<blockquote>
<p>执行Java命令时的参数<br>     -Xms初始分配JVM运行时的内存大小，如果不指定默认为物理内存的1/64</p>
<p>从物理内存中分配出200M空间分配给JVM内存</p>
<p><code>java -Xms200m HelloWorld</code></p>
</blockquote>
<h4 id="1、-如何回收垃圾"><a href="#1、-如何回收垃圾" class="headerlink" title="1、 如何回收垃圾:"></a><strong>1、 如何回收垃圾:</strong></h4><p><code>标记清除算法（Mark and Sweep GC）</code></p>
<p>从”GCRoots”集合开始，将内存整个遍历一次,保留所有可以被GC Roots直接或间接引用到的对象，而剩下的对象都当作垃圾对待并回收过程分两步：</p>
<ol>
<li><code>Mark 标记阶段</code>：找到内存中的所有GC Root对象，只要是和GCRoot对象直接或者间接相连则标记为灰色（也就是存活对象），否则标记为黑色（也就是垃圾对象）</li>
<li><code>Sweep 清除阶段</code>：当遍历完所有的GCRoot之后，则将标记为垃圾的对象直接清除</li>
</ol>
<p><img src="https://s2.loli.net/2022/08/24/eCvE7IqkMcWQ9Ah.png" alt="image-20220821220427076.png"></p>
<p><code>复制算法（Copying）</code></p>
<p>将现有的内存空间分为两快，每次只使用其中一块,在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中,之后清除正在使用的内存块中的所有对象交换两个内存的角色，完成垃圾回收</p>
<p><img src="https://s2.loli.net/2022/08/24/Wvq86kJscFMoLNK.png" alt="image-20220821220606062.png"></p>
<p><img src="https://s2.loli.net/2022/08/24/tMVqWQbrZxHzSkN.png" alt="image-20220821220625309.png"></p>
<p><code>标记-压缩算法（Mark-Compact）</code></p>
<p>需要先从根节点开始对所有可达对象做一次标记</p>
<p>之后并不简单地清理未标记的对象，而是将所有的存活对象压缩到内存的一端最后清理边界外所有的空间</p>
<p>标记压缩也分两步完成：</p>
<ol>
<li><code>Mark 标记阶段：</code>找到内存中的所有GC Root对象，只要是和GC Root对象直接或者间接相连则标记为灰色（也就是存活对象），否则标记为黑色（也就是垃圾对象）</li>
<li><code>Compact压缩阶段：</code>将剩余存活对象按顺序压缩到内存的某一端</li>
</ol>
<p><img src="https://s2.loli.net/2022/08/24/7a6GYVxdMlrcNug.png" alt="image-20220821220855955.png"></p>
<h4 id="2、JVM分代回收策略："><a href="#2、JVM分代回收策略：" class="headerlink" title="2、JVM分代回收策略："></a><strong>2、JVM分代回收策略：</strong></h4><p>Java虚拟机根据对象存活的周期不同</p>
<p>把堆内存划分为<code>新生代</code>、<code>老年代</code>，这就是JVM的内存分代策略</p>
<p>注意：在HotSpot中除了新生代和老年代，还有<code>永久代</code></p>
<p><strong>分代回收的中心思想：</strong></p>
<p>对于新创建的对象会在新生代中分配内存，此区域的对象生命周期一般较短，如果经过多次回收仍然存活下来，则将它们转移到老年代中。</p>
<p><code>年轻代（Young Generation）</code>新生成的对象优先存放在新生代中，存活率很低</p>
<p>新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，<a href="">回收效率很高</a></p>
<p>所以一般采用的GC回收算法是<strong>复制算法</strong></p>
<p>新生代细分为3部分：Eden、Survivor0（简称S0）、Survivor1（简称S1）这3部分</p>
<p>按照8：1：1的比例来划分新生代</p>
<p><img src="https://s2.loli.net/2022/08/24/Pp3lAuNCMSQxgKj.png" alt="image-20220821221508815.png"></p>
<p>Eden区域满的时候，会进行第一次垃圾回收，把存活对象发在S0</p>
<p><img src="https://s2.loli.net/2022/08/24/DnJAF6IB7ic5GXb.png" alt="image-20220821221539884.png"></p>
<p>下一次Eden区域满的时候，会再次执行一次垃圾回收，清空Eden和S0区域垃圾对象</p>
<p><img src="https://s2.loli.net/2022/08/24/8ktUdvTSs1NP4Ol.png" alt="image-20220821221715229.png"></p>
<p>不断切换Eden和S0、S1，15次之后，还有存活的对象，则将这部分对象发在老年代tenured区域中。</p>
<p><img src="https://s2.loli.net/2022/08/24/E9vZXgnhePYfd3A.png" alt="image-20220821221740861.png"></p>
<p><code>年老代（Old Generation）</code></p>
<p>一个对象如果在新生代存活了足够长的时间而没有被清理掉，则会被复制到老年代</p>
<p>老年代的内存大小一般比新生代大，能存放更多的对象</p>
<p>如果对象比较大（比如长字符串或者大数组），并且新生代的剩余空间不足</p>
<p>则这个大对象会直接被分配到老年代上</p>
<p>可以使用<a href=""><strong>-XX:PretenureSizeThreshold</strong></a>来控制直接升入老年代的对象大小</p>
<p>因为对象的生明周期较长，不需要过多的复制操作，所以一般采用标记压缩的回收算法</p>
<p><strong>GC Log分析</strong></p>
<p>其中新生代和老年代所打印的日志是有区别的：</p>
<ul>
<li><p><a href="">新生代GC：</a></p>
<p>这一区域的GC叫作Minor GC</p>
<p>因为Java对象大多都具备朝生夕灭的特性，所以MinorGC非常频繁，一般回收速度也比较快</p>
</li>
<li><p><code>老年代GC：</code></p>
<p>发生在这一区域的GC也叫作 Major GC或者Full GC</p>
<p>当出现了MajorGC，经常会伴随至少一次的Minor GC</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>命令参数</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>-verbose:gc</td>
<td>显示GC的操作内容</td>
</tr>
<tr>
<td>-Xms20M</br>-Xmx20M</td>
<td>初始化堆大小为20M</br>设置堆最大分配内存20M</td>
</tr>
<tr>
<td>Xmn10M</td>
<td>设置新生代的内存大小为10M</td>
</tr>
<tr>
<td>-XX：+printGCDetails</td>
<td>打印GC的详细log日志</td>
</tr>
<tr>
<td>-XX:SurvivorRatio=8</td>
<td>新生代中Eden区域与Survivor区域的大小比值为8：1：1</td>
</tr>
</tbody></table>
<p>通过GC Roots的引用可达性来判断的对象是否存活</p>
<p>JVM中的引用关系根据引用强度的由强到弱，他们分别是：</p>
<ul>
<li>强引用（Strong Reference）</li>
<li>软引用（Soft Reference）</li>
<li>弱引用（Weak Reference）</li>
<li>虚引用（Phantom Reference）</li>
</ul>
<table>
<thead>
<tr>
<th>引用</th>
<th>GC回收时机</th>
<th>使用示例</th>
</tr>
</thead>
<tbody><tr>
<td>强引用</td>
<td>如果一个对象具有强引用，那垃圾收器绝不会回收它</td>
<td>object obj=new object（）；</td>
</tr>
<tr>
<td>软引用</td>
<td>在内存实在不足时，会对软引用进行回收</td>
<td>SoftReferencecobject&gt; softobj=newSoftReference（）；</td>
</tr>
<tr>
<td>弱引用</td>
<td>第一次GC回收时，如果垃圾回收器遍历到此弱引用，则将其回收</td>
<td>WeakReference<Object>weakObj=newWeakReference（）；</td>
</tr>
<tr>
<td>虚引用</td>
<td>一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过品引用来获取一个对象的实例</td>
<td>不会使用</td>
</tr>
</tbody></table>
<p><strong>软引用隐藏问题</strong></p>
<p>注意：</p>
<p>被软引用对象关联的对象会自动被垃圾回收器回收</p>
<p>但是软引用对象本身也是一个对象</p>
<p>这些创建的软引用并不会自动被垃圾回收器回收掉</p>
<h2 id="3、字节码层面分析cla类文件结构"><a href="#3、字节码层面分析cla类文件结构" class="headerlink" title="3、字节码层面分析cla类文件结构"></a>3、字节码层面分析cla类文件结构</h2><p>java中String字符串的长度有限制吗？</p>
<blockquote>
<p>java提供了一种可以在所有平台上都能使用的一种中间代码-字节码类文件(.class文件)</p>
<ul>
<li>有了字节码，无论是哪种平台只要安装了虚拟机都可以直接运行字节码</li>
<li>有了字节码，解除了Java虚拟机和Java语言之间的耦合</li>
</ul>
</blockquote>
<p><img src="https://s2.loli.net/2022/08/07/rfTteURCKQVwqn3.png" alt="image-20220703224242199"></p>
<p>从纵观的角度看，class文件里只有两种数据结构：<code>无符号数</code>和<a href="">表</a></p>
<ul>
<li><p>==无符号数==：属于基本的数据类型</p>
<p>以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或字符串(UTF-8编码)</p>
</li>
<li><p>==表==：表是多个无符号数或其他表作为数据项构成的复合数据类型</p>
<p>class文件中所有的表都以“_info”结尾</p>
<p>整个Class文件本质上就是一张表</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/08/07/hD8bNlRrJFWeSio.png" alt="image-20220703224802209"></p>
<h4 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h4><p>无符号数和表组成了class中的各个结构这些结构按照==预先规定好的顺序==紧密的从前向后排列，相邻的项之间没有任何间隙</p>
<p><img src="https://s2.loli.net/2022/08/24/N5Xla3rAjRCDnLg.png" alt="image-20220821224848178.png"></p>
<h2 id="13、Android是如何通过Activity进行交互的"><a href="#13、Android是如何通过Activity进行交互的" class="headerlink" title="13、Android是如何通过Activity进行交互的"></a>13、Android是如何通过Activity进行交互的</h2><h4 id="taskAffinity"><a href="#taskAffinity" class="headerlink" title="taskAffinity"></a>taskAffinity</h4><p>通过设置不同的启动模式可以实现调度不同的Task，但是taskAffinity在一定程度上也会影响任务栈的调配流程</p>
<p>每一个Activity都有一个Affinity属性，如果不在清单文件中指定，默认为当前应用的包名</p>
<blockquote>
<p>注意：</p>
<p><img src="https://s2.loli.net/2022/08/07/vwEBlAO2CDQHZXa.png" alt="image-20220722153848579"></p>
<p>点击First中的Button，从First页面跳转到Second页面</p>
<p>adb shell dumpsys activity activities</p>
<p>TaskRecord代表一个任务栈</p>
<p><img src="https://s2.loli.net/2022/08/07/Fhp2weZUrOJ183W.png" alt="image-20220722154010602"></p>
<p><img src="https://s2.loli.net/2022/08/07/kAH4rq3uGjlIRFy.png" alt="image-20220722154138806"></p>
<p>重新查看任务栈情况</p>
<p><img src="https://s2.loli.net/2022/08/07/c9rP3MKbdfTGJqZ.png" alt="image-20220722154204655"></p>
<p>修改Second的启动模式，修改为SingleTask</p>
<p><img src="https://s2.loli.net/2022/08/07/R7yfCTuPawvroLb.png" alt="image-20220722154252478"></p>
<p>单纯使用taskAffinity不能导致Activity被创建在新的任务栈中，需要配合**<code>singleTask或singleInstance</code>**.</p>
</blockquote>
<p>allowTaskReparenting赋予Activity在各个Task中间转移的特性</p>
<p>一个在后台任务中的Activity A当有其他任务前台，并且taskAffinity与A相同，则会自动将A添加到当前启动的任务栈中</p>
<h4 id="通过Binder传递数据的限制"><a href="#通过Binder传递数据的限制" class="headerlink" title="通过Binder传递数据的限制"></a>通过Binder传递数据的限制</h4><p>Activity 界面跳转时，使用Intent传递数据是最常用的操作，Intent传值也会导致数据崩溃。</p>
<p>方法一：减少通过Intent传递的数据，将非必须字段使用transient关键字修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startFirstB</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">	Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,FirstB.class);</span><br><span class="line">	intent.putExtra(<span class="string">&quot;bean&quot;</span>,<span class="keyword">new</span> Bean());<span class="comment">//传递Bean中的数据</span></span><br><span class="line">	startActivity(intent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">	String str = <span class="string">&quot;data string&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：将对象转化为JSON字符串，减少数据体积（Gson.toJson）</p>
<p>​             大多时候，将类转化为JSON字符串之后，还是会超出Binder限制这种情况则需要考虑使用本地持久化                来实现数据共享，或者使用EVentBus 来实现数据传递</p>
<h4 id="process造成多个Application"><a href="#process造成多个Application" class="headerlink" title="process造成多个Application"></a>process造成多个Application</h4><p>在自定义的Application中做一些初始化的操作，比如App分包、推送初始化、图片加载库的全局配置等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//图片加载全局设置</span></span><br><span class="line">ImagePipelineConfig config = ImagePipelineConfig.newBuilder(<span class="keyword">this</span>)</span><br><span class="line">							 .setDownsampleenabled(<span class="keyword">true</span>)</span><br><span class="line">							 .setProgressiveJpegConfig(<span class="keyword">new</span> SimpleProgressiveJpegConfig())</span><br><span class="line">							 .build();</span><br><span class="line"></span><br><span class="line">Fresco.initialize(<span class="keyword">this</span>,config);</span><br><span class="line"><span class="comment">//App 分包处理</span></span><br><span class="line">MultiDex.install(context);</span><br><span class="line"><span class="comment">//推送初始化</span></span><br><span class="line">JPushInterface.init(context);</span><br></pre></td></tr></table></figure>

<p>处理方式：</p>
<ul>
<li>onCreate方法中判断进程的名称，只有在符合要求的进程里，才执行初始化操作</li>
<li>抽象出一个与Application 生命周期同步的类，并根据不同的进程创建相应的Application实例</li>
</ul>
<h4 id="后台启动Activity失效"><a href="#后台启动Activity失效" class="headerlink" title="后台启动Activity失效"></a>后台启动Activity失效</h4><h2 id="14、彻底掌握Android-touch-事件分发时许"><a href="#14、彻底掌握Android-touch-事件分发时许" class="headerlink" title="14、彻底掌握Android touch 事件分发时许"></a>14、彻底掌握Android touch 事件分发时许</h2><p><a href="">分析角度：</a></p>
<ul>
<li>touch事件是如何从驱动层传递给Framework层的InputManagerService</li>
<li>WMS是如何通过ViewRoolmple将事件传递给目标窗口</li>
<li>touch事件到达DecorView后，是如何一步步传递到内部的子View中</li>
</ul>
<p>**<code>ViewGroup</code>**：是一组view的组合，在其内部有可能包含多个子view</p>
<p>当手指触摸屏幕上时，手指所在区域既能在viewGroup显示范围内，也可能在其内部view控件上。内部的事件分发的重心是处理**<code>当前Group和子View之间的逻辑关系:</code>**</p>
<ul>
<li>当前group是否需要拦截touch事件</li>
<li>是否需要将touch事件继续分发给子view</li>
<li>如何将touch事件分发给子view</li>
</ul>
<p>**<code>View</code>**：是一个单纯的控件，它的事件分发的重点在于当前的View如何去处理touch事件，并根据相应的手势逻辑进行一些列的效果展示(比如滑动，放大、点击、长按)</p>
<ul>
<li>是否存在touchListener</li>
<li>是否自己接收处理touch事件（主要逻辑在onTouchEvent方法中）</li>
</ul>
<h4 id="事件分发核心：dispatchTouchEvent"><a href="#事件分发核心：dispatchTouchEvent" class="headerlink" title="事件分发核心：dispatchTouchEvent"></a>事件分发核心：<code>dispatchTouchEvent</code></h4><p>整个view之间的事件分发，实质是一个大的递归函数，这个递归函数就是<code>dispatchTouchEvent</code>方法，在这个递归过程中会适时调用<code>onInterceptTouchEvent</code>来拦截事件或调用<code>onTouchEvent</code>方法来处理事件。</p>
<p><img src="https://s2.loli.net/2022/08/07/dtWMoGvI9KsVqDh.png" alt="image-20220722215754960"></p>
<p><img src="https://s2.loli.net/2022/08/07/olfbmyLQ2A9x1qj.png" alt="image-20220722220755799"></p>
<p><img src="https://s2.loli.net/2022/08/24/JwhuAtfyBgvR31r.png" alt="image-20220824231244226.png"></p>
<ol>
<li>表明事件主动分发的前提是事件为DOWN事件</li>
<li>遍历所有的子view</li>
<li>判断事件坐标是否在子view坐标范围内，并且子view并没有处于动画状态。</li>
<li>dispatchTransformedTOuchEvent方法将事件分发给子view，如果子view捕获事件成功，则将mFirstTouchTarget赋值给子view</li>
</ol>
<p><img src="https://s2.loli.net/2022/08/07/Ql5UHZdPLwDhAyG.png" alt="image-20220722221512901"></p>
<p>如果没有子view捕获处理touch事件，ViewGroup会通过自身的onTouchEvent方法进行处理。</p>
<h5 id="为什么Down事件特殊"><a href="#为什么Down事件特殊" class="headerlink" title="为什么Down事件特殊"></a>为什么Down事件特殊</h5><ul>
<li>所有touch事件都是从Down事件开始的</li>
<li>Down事件的处理结果会直接影响后续的MOVE、UP事件的逻辑</li>
</ul>
<p>只有Down事件会传递给子view进行捕获判断，一旦子View捕获成功，后续的MOVE和UP事件是通过遍历mFirstTouchTarger链表查找之前接收ACTION_DOWN的子View，并将触摸事件分配给子View</p>
<p><strong><code>后续的MOVE、UP等事件的分发交给谁，取决于他们的起始事件DOWN由谁捕获的</code></strong></p>
<h5 id="dispatchTouchEvent事件处理流程机制"><a href="#dispatchTouchEvent事件处理流程机制" class="headerlink" title="dispatchTouchEvent事件处理流程机制"></a>dispatchTouchEvent事件处理流程机制</h5><ul>
<li>判断是否需要拦截-&gt;主要根据onInterceptTouchEvent方法的返回值来决定是否拦截</li>
<li>在Down事件中将Touch事件分发给子View-&gt;这一过程如果有子View捕获消费了touch事件，会对mFirstTouchEvent进行赋值</li>
<li>DOWN、MOVE、UP事件都会根据mFirstTouchTarget是否为null，决定是自己处理touch事件还是再次分发给子view</li>
</ul>
<h5 id="事件分发特殊点"><a href="#事件分发特殊点" class="headerlink" title="事件分发特殊点"></a>事件分发特殊点</h5><p><strong>DOWN事件的特殊之处：</strong>事件的起点；决定后续事件由谁来消费处理</p>
<p>mFirstTouchEvent作用：记录捕获消费touch事件的view，是一个链表结构</p>
<p><strong>CANCEL事件的触发场景：</strong>当父视图先不拦截，然后在MOVE事件中重新拦截，此时子View会接收一个CANCEL事件</p>
<h2 id="15、自定义View"><a href="#15、自定义View" class="headerlink" title="15、自定义View"></a>15、自定义View</h2><p>自定义控件有两种方式：</p>
<ul>
<li><a href="">继承系统提供的成熟控件</a>（LinearLayout、RelativeLayout、ImageView）</li>
</ul>
<p>自定义属性： 在res的values目录下attrs.xml文件，使用<declare-styleable>标签<code>自定义属性</code><img src="https://s2.loli.net/2022/08/07/qdXfRH98z7BL6Mu.png" alt="image-20220722224750588"></p>
<p>获取自定义属性值：</p>
<p><img src="https://s2.loli.net/2022/08/07/G6ayXZd7iSkVhWR.png" alt="image-20220722224918096"></p>
<ul>
<li><p><a href="">直接继承系统View或ViewGroup</a>，并自绘制显示内容</p>
<p>注意问题：</p>
<ul>
<li>如何根据相应的属性将UI元素绘制到界面 —onDraw</li>
<li>自定义控件的大小，也就是宽和高分别设置多少 – onMeasure</li>
<li>如果是ViewGroup，如果合理安排其内部子view的摆放位置—onLayout</li>
</ul>
</li>
</ul>
<h5 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw:"></a>onDraw:</h5><p><img src="https://s2.loli.net/2022/08/07/rPAtBY9NHbuqnli.png" alt="image-20220722225216434"></p>
<p>paint的属性，就是一个画笔</p>
<p><img src="https://s2.loli.net/2022/08/07/f5j9JiGRpxl2SVE.png" alt="image-20220722225233994"></p>
<h5 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h5><p>直接在XML布局文件中定义好View的宽高，然后让自定义View在此宽高的区域内显示</p>
<p>Android系统提供了wrap_content和match_parent属性来规范空间的 显示规则</p>
<p>分别代表自适应大小和填充父视图的大小，这两个属性没有指定具体的大小，需要在onMeasure方法中过滤这两种情况。</p>
<p>三种测量模式</p>
<ul>
<li>EXACTLY:表示在XML布局文件中宽高使用match_parent或者固定大小的宽高</li>
<li>AT_MOST：表示在XML布局文件中宽高使用wrap_content</li>
<li>UNSPECIFIED:父容器没有对当前View有任何限制，当前View可以取任意尺寸，比如ListView中item</li>
</ul>
<p><img src="https://s2.loli.net/2022/08/07/F5jGdYntIBxQchT.png" alt="image-20220722230512812"></p>
<h2 id="16、RecyclerView"><a href="#16、RecyclerView" class="headerlink" title="16、RecyclerView"></a>16、RecyclerView</h2><p>目的：在有限的屏幕展示大量的内容，复用机制的实现是他的核心部分</p>
<p><strong><code>使用方法：</code></strong></p>
<p><code>setLayoutManager</code>:必选项，设置RV的布局管理器，决定RV的显示风格</p>
<p>常用的线性布局管理器(<code>LinearLayoutManager</code>)、网格布局管理器(<code>GridLayouManager</code>)、瀑布流布局管理器(<code>StaggerredGridLayoutManager</code>)</p>
<p><code>setAdapter</code>：必选项，设置RV的数据适配器</p>
<p>当数据发生改变时，以通知者的身份，通知RV数据改变进行列表刷新操作。</p>
<p><code>setItemDecoration</code>:非必选项，设置RV中item的装饰器，经常用来设置item的分割线</p>
<p><code>setItemAnimator</code>:非必选项，设置RV中Item的动画</p>
<p><img src="https://s2.loli.net/2022/08/07/tzhwEoNWHnX8rmP.png" alt="image-20220723111521958"></p>
<p>缓存复用：</p>
<p>主要实现了ViewHolder的缓存以及复用</p>
<p><img src="https://s2.loli.net/2022/08/07/H5ZMm1oPSpbkXnF.png" alt="image-20220723111608091"></p>
<p>缓存根据访问优先级从上到下分为4级</p>
<p><img src="https://s2.loli.net/2022/08/07/F8Uhq7B2YnLNR1d.png" alt="image-20220723111747076"></p>
<p>第一级缓存主要用来缓存屏幕内的viewHolder</p>
<p><img src="https://s2.loli.net/2022/08/07/4lBpFmyG1jM5NiD.png" alt="image-20220723114102836"></p>
<p>第二级缓存：</p>
<p>主要保存移除屏幕的viewitem，容量只有2</p>
<p><img src="https://s2.loli.net/2022/08/07/Gt8hIKzdfO2ykAN.png" alt="image-20220723114249098"></p>
<p>第三级缓存:继承之后实现自定义缓存</p>
<p><img src="https://s2.loli.net/2022/08/07/madyukroXe5St2W.png" alt="image-20220723114320300"></p>
<p>第四级缓存：</p>
<p><img src="https://s2.loli.net/2022/08/07/GHFyiTOBIAqegsx.png" alt="image-20220723114433945"></p>
<p>可以多个RV共享recycledViewPool，多个RV共享时，确保使用的apater是同一个</p>
<h5 id="核心实现："><a href="#核心实现：" class="headerlink" title="核心实现："></a>核心实现：</h5><ul>
<li>RV如何经过测量、布局、最终绘制到屏幕上，其中大部分工作是通过委托给LayoutManager来实现</li>
<li>RV的缓存复用机制，主要通过内部类Recycler来实现</li>
</ul>
<h2 id="17、OKhttp"><a href="#17、OKhttp" class="headerlink" title="17、OKhttp"></a>17、OKhttp</h2><blockquote>
<p>是一套处理Http网络请求的依赖库</p>
<p>Retrofit+OkHttp实现网络请求</p>
</blockquote>
<p>流程分析：</p>
<p><img src="https://s2.loli.net/2022/08/07/yEcFtJYmZQpPsxg.png" alt="image-20220723151013165"></p>
<p><img src="https://s2.loli.net/2022/08/07/SKI8hQX2sMpF3C4.png" alt="image-20220723151040597"></p>
<p><img src="https://s2.loli.net/2022/08/07/yOVAGzRIL6ETrah.png" alt="image-20220723151205002"></p>
<p><img src="https://s2.loli.net/2022/08/07/sKaWvdUg9xhJpQY.png" alt="image-20220723151228034"></p>
<p>Dispatcher是OkHttpClient的调度器，是一种门户模式，主要用来实现执行、取消异步请求操作。本质上是内部维护了一个线程池去执行异步操作，保证最大并发个数，同一host主机允许执行请求的线程个数。</p>
<p><img src="https://s2.loli.net/2022/08/07/YVfuU2AbdsiLMDj.png" alt="image-20220723151439147"></p>
<p><img src="https://s2.loli.net/2022/08/07/zIsqDbBw3AlxMEX.png" alt="image-20220723151543544"></p>
<p><img src="https://s2.loli.net/2022/08/07/zI4HxArthwSJBE8.png" alt="image-20220723151558636"></p>
<p><img src="https://s2.loli.net/2022/08/07/Ik6Ns7MOhLWeubv.png" alt="image-20220723151633961"></p>
<h2 id="18、Bitmap"><a href="#18、Bitmap" class="headerlink" title="18、Bitmap"></a>18、Bitmap</h2><blockquote>
<p>用来描述一张图片的长、宽、颜色等信息</p>
<p>可以使用BitmapFactory来将某一个路径下的图片解析为Bitmap对象</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/08/07/dCRnYaH5uOAxsNI.png" alt="image-20220723220323510"></p>
<p>BitmapFactory在解析图片的过程中，根据当前设备屏幕密度和图片所在的drawable目录来做一个对比，根据这个对比值进行缩放操作</p>
<p>公式：</p>
<p>缩放比例scale=当前设备屏幕密度/图片所在drawable目录对应的屏幕密度</p>
<p>Bitamp实际大小=宽*scale * 高 * scale  *Config对应的存储像素数</p>
<p><img src="https://s2.loli.net/2022/08/07/3novS8jQ4TmZdP5.png" alt="image-20220723221513397"></p>
<p>Android中的图片不仅可以保存在drawable目录中，还可以保存在assets目录下，然后通过AssetManager获取图片的输入流</p>
<p><img src="https://s2.loli.net/2022/08/07/FEmIwxQWVp4NJGX.png" alt="image-20220723221639170"></p>
<p>Bitmap优化：</p>
<ul>
<li><p>缩略优化：</p>
<ul>
<li><p>修改图片加载的config，一个像素占用两个字节</p>
<p><img src="https://s2.loli.net/2022/08/07/SX5ihAVx7bjJGk1.png" alt="image-20220723221729025"></p>
<p><img src="https://s2.loli.net/2022/08/07/IVdlxLNiU29BnWc.png" alt="image-20220723221824078"></p>
</li>
</ul>
</li>
</ul>
<p>Bitmap复用</p>
<ul>
<li><p>使用Options.inBitmap优化</p>
<p><img src="https://s2.loli.net/2022/08/07/W8LgKNt7msFv549.png" alt="image-20220723221955782"></p>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/08/07/lijwb6EQnA27IkC.png" alt="image-20220723222057256"></p>
<h2 id="19、startActivity启动过程分析"><a href="#19、startActivity启动过程分析" class="headerlink" title="19、startActivity启动过程分析"></a>19、startActivity启动过程分析</h2><p>在手机桌面应用中点击某一个icon之后，最终是通过 startActivity 去打开某一个Activity页面Android中的<code>一个App就相当于一个进程</code>，startActivity 操作中还需要判断，<code>目标Activity的进程是否已经创建，</code>如果没有，则在显示Activity之前还需要将进程Process提前创建出来。</p>
<p><img src="https://s2.loli.net/2022/08/25/Ik6978rvnCgm3Uo.png" alt="image-20220825074649126.png"></p>
<p>整个startActivity的流程分为3大部分，也涉及3个进程之间的交互：</p>
<ul>
<li>ActivityA–&gt;ActivityManagerService（简称AMS）</li>
<li>ActivityManagerService–&gt;ApplicationThread</li>
<li>ApplicationThread–&gt;Activity</li>
</ul>
<h5 id="ActivityA–-gt-ActivityManagerService阶段"><a href="#ActivityA–-gt-ActivityManagerService阶段" class="headerlink" title="ActivityA–&gt;ActivityManagerService阶段"></a>ActivityA–&gt;ActivityManagerService阶段</h5><p><img src="https://s2.loli.net/2022/08/25/TW52D4HnKBxesAj.png" alt="image-20220825074847930.png"></p>
<p><img src="https://s2.loli.net/2022/08/25/kJutxz197jAiMZR.png" alt="image-20220825074916021.png"></p>
<p><img src="https://s2.loli.net/2022/08/25/D7demF3kpJnWCHM.png" alt="image-20220825074943399.png"></p>
<p><img src="https://s2.loli.net/2022/08/25/NiIUBOA4EjeYSVZ.png" alt="image-20220825075032758.png"></p>
<h5 id="ActivityManagerService–-gt-ApplicationThread"><a href="#ActivityManagerService–-gt-ApplicationThread" class="headerlink" title="ActivityManagerService–&gt;ApplicationThread"></a>ActivityManagerService–&gt;ApplicationThread</h5><p><a href="">ApplicationThread 类</a>负责进程间通信</p>
<p>AMS最终调用了B进程中的一个ApplicationThread 引用，从而间接地通知B进程进行相应操作</p>
<p><code>AMS-&gt;ApplicationThread 流程：</code></p>
<ol>
<li>综合处理launchMode和Intent中的Flag标志位并根据处理结果生成一个目标 Activity B的对象（ActivityRecord）</li>
<li>判断是否需要为目标ActivityB创建一个新的进程（ProcessRecord）、新的任务栈（TaskRecord）</li>
</ol>
<p><img src="https://s2.loli.net/2022/08/25/VZCJFQYtXTULdO7.png" alt="image-20220825075305478.png"></p>
<p><img src="https://s2.loli.net/2022/08/25/G4Fhf6jdqOiIx2S.png" alt="image-20220825075346022.png"></p>
<p>最终会调用的ActivityStarter中的startActivityUnchecked方法来获取启动Activity的结果</p>
<p><img src="https://s2.loli.net/2022/08/25/FdCWekDZi6jz2T7.png" alt="image-20220825075511861.png"></p>
<p><img src="https://s2.loli.net/2022/08/25/fMNUutGS1x34noE.png" alt="image-20220825075525140.png"></p>
<h5 id="ActivityThread的handleLaunchActivity"><a href="#ActivityThread的handleLaunchActivity" class="headerlink" title="ActivityThread的handleLaunchActivity"></a>ActivityThread的handleLaunchActivity</h5><p><img src="https://s2.loli.net/2022/08/25/xNdbZCgSOVElMqo.png" alt="image-20220825080032196.png"></p>
<p><strong><code>Activity的启动在源码中的实现流程</code></strong></p>
<p>主要涉及3个进程间的通信过程：</p>
<ul>
<li><p>进程A通过Binder 调用AMS的startActivity方法</p>
</li>
<li><p>AMS通过一系列的计算构造目标Intent</p>
<p>然后在ActivityStack与ActivityStackSupervisor中处理Task和Activity的入栈操作</p>
</li>
<li><p>AMS通过Binder机制<br>调用目标进程中ApplicationThread的方法来创建并执行Activity生命周期方法</p>
<p>ApplicationThread 是ActivityThread的一个内部类，最终都调用到了ActivityThread中的相应方法</p>
</li>
</ul>
<h2 id="20、Window、Activity、View"><a href="#20、Window、Activity、View" class="headerlink" title="20、Window、Activity、View"></a>20、Window、Activity、View</h2><h4 id="Activity的setcontentView"><a href="#Activity的setcontentView" class="headerlink" title="Activity的setcontentView"></a>Activity的setcontentView</h4><p><img src="https://s2.loli.net/2022/08/07/SdjthBDfy2wLg4r.png" alt="image-20220726080408295"></p>
<p>屏幕绘制在Window中绘制，通过getwindow传入</p>
<p><img src="https://s2.loli.net/2022/08/07/4yi1UKq8M9XGShe.png" alt="image-20220726080515208"></p>
<p><img src="https://s2.loli.net/2022/08/07/ISWPHCeJfGhvrq5.png" alt="image-20220726080651976"></p>
<p>具体的setcontView</p>
<p><img src="https://s2.loli.net/2022/08/07/G25O3PVhvckZLHe.png" alt="image-20220726080803368"></p>
<p><img src="https://s2.loli.net/2022/08/07/oUzI9VfBDv8AxGT.png" alt="image-20220726080954106"></p>
<p>通过setcontview调用window的Phonewindow, DecorView是一个FragmentLayout，mContentParent是一个viewgroup，layoutId自定义布局</p>
<p>DecorView什么时候被绘制？</p>
<p><code>OnCreate阶段</code>只是初始化了Activiyt需要显示的内容</p>
<p><code>OnResume阶段</code>会将Phonewindow中的DecorView真正绘制到屏幕上。</p>
<p><img src="https://s2.loli.net/2022/08/07/z6798R4kfOXZuhG.png" alt="image-20220726081235367"></p>
<p>WindowManager的addview效果：</p>
<ul>
<li>decorView被渲染 绘制到屏幕上显示</li>
<li>Decorview可以接收屏幕触摸事件</li>
</ul>
<p><img src="https://s2.loli.net/2022/08/07/xiSJnUR3OHXcyCP.png" alt="image-20220726081428373"></p>
<p><img src="https://s2.loli.net/2022/08/07/WdL7ESJH8PO4tcA.png" alt="image-20220726081526485"></p>
<p><img src="https://s2.loli.net/2022/08/07/XoMk5EqSaQdVhmY.png" alt="image-20220726081605093"></p>
<p><img src="https://s2.loli.net/2022/08/07/FZtWdksnH6O8AS5.png" alt="image-20220726081637123"></p>
<p>addView成功的一个标志就是能够接受触屏事件</p>
<p>通过堆setContentView流程的分析，可以看出：</p>
<p>添加View的操作实质上是PhoneWindow在全盘操作，背后负责人是WMS</p>
<p>当触屏事件发生后，Touch事件首先被传入到Ac  tivity，然后被下发到布局的ViewGroup或View中。</p>
<h4 id="Touch事件如何传递到Activity上？"><a href="#Touch事件如何传递到Activity上？" class="headerlink" title="Touch事件如何传递到Activity上？"></a>Touch事件如何传递到Activity上？</h4><p><img src="https://s2.loli.net/2022/08/07/X4zCoJbhST91PAm.png" alt="image-20220726081939012"></p>
<p><img src="https://s2.loli.net/2022/08/07/PMweSu9QZxn5Uki.png" alt="image-20220726082122339"></p>
<h2 id="22、如何通过View进行渲染？"><a href="#22、如何通过View进行渲染？" class="headerlink" title="22、如何通过View进行渲染？"></a>22、如何通过View进行渲染？</h2><p>**<code>ViewRootImpl</code>**在整个流程中，起着承上启下的作用</p>
<ul>
<li>ViewRootImpl中通过Binder通信机制，远程调用WindowSession将View添加到Window中</li>
<li>ViewRootImpl在添加View之前，需要调用requestLayout方法，执行完成的View树的渲染操作。</li>
</ul>
<h5 id="ViewRootImpl-requestLayout流程"><a href="#ViewRootImpl-requestLayout流程" class="headerlink" title="ViewRootImpl requestLayout流程"></a>ViewRootImpl requestLayout流程</h5><p>请求布局操作</p>
<p><img src="https://s2.loli.net/2022/08/07/91LsRjMCrEumgYS.png" alt="image-20220727212613188"></p>
<p><img src="https://s2.loli.net/2022/08/07/uor46HxtJPWcsp2.png" alt="image-20220727213425948"></p>
<p>1：检测是否是合法进程。一般是主线程</p>
<p>2：</p>
<p><img src="https://s2.loli.net/2022/08/07/rBg3t4Z7lxOfaAM.png" alt="image-20220727213513228"></p>
<p><img src="https://s2.loli.net/2022/08/07/E3Y4VLCrXvqeG7m.png" alt="image-20220727213631052"></p>
<p><img src="https://s2.loli.net/2022/08/07/823orqbNaFnCIyR.png" alt="image-20220727213738218"></p>
<p>performTraversals()方法开始View绘制：measure-&gt;layout-&gt;draw</p>
<p><img src="https://s2.loli.net/2022/08/07/bi5VotW7UY1lAds.png" alt="image-20220727213844888"></p>
<p><img src="https://s2.loli.net/2022/08/07/WOpI1mR4FH2gyvr.png" alt="image-20220727213933371"></p>
<p><img src="https://s2.loli.net/2022/08/07/oqbwQ3fkMms6vIS.png" alt="image-20220727213959720"></p>
<p><img src="https://s2.loli.net/2022/08/07/9ETYs8wQDtRFxfh.png" alt="image-20220727214030873"></p>
<p>//注释1</p>
<p>ViewRootImpl中有一个非常重要的对象Surface</p>
<p>ViewRootImpl的一个核心功能是负责UI渲染</p>
<p>在ViewRootImpl中会将在draw方法中绘制的UI元素，绑定到这个Surface上，Surface中的内容最终会被传递给底层的SurfaceFliger。</p>
<p>最终将Surface中的内容进行合成并显示到屏幕上。</p>
<p>//注释2</p>
<p><img src="https://s2.loli.net/2022/08/07/gU3LljGdRXH8m2B.png" alt="image-20220727214358889"></p>
<p>默认情况下，软件绘制没有采用GPU渲染的方式，drawSoftware工作完全由CPU来完成。</p>
<p><img src="https://s2.loli.net/2022/08/07/GUiIeMopZgxmH9y.png" alt="image-20220727214517048"></p>
<p>启动硬件加速：</p>
<p><img src="https://s2.loli.net/2022/08/07/ZeWpIuzS97atvif.png" alt="image-20220727214558053"></p>
<p><img src="https://s2.loli.net/2022/08/07/eRH5vALxIr1kWgY.png" alt="image-20220727214613991"></p>
<p><img src="https://s2.loli.net/2022/08/07/ds6hex5Ztl8apQu.png" alt="image-20220727214627640"></p>
<h5 id="Invalidate轻量刷新"><a href="#Invalidate轻量刷新" class="headerlink" title="Invalidate轻量刷新"></a>Invalidate轻量刷新</h5><p><img src="https://s2.loli.net/2022/08/07/sYcQz273xTRW8pg.png" alt="image-20220727214847934"></p>
<p>**<code>invalidate</code><strong>与</strong><code>postInvalidate</code>**两者之间的区别</p>
<p>**<code>invalidate</code><strong>是在UI线程调用，</strong><code>postInvalidate</code>**是在非UI线程调用</p>
<p><img src="https://s2.loli.net/2022/08/07/bTZtLFAVu2adhq7.png" alt="image-20220727215134246"></p>
<p><img src="https://s2.loli.net/2022/08/07/fm6PzTchLeiOJDE.png" alt="image-20220727215259092"></p>
<h2 id="22、APP安装"><a href="#22、APP安装" class="headerlink" title="22、APP安装"></a>22、APP安装</h2><blockquote>
<p>PackageManagerService（PMS ）</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/08/07/Xd5MKtUwFcgYhD9.png" alt="image-20220727220520673"></p>
<p>每一个module中的内容可以分为2部分：</p>
<ul>
<li>resources资源文件</li>
<li>Java或者Kotlin源代码</li>
</ul>
<h5 id="编译阶段–Resources资源文件"><a href="#编译阶段–Resources资源文件" class="headerlink" title="编译阶段–Resources资源文件"></a>编译阶段–Resources资源文件</h5><p>资源文件包括项目中res目录下的各种xml文件、动画、drawable图片、音视频等</p>
<p>**<code>AAPT工具</code>**负责编译项目中的这些资源文件，所有资源文件会被编译处理</p>
<p>XML文件(Drawable图片除外)会被编译成二进制文件</p>
<p><code>assets和raw目录下的资源并不会被编译，会被原封不动的打包到apk压缩包中。</code></p>
<p>资源文件编译之后的产物包括两部分：</p>
<ul>
<li>resources.arsc文件 （保存的是一个资源索引表）</li>
<li>R.java文件 （定义了各个资源ID差两个常量）</li>
</ul>
<p>resources.arsc相当于一个资源索引表，也可以理解为一个map映射表，map的<code>key</code>是R.java中的资源ID，而value是其对应的资源所在路径。</p>
<h5 id="编译阶段–源码部分"><a href="#编译阶段–源码部分" class="headerlink" title="编译阶段–源码部分"></a>编译阶段–源码部分</h5><p>项目中源代码首先会通过javac编译成.class字节码文件</p>
<p>然后这些.class文件连同依赖的三方库中的.class文件一同被dx工具优化为.dex文件</p>
<p>如果由分包，那么也可能会生成多个.dex文件</p>
<p>源代码文件也包括**<code>AIDL接口文件编译之后生成的.java文件</code>**</p>
<p>Android项目中如果包含.aidl接口文件，这些.aidl文件会被编译成.java文件。</p>
<h5 id="打包阶段"><a href="#打包阶段" class="headerlink" title="打包阶段"></a>打包阶段</h5><p>使用工具APK Builder将经过编译之后的resource和.dex文件一起打包到apk中，实际上被打包到apk中的还有一些其他资源，比如AndroidManifest.xml清单列表和三方库中使用的动态库.so文件。</p>
<p>apk创建好之后，需要使用工具jarsigner对其进行签名，签名之后会生成META_INF文件夹，次文件夹中保存着跟签名相关的各个文件</p>
<ul>
<li>CETF.SF:生成每个文件相对的密钥</li>
<li>MANIFEST.MF：数字签名信息</li>
<li>xxx.SF:JAR文件的签名文件</li>
<li>xxx.DSA：对输出文件的签名和公钥</li>
</ul>
<p>实际打包过程还会多一步APK优化操作</p>
<p>使用工具zipalign对APK中的未压缩资源(图片、视频等)进行对其操作，让资源按照4字节的边界进行对其：<code>主要为了加快资源的访问速度</code>。如果每个资源的开始位置都是上一个资源之后的4*n字节，那么访问下一个资源就不用编译，直接跳到4 * n字节处判断是不是一个新的资源即可</p>
<h5 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h5><p>当点击某一个App安装包进行安装时，首先会弹出一个系统界面指示我们进行安装操作</p>
<p>这个界面是Android Framework中预置的一个Activity-PackagelnstallerActivity.java，当点击安装后，PackagelnstallerActivity 最终会将所安装的apk信息通过PackagelnstallerSession 传给PMS</p>
<p><img src="https://s2.loli.net/2022/08/07/bu5J3zQx2Ck8NKS.png" alt="image-20220727233249743"></p>
<p>整个apk的安装过程可以分为两大步</p>
<ul>
<li>拷贝安装包</li>
<li>装载代码</li>
</ul>
<p><img src="https://s2.loli.net/2022/08/07/uwXPjSDomaHt2V3.png" alt="image-20220727233346688"></p>
<p><img src="https://s2.loli.net/2022/08/07/HEhGxNPiWvFdAOy.png" alt="image-20220727233408784"></p>
<p><img src="https://s2.loli.net/2022/08/07/g8FwKpI32BhEenq.png" alt="image-20220727233429918"></p>
<p><img src="https://s2.loli.net/2022/08/07/PpbW1fx2tmTUDBZ.png" alt="image-20220727233437183"></p>
<p><img src="https://s2.loli.net/2022/08/07/HOhoDlrN5dSKQTw.png" alt="image-20220727233451082"></p>
<p><img src="https://s2.loli.net/2022/08/07/UGAktEFLoWeCiN8.png" alt="image-20220727233510239"></p>
<p><img src="https://s2.loli.net/2022/08/07/owrO1C5xHbcUl6F.png" alt="image-20220727233541474"></p>
<p><img src="https://s2.loli.net/2022/08/07/7yWGILlz5O8gVtr.png" alt="image-20220727233618767"></p>
<p>装载代码：</p>
<p><img src="https://s2.loli.net/2022/08/07/PZqIH4FMyXnfCao.png" alt="image-20220727233644798"></p>
<p><img src="https://s2.loli.net/2022/08/07/Z941AtabWMScfRE.png" alt="image-20220727233719985"></p>
<p>安装核心</p>
<p><img src="https://s2.loli.net/2022/08/07/Dcg1LXTHAW7sRve.png" alt="image-20220727233749999"></p>
<p><img src="https://s2.loli.net/2022/08/07/2fhDVzP3WK6BFej.png" alt="image-20220727233835484"></p>
<p>安装成功之后，还会发送一个App安装成功的广播ACTION_PACKAGE_ADDED手机桌面应用注册了这个广播，当接收到应用安装成功之后就将apk的启动icon显示在桌面上</p>
<h2 id="23、Handler"><a href="#23、Handler" class="headerlink" title="23、Handler"></a>23、Handler</h2><blockquote>
<p>主要场景是子线程完成耗时操作的过程中通过Handler向主线程发送消息Message，用来刷新UI界面</p>
</blockquote>
<h5 id="从new-Handler-开始"><a href="#从new-Handler-开始" class="headerlink" title="从new Handler()开始"></a>从new Handler()开始</h5><p><img src="https://s2.loli.net/2022/08/07/D8qLdlyxtM25s76.png" alt="image-20220727234128243"></p>
<p><img src="https://s2.loli.net/2022/08/07/ZgVKUMnE4qLv18I.png" alt="image-20220727234241883"></p>
<h5 id="Looper介绍"><a href="#Looper介绍" class="headerlink" title="Looper介绍"></a>Looper介绍</h5><p>Looper内部维护一个无限循环，保证App进程持续进行</p>
<p><img src="https://s2.loli.net/2022/08/07/OjJQSq3MGbuHrLF.png" alt="image-20220727234419996"></p>
<h5 id="Looper初始化"><a href="#Looper初始化" class="headerlink" title="Looper初始化"></a>Looper初始化</h5><p><img src="https://s2.loli.net/2022/08/07/7aG4bzq5pJWxNCV.png" alt="image-20220728221907991"></p>
<ol>
<li><p>创建Looper对象</p>
</li>
<li><p>判断是否绑定过Looper对象，将looper对象设置到本地线程，与线程绑定</p>
<p>2处，确保在一个线程中Looper.prepare()方法只能被调用1次。</p>
</li>
<li><p>取出Looper对象</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2022/08/07/EHZXtJPKiS9BfzN.png" alt="image-20220728222500325"></p>
<p><img src="https://s2.loli.net/2022/08/07/hmJiHUFuqDrK8LG.png" alt="image-20220728222528872"></p>
<p>在MainActivity 所在进程被创建时，Looper的prepare方法已经在main方法中调用了1遍这会直接导致一个非常重要的结果：是</p>
<ul>
<li>prepare方法在一个线程中只能被调用1次；</li>
<li>Looper的构造方法在一个线程中只能被调用1次</li>
<li>最终导致MessageQueue在一个线程中只会被初始化1次</li>
</ul>
<h5 id="Looper负责内容"><a href="#Looper负责内容" class="headerlink" title="Looper负责内容"></a>Looper负责内容</h5><blockquote>
<p>不断从MessageQueue中取出Message，然后处理Message中指定的任务</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/08/07/WXglFR3EMy6DUxs.png" alt="image-20220728222954847"></p>
<p>looper方法，执行一个死循环，不断的获取message</p>
<p><img src="https://s2.loli.net/2022/08/07/2qKJVhzFbdsRLHi.png" alt="image-20220728223118376"></p>
<p><img src="https://s2.loli.net/2022/08/07/sKVdZCHYxtTJDju.png" alt="image-20220728223130262"></p>
<h5 id="Handler的sendMessage方法"><a href="#Handler的sendMessage方法" class="headerlink" title="Handler的sendMessage方法"></a>Handler的sendMessage方法</h5><p><img src="https://s2.loli.net/2022/08/07/gaSV8Tkzc2GhNmp.png" alt="image-20220728223201726"></p>
<h5 id="Handler的enqueueMessage方法"><a href="#Handler的enqueueMessage方法" class="headerlink" title="Handler的enqueueMessage方法"></a>Handler的enqueueMessage方法</h5><p><img src="https://s2.loli.net/2022/08/07/6VzfDW5URYMS3TK.png" alt="image-20220728223238200"></p>
<h5 id="Handler的post-Runnable-与sendMessage有什么区别"><a href="#Handler的post-Runnable-与sendMessage有什么区别" class="headerlink" title="Handler的post(Runnable)与sendMessage有什么区别"></a>Handler的post(Runnable)与sendMessage有什么区别</h5><p>​                  <img src="https://s2.loli.net/2022/08/07/oOfcFmjyV7uaX3D.png" alt="image-20220727215547798"></p>
<p>Looper从MessageQueue中取出message之后，会调用dispatchMessage方法进行处理</p>
<p><img src="https://s2.loli.net/2022/08/07/pkoxXscwhiFZJBd.png" alt="image-20220727215611740"></p>
<p>如果msg.callback为空，则为sendmessage处理</p>
<h5 id="Looper-loop（）方法为什么不回阻塞主线程"><a href="#Looper-loop（）方法为什么不回阻塞主线程" class="headerlink" title="Looper.loop（）方法为什么不回阻塞主线程"></a>Looper.loop（）方法为什么不回阻塞主线程</h5><p>Looper中的loop方法实际上是一个死循环，但是我们的ui线程却并没有被阻塞，反而可以进行各种手势操作？</p>
<p><img src="https://s2.loli.net/2022/08/07/RYnU5PxTVM4zrvQ.png" alt="image-20220728223545960"></p>
<p>nativePollOnce 方法是一个native方法，当调用此native 方法时主线程会释放CPU资源进入休眠状态，直到下条消息到达或者有事务发生通过往 pipe 管道写端写入数据来唤醒主线程工作。</p>
<h5 id="Handler的sendMessageDelayed或者postDelayed是如何实现的"><a href="#Handler的sendMessageDelayed或者postDelayed是如何实现的" class="headerlink" title="Handler的sendMessageDelayed或者postDelayed是如何实现的"></a>Handler的sendMessageDelayed或者postDelayed是如何实现的</h5><p>在向MessageQueue队列中插入Message时，会根据Message的执行时间顺序，而消息的延迟处理的核心是在获取Messge阶段。</p>
<p><img src="https://s2.loli.net/2022/08/07/A3iEaQouO95Zegz.png" alt="image-20220727215622424"></p>
<p>如果当前系统时间大于等于message.when，那么会返回Message给Looper.loop()，但是这个逻辑只能保证在when之前消息不被处理，不能够保证一定在when时被处理</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li><p>应用启动是从ActivityThread的main开始的先是执行了Looper.prepare（），该方法先是new了一个Looper对象在私有的构造方法中又创建了MessageQueue作为此Looper对象的成员变量Looper 对象通过ThreadLocal绑定MainThread中</p>
</li>
<li><p>当创建 Handler子类对象时，在构造方法中通过ThreadLocal 获取绑定的Looper对象并获取此Looper对象的成员变量MessageQueue作为该Handler对象的成员变量</p>
</li>
<li><p>在子线程中调用上一步创建的Handler子类对象的sendMesage（msg）方法时<br>在该方法中将msg的target属性设置为自己本身<br>同时调用成员变量MessageQueue对象的enqueueMessag（）方法将msg放入MessageQueue中</p>
</li>
<li><p>主线程创建好之后，会执行Looper.loop（）方法，该方法中获取与线程绑定的Looper对象继而获取该Looper对象的成员变量MessageQueue对象并开启一个会阻塞（不占用资源）的死循环，只要MessageQueue中有msg，就会获取该msg并执行msg.target.dispatchMessage（msg）方法（msg.target即上一步引用的handler对象）此方法中调用了第二步创建 handler 子类对象时覆写的handleMessage（）方法</p>
</li>
</ul>
<h2 id="24、APK如何包体积优化"><a href="#24、APK如何包体积优化" class="headerlink" title="24、APK如何包体积优化"></a>24、APK如何包体积优化</h2><ol>
<li><p>安装包监控</p>
<p>a)   Android Analyzer</p>
<p>Android Studio的APK Analyser是Android Studio提供的一个APK检测工具通过它可以查看一个APK文件内部各项内容所占的大小，并且按照大小排序显示可以很容易观察到APK中哪一部分内容占用了最大空间</p>
<p>实际上APK Analyzer的作用不光是查看APK大小，也能用来分析APK因此可以使用它来分析一些优秀APK的目录结构、代码规范甚至是使用了哪些动态库技术等</p>
<p>b)   Matrix中的ApkChecker</p>
<p>ApkChecker 是腾讯开源框架Matrix的一部分<br>主要是用来对Android安装包进行分析检测，并输出较为详细的检测结果报告正常情况下需要下载Matrix源码，并单独编译matrix-apk-cananry部分如果想快速使用ApkChecker，可以在网上下载其ApkChecker.jar文件，然后创建一个配置文件.json</p>
<p><img src="https://s2.loli.net/2022/08/07/ZrXvqwka3p5dc1F.png" alt="image-20220728224128978"></p>
</li>
</ol>
<ol start="2">
<li><p>安装包大小优化</p>
<p>a)   删除无用文件</p>
<p>​    使用Lint查看未引用资源</p>
<p><img src="https://s2.loli.net/2022/08/07/LBkdnGwoa742Zc5.png" alt="image-20220728224222616"></p>
<p>下面两个选项可以在项目编译时期减少被打包到APK中的文件：</p>
<ul>
<li>使用shrinkResources能够在项目编译阶段，删除所有在项目中未被使用到的资源文件但是需要将minifyEnabled选项设置为true</li>
<li>使用resConfig 限定国际化资源文件</li>
</ul>
<p>b)  文件优化</p>
<ul>
<li>静态图片优化<ul>
<li>有限使用drawable</li>
<li>WebP格式</li>
</ul>
</li>
<li>动态图片优化</li>
</ul>
<p>c) 引入第三方库</p>
<ul>
<li>在引入之前最好权衡一下是否需要将其代码全部引入，造成不必要的代码或者资源也被打包到APK中</li>
</ul>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ul>
<li>安装包的监控<br>主要介绍了几个可以用来分析安装包大小以及详细内容的工具：Apk Analyzer和ApkChecker在开发过程中，良好的编程习惯和严格的code review也是非常重要的</li>
<li>安装包优化实践<br>主要思路是删减无用资源或者代码，并对资源文件进行相应的压缩优化对于代码部分也可以更进一步的优化，比如使用Proguard，或者直接使用R8编译方式极力推荐阅读Jake Wharton的个人博客：jakewharton中的相关介绍</li>
</ul>
</li>
</ol>
<p><img src="https://s2.loli.net/2022/08/07/S9dp7Q1fu6FOEIj.png" alt="image-20220727215720386"></p>
<h2 id="25、android-崩溃日志"><a href="#25、android-崩溃日志" class="headerlink" title="25、android 崩溃日志"></a>25、android 崩溃日志</h2><p>crash日志分类：</p>
<ul>
<li><p><strong><code>JVM异常(Exception)堆栈信息</code></strong></p>
<ul>
<li>检测异常 checked exception<ul>
<li>检查异常是在代码编译时期，Android Studio 就会提示代码有错误，无法通过编译比如I0Exception。如果没有在代码中将这些异常catch，而是直接抛出，最终也有可能导致程序崩溃<br><img src="https://s2.loli.net/2022/08/07/8FBsrQDlPjAp7S2.png" alt="image-20220728225456511"></li>
</ul>
</li>
<li>非检查异常 unchecked Exception<ul>
<li>非检查异常包括error 和运行时异常（RuntimeException）<br>AS并不会在编译时期提示这些异常信息，而是在程序运行时期因为代码错误而直接导致程序崩溃比如OOM或者空指针异常（NPE）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>native代码崩溃日志</code></strong></p>
<ul>
<li><p>当程序中的native代码发生崩溃时<br>系统会在/data/tombstones/目录下保存一份详细的崩溃日志信息</p>
<p>如果一个native crash是必现的，不妨在模拟器上重现bug</p>
<p>并将/data/tombstones中的崩溃日志拉到本地电脑中加以分析</p>
</li>
<li><p>需要一种机制，将native crash现场的日志信息保存到可以访问的手机目录中目前比较成熟，使用也比较广泛的是谷歌的BreakPad Breakpad 是一个跨平台的开源库，也可以在其Breakpad Github上下载自己编译并通过JNI的方式引入到项目中</p>
</li>
</ul>
</li>
</ul>
<h2 id="26、内存泄漏"><a href="#26、内存泄漏" class="headerlink" title="26、内存泄漏"></a>26、内存泄漏</h2><h4 id="Activity内存泄漏预防"><a href="#Activity内存泄漏预防" class="headerlink" title="Activity内存泄漏预防"></a>Activity内存泄漏预防</h4><p>因为Activity承担了与用户交互的职责，因此内部需要持有大量的资源引用以及与系统交互的Context</p>
<p>这会导致一个Activity对象的retained size特别大</p>
<h6 id="造成Activity内存泄漏的场景"><a href="#造成Activity内存泄漏的场景" class="headerlink" title="造成Activity内存泄漏的场景"></a>造成Activity内存泄漏的场景</h6><ol>
<li>将Context或View设置为static</li>
</ol>
<p><img src="https://s2.loli.net/2022/08/07/gutN4OTAr3hXWwo.png" alt="image-20220728225953692"></p>
<ol start="2">
<li><p>未解注册各种Listener</p>
<p><img src="https://s2.loli.net/2022/08/07/sgBKalLNW8UfJox.png" alt="image-20220728230115561"></p>
</li>
<li><p>非静态Handler导致Acitivity泄漏</p>
<p><img src="https://s2.loli.net/2022/08/07/ybMCIYa1tkoS8zs.png" alt="image-20220728233011907"></p>
<p>正确用法：</p>
<p><img src="https://s2.loli.net/2022/08/07/NdgmxrtKHpiGh6a.png" alt="image-20220728233044052"></p>
</li>
<li><p>三方库使用Context</p>
<p><img src="https://s2.loli.net/2022/08/07/xwN2Z7cjgOoWBq8.png" alt="image-20220728235522921"></p>
<p>正确使用</p>
<p><img src="https://s2.loli.net/2022/08/07/bSoE6ZnCR3XMtxi.png" alt="image-20220728235633843"></p>
<p>在开发阶段可以直接使用<code>Android Studio</code>来查看Activity是否存在内存泄漏<br>并结合MAT来查看发生内存泄漏的具体对象<br>详细使用过程可以参考：Android Studio和MAT结合使用来分析内存问题</p>
<h4 id="内存泄漏检测"><a href="#内存泄漏检测" class="headerlink" title="内存泄漏检测"></a>内存泄漏检测</h4><p><code>LeakCanary</code> 是Square公司的一个开源库，通过它可以在App运行过程中检测内存泄漏，当内存泄漏发生时会生成发生泄漏对象的引用链，并通知程序开发人员</p>
<p>LeakCanary 主要分2大核心部分：</p>
<ol>
<li>如何检测内存泄漏</li>
<li>分析内存泄漏对象的引用链</li>
</ol>
<h5 id="如果检测内存泄漏–JVM理论知识"><a href="#如果检测内存泄漏–JVM理论知识" class="headerlink" title="如果检测内存泄漏–JVM理论知识"></a>如果检测内存泄漏–JVM理论知识</h5><p><img src="https://s2.loli.net/2022/08/07/c4PNygnVh1i78eM.png" alt="image-20220728235938304"></p>
<p>实现思路：</p>
<p>LeakCanary 中对内存泄漏检测的核心原理就是<code>基于WeakReference和ReferenceQueue实现的</code><br>1.当一个Activity需要被回收时，就将其包装到一个WeakReference中并且在WeakReference的构造器中传入自定义的ReferenceQueue<br>2.给包装后的WeakReference做一个标记Key，并且在一个强引用Set中添加相应的Key记录<br>3.主动触发GC，遍历自定义ReferenceQueue中所有的记录并根据获取的Reference对象将Set中的记录也删除<br>还保留在Set中的是：<code>应当被GC回收，但是实际还保留在内存中的对象，也就是发生泄漏了的对象</code></p>
<p>源码分析</p>
<p>一个可回收对象在System.gc（）之后就应该被GC回收在AndroidApp中，我们并不清楚何时系统会回收Activity按照正常流程，当Activity 调用onDestroy 方法时就说明这个Activity就已经处于无用状态因此需要<code>监听到每一个Activity的onDestroy 方法的调用</code></p>
<p>总结：</p>
<p>这节课主要介绍了Android内存泄漏优化的相关知识<br>·内存泄漏预防<br>这需要了解JVM发生内存泄漏的原因，并在平时开发阶段养成良好的编码规范针对编码规范Android Studio可以安装一个阿里代码规范的插件，能够起到一定的代码检查效果<br>·内存泄漏检测<br>内存泄漏检测工具有很多Android Studio自带的Profiler，以及MAT都是不错的选择使用这些工具排查内存泄漏门槛稍高，并且全部是手动操作，略显麻烦</p>
</li>
</ol>
<h2 id="27、UI卡顿"><a href="#27、UI卡顿" class="headerlink" title="27、UI卡顿"></a>27、UI卡顿</h2><p>systrace工具：通过Android提供的脚本systrace.py，可以设置数据采集并收集相关程序运行数据，最终生成一个网页文件提供程序开发者分析程序性能问题。</p>
<p><img src="https://s2.loli.net/2022/08/07/sp61TkPxu2IvelV.png" alt="image-20220726080025126"></p>
<h2 id="29、MVP中presenter生命周期管理"><a href="#29、MVP中presenter生命周期管理" class="headerlink" title="29、MVP中presenter生命周期管理"></a>29、MVP中presenter生命周期管理</h2><p>presenter层经常做一些耗时操作，根据请求后的结果刷新View。</p>
<p>如果按返回结束Activity，而Presenter依然在执行耗时操作，就有可能造成内存泄漏，甚至程序崩溃。</p>
<p><code>将Activity的某些生命周期方法与Presenter保持一致</code></p>
<h5 id="Lifecycle绑定Presenter生命周期"><a href="#Lifecycle绑定Presenter生命周期" class="headerlink" title="Lifecycle绑定Presenter生命周期"></a>Lifecycle绑定Presenter生命周期</h5><p>Activity通过继承AppCompatActivity会自动继承来自父类CimponentActivity的方法getLifeCycle</p>
<p><img src="https://s2.loli.net/2022/08/07/rOBtNYVzEdu7eTh.png" alt="image-20220726075329090"></p>
<p><img src="https://s2.loli.net/2022/08/07/xNdvmuGgQSRKi8U.png" alt="image-20220726075423485"></p>
<p>需要在自定义类中实现这些方法</p>
<p><img src="https://s2.loli.net/2022/08/07/1v5So4C9AqXYnsy.png" alt="image-20220726075515675"></p>
<p>修改Activity，将BasePresenter注册到LifeCycle中</p>
<p><img src="https://s2.loli.net/2022/08/07/1RxOpKLjazgedu8.png" alt="image-20220726075621690"></p>
<h2 id="30、LogUtil"><a href="#30、LogUtil" class="headerlink" title="30、LogUtil"></a>30、LogUtil</h2><p>​    Xlog</p>
<p><img src="https://s2.loli.net/2022/08/07/ETLNet3pCyxPwKr.png" alt="image-20220726074321935"></p>
<p><img src="https://s2.loli.net/2022/08/07/COPpfeGQ1ksHTn5.png" alt="image-20220726074423740"></p>
<h2 id="31、屏幕适配"><a href="#31、屏幕适配" class="headerlink" title="31、屏幕适配"></a>31、屏幕适配</h2><ol>
<li>ConStrainLayout(约束布局)（前身是percentLayout百分百布局）+dimens</li>
<li>控件适配：TextView使用wrap_congt(自适应),ImageView使用固定大小dp</li>
<li>手机和平板或折叠屏，布局是否需要拆分，控件布局方式或大小</li>
</ol>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 群英传笔记</title>
    <url>/2022/08/08/Android/Android%20%E7%BE%A4%E8%8B%B1%E4%BC%A0%20%E6%80%BB%E7%BB%93%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<hr>
<h2 id="群英传"><a href="#群英传" class="headerlink" title="群英传"></a>群英传</h2><h3 id="第1章Android体系与系统架构"><a href="#第1章Android体系与系统架构" class="headerlink" title="第1章Android体系与系统架构"></a>第1章Android体系与系统架构</h3><h4 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h4><p><img src="https://s2.loli.net/2022/08/07/Yfl4p3AMeikBgSC.png" alt="image-20220807145006111"></p>
<ul>
<li><p>Linux内核层</p>
<p>Android系统是基于Linux内核的，为设置的各种硬件提供了底层的驱动：显示驱动，音频驱动，蓝牙驱动等</p>
</li>
<li><p>系统运行库层</p>
<p>通过一些C/C++库为Android系统提供了主要的特性支持，SQLite库提供了数据库的支持，OpenGL|ES库提供了3D绘图的支持。</p>
<p>还提供一些核心库，允许使用Java来编写Android应用。还包含Dalvik虚拟机（5.0之后改为ART运行环境），使得每一个Android应用都能运行在读理的进程中，并拥有一个自己的虚拟机实例。</p>
</li>
<li><p>应用框架层</p>
<p>构建应用程序时可能用到的各种API，Android自带的一些核心应用就是使用这些api完成的。</p>
</li>
<li><p>应用层</p>
<p>各种手机应用</p>
</li>
</ul>
<h4 id="App组件架构"><a href="#App组件架构" class="headerlink" title="App组件架构"></a><code>App</code>组件架构</h4><ul>
<li><code>Activity</code></li>
<li><code>BroadCastReceiver</code></li>
<li><code>ContentProvider</code></li>
<li><code>Service</code></li>
</ul>
<p>组件之间的协同工作：</p>
<p>Android作为人机交互的第一界面，负责向用户展示信息和处理结果，这些信息来源，可以通过资源获取，也可也i通过Content Provider来获取其他应用的信息或Service从后台计算、下载、处理的结果，也可以是通过BroadCast Revicever获取到的广播信息。同时通过信使Intent-，作为信息传递的载体。组件与组件之间通过Intent来通信、传递信息、交换数据，从而使得四大组件形成各自独立而又紧密联系。</p>
<h3 id="第2章Android开发工具新接触"><a href="#第2章Android开发工具新接触" class="headerlink" title="第2章Android开发工具新接触"></a>第2章Android开发工具新接触</h3><h4 id="ADB命令使用技巧"><a href="#ADB命令使用技巧" class="headerlink" title="ADB命令使用技巧"></a>ADB命令使用技巧</h4><h3 id="第3章Android控件架构与自定义控件详解"><a href="#第3章Android控件架构与自定义控件详解" class="headerlink" title="第3章Android控件架构与自定义控件详解"></a>第3章Android控件架构与自定义控件详解</h3><h4 id="3-1-Android控件架构"><a href="#3-1-Android控件架构" class="headerlink" title="3.1 Android控件架构"></a>3.1 Android控件架构</h4><ul>
<li><p><strong><code>ViewGroup</code></strong></p>
<p>父控件，可以包含多个View控件，管理包含的View控件。通过ViewGroup，构造成控件树，上层控件负责下层子控件的测量与绘制，并传递交互事件。</p>
</li>
<li><p><strong><code>View控件</code></strong></p>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/08/07/ktrbNuBJyaCp2OY.png" alt="img"></p>
<p>每个Activity都包含一个window对象，在Android中Window对象通常由PhoneWindow来实现。PhoneWindow将一个DecorView设置为整个应用窗口的根View。DevorView作为窗口界面的顶层视图，封装了一些窗口操作的通用方法。DecorView将要显示的具体内容呈现在PhoneWindow上，包含所有View的监听事件，通过WindowMangerService来进行接收，并通过activity对象来回调相应的onClickListener。</p>
<p>将屏幕分成两部分，一个是TitleView，另一个是ContentView(id为content的FrameLayout)。</p>
<p>OnCreate()方法中调用setContentView()方法后，activityManagerService会回调onResume方法，将整个decorView添加到PhoneWindow中，显示出来，最终完成界面的绘制。</p>
<h4 id="3-2-View的测量"><a href="#3-2-View的测量" class="headerlink" title="3.2 View的测量"></a>3.2 View的测量</h4><ul>
<li><p>onMeasure方法：测量View的大小.</p>
<ul>
<li>MeasureSpec类，32位int值，高2位测量的模式，低20位测量的大小</li>
<li>测量的三种模式<ul>
<li>EXACTLY(默认)：当控件layout_width或layout_height属性为具体数值时，或指定为match_parent属性</li>
<li>AT_MOST:最大值模式，当控件layout_width或layout_height属性为wrap_content时，控件的大小一般随着控件的子控件或内容的变化而变化。</li>
<li>UNSPECIFIED：不指定大小的测量模式，view想多大就多大，通常情况下在绘制自定义View时才会使用。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.customview;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Canvas;</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.annotation.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomViewDemo</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomViewDemo</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        setMeasuredDimension(measureWidth(widthMeasureSpec),measureHeight(heightMeasureSpec));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">measureWidth</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">        <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (specMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">            result = specSize;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="number">200</span>;</span><br><span class="line">            <span class="keyword">if</span> (specMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">                result = Math.min(result,specSize);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">measureHeight</span><span class="params">(<span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">        <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (specMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">            result = specSize;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="number">200</span>;</span><br><span class="line">            <span class="keyword">if</span> (specMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">                result = Math.min(result,specSize);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">        canvas.drawBitmap(bitmap1,<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">null</span>);</span><br><span class="line">        canvas.drawBitmap(bitmap2,<span class="number">0</span>,<span class="number">0</span>,<span class="keyword">null</span>);</span><br><span class="line">        Canvas mCanvas = <span class="keyword">new</span> Canvas(bitmap2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-3-View的绘制"><a href="#3-3-View的绘制" class="headerlink" title="3.3 View的绘制"></a>3.3 View的绘制</h4><blockquote>
<p>在Android的界面上绘制图像，需要在Canvas上进行绘制(画板)，Paint进行画(画笔)，在重写的OnDraw方法上完成。</p>
</blockquote>
<p>创建Canvas对象时，需要传进去一个bitamp对象。通过bitamp与通过整个bitmao创建的canvas画布紧密连接起来，过程为装载画布。此bitamp用来存储所有绘制在Canvas上的像素信息。通过这种方式创建了Canvas对象后，后面所有的Canvas.drawXXX方法都发生在bitmap上。</p>
<h4 id="3-4-ViewGroup的测量"><a href="#3-4-ViewGroup的测量" class="headerlink" title="3.4 ViewGroup的测量"></a>3.4 ViewGroup的测量</h4><p>当ViewGroup的大小为wrap_content时，ViewGroup就需要对子View进行遍历，以获得所有的子View的大小，从而决定自己的大小。在其他模式下，则通过具体的指定值来设置自身的大小。</p>
<p>ViewGroup在测量时通过遍历所有的子View，从而调用子View的measure方法获得每一个子view的测量结果。</p>
<p>当子view测量完成后，需要将子view放到合适的位置，这个过程就是view的layout过程，ViewGroup在执行Layout过程时，同样是使用遍历来调用子View的Layout方法，并指定其具体显示的位置，从而俩决定其布局的位置。</p>
<p>在自定义ViewGroup时，通常会去重写onLaout方法来控制子view显示位置的逻辑。通过，如果需要<code>支持wrap_content属性</code>，还必须重写onmeasure方法，同View。</p>
<h4 id="3-5-ViewGroup的绘制"><a href="#3-5-ViewGroup的绘制" class="headerlink" title="3.5 ViewGroup的绘制"></a>3.5 ViewGroup的绘制</h4><p>ViewGroup通常情况不需要绘制，本身没有需要绘制的东西，如果指定了ViewGroup的背景颜色则需要调用OnDraw方法。但是，ViewGroup会使用dispatchDraw()方法来绘制子View,其过程同样需要通过遍历所有的子View，并调用子view的绘制方法来完成绘制工作。</p>
<h4 id="3-6-自定义View"><a href="#3-6-自定义View" class="headerlink" title="3.6 自定义View"></a>3.6 自定义View</h4><p><strong><code>常用回调方法</code></strong></p>
<ul>
<li>onFinishInflate()：从XML加载固件后回调。</li>
<li>OnSizeChanged()：组件改变时回调</li>
<li>OnMeasure()：回调该方法进行测量</li>
<li>OnLayout：回调该方法来确定显示的位置</li>
<li>OnTOuchEvent：监听到触摸事件的回调</li>
</ul>
<p><strong><code>实现自定义控件的方法</code></strong></p>
<ul>
<li>对现有控件进行拓展</li>
<li>通过组合来实现新的控件</li>
<li>重写View来实现全新的控件</li>
</ul>
<h5 id="3-61-现有控件拓展"><a href="#3-61-现有控件拓展" class="headerlink" title="3.61. 现有控件拓展"></a>3.61. 现有控件拓展</h5><p><strong>拓展TextView</strong></p>
<ul>
<li><p>绘制TextVie背景</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.customview;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Canvas;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Color;</span><br><span class="line"><span class="keyword">import</span> android.graphics.LinearGradient;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Matrix;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Paint;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Shader;</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.annotation.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomTextView</span> <span class="keyword">extends</span> <span class="title">androidx</span>.<span class="title">appcompat</span>.<span class="title">widget</span>.<span class="title">AppCompatTextView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Paint mPaint1;</span><br><span class="line">    <span class="keyword">private</span> Paint mPaint2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomTextView</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在回调父类方法前，实现自己的逻辑，对TextView来说就是绘制文件内容前</span></span><br><span class="line">        mPaint1 = <span class="keyword">new</span> Paint();</span><br><span class="line">        mPaint1.setColor(getResources().getColor(android.R.color.holo_blue_bright));</span><br><span class="line">        mPaint1.setStyle(Paint.Style.FILL);</span><br><span class="line">        mPaint2 = <span class="keyword">new</span> Paint();</span><br><span class="line">        mPaint2.setColor(Color.YELLOW);</span><br><span class="line">        mPaint2.setStyle(Paint.Style.FILL);</span><br><span class="line">        <span class="comment">//绘制外层矩形</span></span><br><span class="line">        canvas.drawRect(<span class="number">0</span>,<span class="number">0</span>,getMeasuredWidth(),getMeasuredHeight(),mPaint1);</span><br><span class="line">        <span class="comment">//绘制内层矩形</span></span><br><span class="line">        canvas.drawRect(<span class="number">10</span>,<span class="number">10</span>,getMeasuredWidth()-<span class="number">10</span>,getMeasuredHeight()-<span class="number">10</span>,mPaint2);</span><br><span class="line">        canvas.save();</span><br><span class="line">        <span class="comment">//绘制文字前平移10像素</span></span><br><span class="line">        canvas.translate(<span class="number">50</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//父类完成的方法，即绘制文本</span></span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">        <span class="comment">//在回调父类方法后，实现自己的逻辑，对TextView来说就是绘制文件内容后</span></span><br><span class="line">        canvas.restore();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>文字闪烁</p>
<p>通过使用Shader渲染器，设置一个不断变化的<code>LinearGradient</code>，并使用带有该属性的Paint对象来绘制要显示的文字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.customview;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Canvas;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Color;</span><br><span class="line"><span class="keyword">import</span> android.graphics.LinearGradient;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Matrix;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Paint;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Shader;</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.annotation.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomTextView</span> <span class="keyword">extends</span> <span class="title">androidx</span>.<span class="title">appcompat</span>.<span class="title">widget</span>.<span class="title">AppCompatTextView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Paint mPaint1;</span><br><span class="line">    <span class="keyword">private</span> Paint mPaint2;</span><br><span class="line">    <span class="keyword">private</span> Paint mPaint;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mViewWidth;</span><br><span class="line">    <span class="keyword">private</span> LinearGradient mLinearGradient;</span><br><span class="line">    <span class="keyword">private</span> Matrix mGradientMatrix;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mTranslate;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomTextView</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在回调父类方法前，实现自己的逻辑，对TextView来说就是绘制文件内容前</span></span><br><span class="line">        mPaint1 = <span class="keyword">new</span> Paint();</span><br><span class="line">        mPaint1.setColor(getResources().getColor(android.R.color.holo_blue_bright));</span><br><span class="line">        mPaint1.setStyle(Paint.Style.FILL);</span><br><span class="line">        mPaint2 = <span class="keyword">new</span> Paint();</span><br><span class="line">        mPaint2.setColor(Color.YELLOW);</span><br><span class="line">        mPaint2.setStyle(Paint.Style.FILL);</span><br><span class="line">        <span class="comment">//绘制外层矩形</span></span><br><span class="line">        canvas.drawRect(<span class="number">0</span>,<span class="number">0</span>,getMeasuredWidth(),getMeasuredHeight(),mPaint1);</span><br><span class="line">        <span class="comment">//绘制内层矩形</span></span><br><span class="line">        canvas.drawRect(<span class="number">10</span>,<span class="number">10</span>,getMeasuredWidth()-<span class="number">10</span>,getMeasuredHeight()-<span class="number">10</span>,mPaint2);</span><br><span class="line">        canvas.save();</span><br><span class="line">        <span class="comment">//绘制文字前平移10像素</span></span><br><span class="line">        canvas.translate(<span class="number">50</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//父类完成的方法，即绘制文本</span></span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">        <span class="comment">//在回调父类方法后，实现自己的逻辑，对TextView来说就是绘制文件内容后</span></span><br><span class="line">        canvas.restore();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文字闪烁</span></span><br><span class="line">        <span class="keyword">if</span> (mGradientMatrix !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            mTranslate += mViewWidth/<span class="number">5</span>;</span><br><span class="line">            <span class="keyword">if</span> (mTranslate&gt;<span class="number">2</span>*mViewWidth)&#123;</span><br><span class="line">                mTranslate=-mViewWidth;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//通过矩阵的不断平移</span></span><br><span class="line">            mGradientMatrix.setTranslate(mTranslate,<span class="number">0</span>);</span><br><span class="line">            mLinearGradient.setLocalMatrix(mGradientMatrix);</span><br><span class="line">            postInvalidateDelayed(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line">        <span class="keyword">if</span> (mViewWidth == <span class="number">0</span>)&#123;</span><br><span class="line">            mViewWidth = getMeasuredWidth();</span><br><span class="line">            <span class="keyword">if</span> (mViewWidth&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//获取当前绘制Textview的Paint对象，并给这个对象设置LinearGradient属性。</span></span><br><span class="line">                mPaint = getPaint();</span><br><span class="line">                mLinearGradient = <span class="keyword">new</span> LinearGradient(<span class="number">0</span>,<span class="number">0</span>,mViewWidth,<span class="number">0</span>,<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;Color.BLUE,<span class="number">0xffffffff</span>,Color.YELLOW&#125;,<span class="keyword">null</span>,Shader.TileMode.CLAMP);</span><br><span class="line">                mPaint.setShader(mLinearGradient);</span><br><span class="line">                mGradientMatrix = <span class="keyword">new</span> Matrix();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="3-6-2-复合控件"><a href="#3-6-2-复合控件" class="headerlink" title="3.6.2.复合控件"></a>3.6.2.复合控件</h5><p>创建复合控件可以很好地创建出具有重用功能的控件集合。这种方式通常需要继承一个合适的ViewGroup，再给它添加指定功能的控件，从而组合成新的复合控件。通过这种方式创建的控件，我们一般会给它指定一些可配置的属性，让它具有更强的拓展性。</p>
<h6 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h6><blockquote>
<p>可定制性，通过调用不同的属性实现不同的效果</p>
</blockquote>
<p>values/attrs.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--我们在代码中通过&lt;declare-styleable&gt;标签声明了使用自定义属性，</span></span><br><span class="line"><span class="comment">    并通过name属性来确定引用的名称。</span></span><br><span class="line"><span class="comment">    最后，通过&lt;attr&gt;标签来声明具体的自定义属性，</span></span><br><span class="line"><span class="comment">    比如在这里定义了标题文字的字体、大小、颜色，左边按钮的文字颜色、背景、字体，右边按钮的文字颜色、背景、字体等属性，</span></span><br><span class="line"><span class="comment">    并通过format属性来指定属性的类型。这里需要注意的就是，有些属性可以是颜色属性，也可以是引用属性。</span></span><br><span class="line"><span class="comment">    比如按钮的背景，可以把它指定为具体的颜色，也可以把它指定为一张图片，所以使用“”来分隔不同的属性—“reference|color”。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span> = <span class="string">&quot;TopBar&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;title&quot;</span> <span class="attr">format</span> = <span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;titleTextSize&quot;</span> <span class="attr">format</span> = <span class="string">&quot;dimension&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;titleTextColor&quot;</span> <span class="attr">format</span> = <span class="string">&quot;color&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;leftTextColor&quot;</span> <span class="attr">format</span> = <span class="string">&quot;color&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;leftBackground&quot;</span> <span class="attr">format</span> = <span class="string">&quot;reference|color&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;leftText&quot;</span> <span class="attr">format</span> = <span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;rightTextColor&quot;</span> <span class="attr">format</span> = <span class="string">&quot;color&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;rightBackground&quot;</span> <span class="attr">format</span> = <span class="string">&quot;reference|color&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;rightText&quot;</span> <span class="attr">format</span> = <span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>获取属性集，并设置属性值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.customview;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.res.TypedArray;</span><br><span class="line"><span class="keyword">import</span> android.graphics.drawable.Drawable;</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet;</span><br><span class="line"><span class="keyword">import</span> android.widget.RelativeLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopBar</span> <span class="keyword">extends</span> <span class="title">RelativeLayout</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mLeftTextColor;</span><br><span class="line">    <span class="keyword">private</span> Drawable mLeftBackground;</span><br><span class="line">    <span class="keyword">private</span> String mLeftText;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mRightTextColor;</span><br><span class="line">    <span class="keyword">private</span> Drawable mRightBackground;</span><br><span class="line">    <span class="keyword">private</span> String mRightText;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mTitle;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mTitleTextColor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mTitleTextSize;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TopBar</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        <span class="comment">//通过TypedArray 数据结构来获取自定义属性集，通过getString，getColor方法获得定义的属性值</span></span><br><span class="line">        TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.TopBar);</span><br><span class="line">        <span class="comment">//从通过TypedArray中取出对应的值来为要设置的属性赋值</span></span><br><span class="line">        mLeftTextColor = typedArray.getColor(R.styleable.TopBar_leftTextColor, <span class="number">0</span>);</span><br><span class="line">        mLeftBackground = typedArray.getDrawable(R.styleable.TopBar_leftBackground);</span><br><span class="line">        mLeftText = typedArray.getString(R.styleable.TopBar_leftText);</span><br><span class="line"></span><br><span class="line">        mRightTextColor = typedArray.getColor(R.styleable.TopBar_rightTextColor, <span class="number">0</span>);</span><br><span class="line">        mRightBackground = typedArray.getDrawable(R.styleable.TopBar_rightBackground);</span><br><span class="line">        mRightText = typedArray.getString(R.styleable.TopBar_rightText);</span><br><span class="line"></span><br><span class="line">        mTitle = typedArray.getString(R.styleable.TopBar_title);</span><br><span class="line">        mTitleTextColor = typedArray.getColor(R.styleable.TopBar_titleTextColor, <span class="number">0</span>);</span><br><span class="line">        mTitleTextSize = typedArray.getDimension(R.styleable.TopBar_titleTextSize, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//获取完TypedArray的值之后，一般要调用recyle方法来避免重新创建的时候的错误</span></span><br><span class="line">        typedArray.recycle();<span class="comment">//资源释放，回收</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="组合控件"><a href="#组合控件" class="headerlink" title="组合控件"></a>组合控件</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.customview;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.res.TypedArray;</span><br><span class="line"><span class="keyword">import</span> android.graphics.drawable.Drawable;</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.Gravity;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.RelativeLayout;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopBar</span> <span class="keyword">extends</span> <span class="title">RelativeLayout</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;TopBar&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mLeftTextColor;</span><br><span class="line">    <span class="keyword">private</span> Drawable mLeftBackground;</span><br><span class="line">    <span class="keyword">private</span> String mLeftText;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mRightTextColor;</span><br><span class="line">    <span class="keyword">private</span> Drawable mRightBackground;</span><br><span class="line">    <span class="keyword">private</span> String mRightText;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mTitle;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mTitleTextColor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mTitleTextSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Button mLeftButton;</span><br><span class="line">    <span class="keyword">private</span> Button mRightButton;</span><br><span class="line">    <span class="keyword">private</span> TextView mTitleView;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LayoutParams mLeftParams;</span><br><span class="line">    <span class="keyword">private</span> LayoutParams mRightParams;</span><br><span class="line">    <span class="keyword">private</span> LayoutParams mTitleParams;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OnTopBarClickListener mListener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TopBar</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TopBar</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TopBar</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        <span class="comment">//通过TypedArray 数据结构来获取自定义属性集，通过getString，getColor方法获得定义的属性值</span></span><br><span class="line">        TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.TopBar);</span><br><span class="line">        <span class="comment">//从通过TypedArray中取出对应的值来为要设置的属性赋值</span></span><br><span class="line">        mLeftTextColor = typedArray.getColor(R.styleable.TopBar_leftTextColor, <span class="number">0</span>);</span><br><span class="line">        mLeftBackground = typedArray.getDrawable(R.styleable.TopBar_leftBackground);</span><br><span class="line">        mLeftText = typedArray.getString(R.styleable.TopBar_leftText);</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;zhangtao: mLeftText:&quot;</span>+mLeftText.toString());</span><br><span class="line"></span><br><span class="line">        mRightTextColor = typedArray.getColor(R.styleable.TopBar_rightTextColor, <span class="number">0</span>);</span><br><span class="line">        mRightBackground = typedArray.getDrawable(R.styleable.TopBar_rightBackground);</span><br><span class="line">        mRightText = typedArray.getString(R.styleable.TopBar_rightText);</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;zhangtao: mLeftText:&quot;</span>+mRightText.toString());</span><br><span class="line"></span><br><span class="line">        mTitle = typedArray.getString(R.styleable.TopBar_title);</span><br><span class="line">        mTitleTextColor = typedArray.getColor(R.styleable.TopBar_titleTextColor, <span class="number">0</span>);</span><br><span class="line">        mTitleTextSize = typedArray.getDimension(R.styleable.TopBar_titleTextSize, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//获取完TypedArray的值之后，一般要调用recyle方法来避免重新创建的时候的错误</span></span><br><span class="line">        typedArray.recycle();<span class="comment">//资源释放，回收</span></span><br><span class="line">        <span class="comment">//initTopBar(context);</span></span><br><span class="line">        mLeftButton = <span class="keyword">new</span> Button(context);</span><br><span class="line">        mRightButton = <span class="keyword">new</span> Button(context);</span><br><span class="line">        mTitleView = <span class="keyword">new</span> TextView(context);</span><br><span class="line">        <span class="comment">//为创建的组件元素赋值</span></span><br><span class="line">        <span class="comment">//值来源于引用的xml文件中对应属性的赋值</span></span><br><span class="line">        mLeftButton.setTextColor(mLeftTextColor);</span><br><span class="line">        mLeftButton.setBackground(mLeftBackground);</span><br><span class="line">        mLeftButton.setText(mLeftText);</span><br><span class="line"></span><br><span class="line">        mRightButton.setTextColor(mRightTextColor);</span><br><span class="line">        mRightButton.setBackground(mRightBackground);</span><br><span class="line">        mRightButton.setText(mRightText);</span><br><span class="line"></span><br><span class="line">        mTitleView.setText(mTitle);</span><br><span class="line">        mTitleView.setTextColor(mTitleTextColor);</span><br><span class="line">        mTitleView.setTextSize(mTitleTextSize);</span><br><span class="line">        mTitleView.setGravity(Gravity.CENTER);</span><br><span class="line"></span><br><span class="line">        initTopBar(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initTopBar</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*if (getParent()!=null)&#123;</span></span><br><span class="line"><span class="comment">            Log.i(TAG, &quot;initTopBar: zhangtao ,not null&quot;);</span></span><br><span class="line"><span class="comment">            removeAllViews();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        removeAllViews();*/</span></span><br><span class="line">        <span class="comment">//为组件元素设置相应的布局元素</span></span><br><span class="line">        mLeftParams = <span class="keyword">new</span> LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT);</span><br><span class="line">        mLeftParams.addRule(ALIGN_PARENT_LEFT,TRUE);</span><br><span class="line">        <span class="comment">//添加到ViewGroup</span></span><br><span class="line">        addView(mLeftButton, mLeftParams);</span><br><span class="line"></span><br><span class="line">        mRightParams = <span class="keyword">new</span> LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT);</span><br><span class="line">        mRightParams.addRule(ALIGN_PARENT_RIGHT,TRUE);</span><br><span class="line">        <span class="comment">//getParent();</span></span><br><span class="line">        addView(mRightButton, mRightParams);</span><br><span class="line"></span><br><span class="line">        mTitleParams = <span class="keyword">new</span> LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT);</span><br><span class="line">        mTitleParams.addRule(CENTER_IN_PARENT,TRUE);</span><br><span class="line">        addView(mTitleView,mTitleParams);</span><br><span class="line">        <span class="comment">//暴露接口给调用者</span></span><br><span class="line">        <span class="comment">/*按钮的点击事件，不需要具体的实现，只需要调用接口的方法，回调的时候，会有具体的实现*/</span></span><br><span class="line">        mRightButton.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (mListener !=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    mListener.rightClick();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        mLeftButton.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (mListener!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    mListener.leftClick();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*暴露一个方法给调用者来注册接口回调</span></span><br><span class="line"><span class="comment">    * 通过接口来获得回调者对接口发方法的实现*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setonTopBarClickListener</span><span class="params">(OnTopBarClickListener mListener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mListener = mListener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setButtonVisable</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">boolean</span> flag)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;</span><br><span class="line">                mLeftButton.setVisibility(View.VISIBLE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mRightButton.setVisibility(VISIBLE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;</span><br><span class="line">                mLeftButton.setVisibility(GONE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mRightButton.setVisibility(GONE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口对象，实现回调机制，在回调方法中</span></span><br><span class="line"><span class="comment">//通过映射的接口对象调用接口中的方法</span></span><br><span class="line"><span class="comment">//而不用去考虑如何实现，具体的实现由调用者去创建</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnTopBarClickListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">//左按钮点击事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">leftClick</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//右按钮点击事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rightClick</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="引用UI模板"><a href="#引用UI模板" class="headerlink" title="引用UI模板"></a>引用UI模板</h6><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">com.example.customview.TopBar</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;40dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/topBar&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:leftBackground</span>=<span class="string">&quot;@drawable/ic_launcher_background&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:leftText</span>=<span class="string">&quot;Back&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:leftTextColor</span>=<span class="string">&quot;#FFFFFF&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:rightBackground</span>=<span class="string">&quot;@color/design_default_color_error&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:rightText</span>=<span class="string">&quot;More&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:rightTextColor</span>=<span class="string">&quot;#FFFFFF&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:title</span>=<span class="string">&quot;自定义标题&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:titleTextColor</span>=<span class="string">&quot;#123412&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:titleTextSize</span>=<span class="string">&quot;10sp&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">com.example.customview.TopBar</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.customview;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.pm.ApplicationInfo;</span><br><span class="line"><span class="keyword">import</span> android.content.pm.PackageManager;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PackageManager pm;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        TopBar mTopBar = (TopBar)findViewById(R.id.topBar);</span><br><span class="line">        mTopBar.setonTopBarClickListener(<span class="keyword">new</span> OnTopBarClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leftClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>,<span class="string">&quot;left&quot;</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rightClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>,<span class="string">&quot;right&quot;</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        mTopBar.setButtonVisable(<span class="number">0</span>,<span class="keyword">true</span>);</span><br><span class="line">        mTopBar.setButtonVisable(<span class="number">1</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> type = ApplicationInfo.FLAG_SYSTEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;PMAppInfo&gt; <span class="title">getAppInfo</span><span class="params">(<span class="keyword">int</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取packageManager对象</span></span><br><span class="line">        pm = <span class="keyword">this</span>.getPackageManager();</span><br><span class="line">        <span class="comment">//获取应用信息</span></span><br><span class="line">        List&lt;ApplicationInfo&gt; listApplications = pm.getInstalledApplications(PackageManager.GET_UNINSTALLED_PACKAGES);</span><br><span class="line">        List&lt;PMAppInfo&gt; appInfos = <span class="keyword">new</span> ArrayList&lt;PMAppInfo&gt;();</span><br><span class="line">        <span class="comment">//判断类型</span></span><br><span class="line">        <span class="keyword">switch</span> (flag) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> appInfos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-重写View实现全新的控件"><a href="#3-重写View实现全新的控件" class="headerlink" title="3.重写View实现全新的控件"></a>3.重写View实现全新的控件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.customview;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Canvas;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Color;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Paint;</span><br><span class="line"><span class="keyword">import</span> android.graphics.RectF;</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet;</span><br><span class="line"><span class="keyword">import</span> android.util.DisplayMetrics;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.annotation.Nullable;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 圆的半径是屏幕宽度的1/4，原点坐标x,y，值大小都是屏幕的1/2*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="comment">//圆画笔</span></span><br><span class="line">    <span class="keyword">private</span> Paint mCirclePaint;</span><br><span class="line">    <span class="comment">//xy坐标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mCircleXY;</span><br><span class="line">    <span class="comment">//圆的半径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> mRadius;</span><br><span class="line">    <span class="comment">//屏幕宽度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mScreenWidth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//文字画笔</span></span><br><span class="line">    <span class="keyword">private</span> Paint mTextPaint;</span><br><span class="line">    <span class="comment">//绘制文字</span></span><br><span class="line">    <span class="keyword">private</span> String mShowText = <span class="string">&quot;Android Skill&quot;</span>;</span><br><span class="line">    <span class="comment">//文字大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mShowTextSize = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//圆弧的画笔</span></span><br><span class="line">    <span class="keyword">private</span> Paint mArcPaint;</span><br><span class="line">    <span class="comment">//圆弧扫过的角度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> sweepAngle;</span><br><span class="line">    <span class="comment">//矩形，用来辅助绘制圆弧</span></span><br><span class="line">    <span class="keyword">private</span> RectF mRectF;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomView</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        mScreenWidth = getScreenWidth(mContext);</span><br><span class="line">        <span class="comment">//圆心坐标</span></span><br><span class="line">        mCircleXY = mScreenWidth/<span class="number">2f</span>;</span><br><span class="line">        mRadius = mScreenWidth / <span class="number">8f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//圆弧扫过的角度，360度的66%</span></span><br><span class="line">        sweepAngle = <span class="number">66</span> / <span class="number">100f</span> * <span class="number">360f</span>;</span><br><span class="line">        initPaint();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*获取屏幕宽度*/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getScreenWidth</span><span class="params">(Context activity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*DisplayMetrics metrics = new DisplayMetrics();</span></span><br><span class="line"><span class="comment">        activity.getWindowManager().getDefaultDisplay().getRealMetrics(metrics);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> activity.getResources().getDisplayMetrics().widthPixels;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*初始化画笔*/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPaint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mCirclePaint = <span class="keyword">new</span> Paint();</span><br><span class="line">        <span class="comment">//画笔颜色</span></span><br><span class="line">        mCirclePaint.setColor(getResources().getColor(android.R.color.holo_blue_bright));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文字画笔</span></span><br><span class="line">        mTextPaint = <span class="keyword">new</span> Paint();</span><br><span class="line">        <span class="comment">//颜色</span></span><br><span class="line">        mTextPaint.setColor(Color.BLACK);</span><br><span class="line">        <span class="comment">//文字大小</span></span><br><span class="line">        mTextPaint.setTextSize(mShowTextSize);</span><br><span class="line">        <span class="comment">//文字对齐</span></span><br><span class="line">        mTextPaint.setTextAlign(Paint.Align.CENTER);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//弧度的画笔</span></span><br><span class="line">        mArcPaint = <span class="keyword">new</span> Paint();</span><br><span class="line">        <span class="comment">//颜色</span></span><br><span class="line">        mArcPaint.setColor(getResources().getColor(android.R.color.holo_blue_bright));</span><br><span class="line">        <span class="comment">//描边</span></span><br><span class="line">        mArcPaint.setStyle(Paint.Style.STROKE);</span><br><span class="line">        <span class="comment">//描边宽度</span></span><br><span class="line">        mArcPaint.setStrokeWidth(mScreenWidth*<span class="number">0.1f</span>);</span><br><span class="line">        <span class="comment">//创建一个矩形，用来辅助绘制圆弧</span></span><br><span class="line">        mRectF = <span class="keyword">new</span> RectF(mScreenWidth*<span class="number">0.2f</span>,mScreenWidth*<span class="number">0.2f</span>,mScreenWidth*<span class="number">0.8f</span>,mScreenWidth*<span class="number">0.8f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">        <span class="comment">//绘制圆</span></span><br><span class="line">        <span class="comment">/* 绘制圆</span></span><br><span class="line"><span class="comment">         第一个参数是 圆心的 x 坐标</span></span><br><span class="line"><span class="comment">         第二个参数是 圆心的 y 坐标</span></span><br><span class="line"><span class="comment">         第三个参数是 圆的半径</span></span><br><span class="line"><span class="comment">         第四个参数是 画笔*/</span></span><br><span class="line">        canvas.drawCircle(mCircleXY,mCircleXY,mRadius,mCirclePaint);</span><br><span class="line">        <span class="comment">//绘制文字</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一个参数是 要绘制的文字内容</span></span><br><span class="line"><span class="comment">         * 第二个参数是 要绘制的文字中第一个字符的索引</span></span><br><span class="line"><span class="comment">         * 第三个参数是 要绘制的文字中最后一个字符的索引减去一</span></span><br><span class="line"><span class="comment">         * 第四个参数是 要绘制文字的原点的 x 坐标</span></span><br><span class="line"><span class="comment">         * 第五个参数是 要绘制文字的原点的 y 坐标</span></span><br><span class="line"><span class="comment">         * 第六个参数是 画笔 */</span></span><br><span class="line">        canvas.drawText(mShowText,<span class="number">0</span>,mShowText.length(),mCircleXY,mCircleXY+mShowTextSize/<span class="number">4</span>,mTextPaint);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绘制圆弧</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一个参数是 椭圆的边界，用来定义弧形的形状和大小</span></span><br><span class="line"><span class="comment">         * 第二个参数是 圆弧的起始角度</span></span><br><span class="line"><span class="comment">         * 第三个参数是 圆弧扫过的角度</span></span><br><span class="line"><span class="comment">         * 第四个参数是 这个参数如果为 true，就把椭圆的中心包括在圆弧中</span></span><br><span class="line"><span class="comment">         * 第五个参数是 画笔</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        canvas.drawArc(mRectF,<span class="number">270</span>,sweepAngle,<span class="keyword">false</span>,mArcPaint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-8-事件拦截机制分析"><a href="#3-8-事件拦截机制分析" class="headerlink" title="3.8 事件拦截机制分析"></a>3.8 事件拦截机制分析</h4><p><code>dispatchTouchEvent</code>:决定了事件是否继续分发下去和是否响应事件，false：继续分发，true：不继续分发，此次事件到此结束，也不会有任何控件执行<code>onTouchEvent</code>方法。</p>
<p><code>onInterceptTouchEvent</code>：决定了是否拦截该事件，false：不拦截，true：拦截，此时当前控件执行<code>onTouchEvent</code>方法。</p>
<p><code>onTouchEvent</code>：决定了是否消费该事件，false：不消费,true：消费。</p>
<h5 id="OnTouchListener、OnTouchEvent、OnClickListener事件分发顺序"><a href="#OnTouchListener、OnTouchEvent、OnClickListener事件分发顺序" class="headerlink" title="OnTouchListener、OnTouchEvent、OnClickListener事件分发顺序"></a><code>OnTouchListener</code>、<code>OnTouchEvent</code>、<code>OnClickListener</code>事件分发顺序</h5><p>1、调用顺序，<code>OnTouchListener.onTouch()</code>—&gt; <code>onTouchEvent()</code>—&gt;<code>OnClickListener.onClick()</code>，其中若<code>onTouch</code>返回值为<strong>true</strong>，则会屏蔽掉<strong>onTouchEvent</strong>方法和<strong>OnClickListener</strong>.onClick方法，若<strong>onTouchEvent</strong>方法可以被调用，则<strong>OnClickListener</strong>.onClick方法也一定可以被调用。</p>
<p>2、一系列点击事件，肯定是以down事件开始，以up事件结束，中间若干个move事件。如果一旦某个元素拦截了某个事件，那么同一个事件序列内的所有事件都会直接交给它处理。（详见Android开发艺术探索P142)</p>
<p>3、首先，考虑<code>OnTouchListener.onTouch</code>返回的是false，此种情况下，首先down事件按照顺序先经过OnTouchListener.onTouch方法，由于返回false不屏蔽onTouchEvent方法，所以又被分发到onTouchEvent方法，由于该方法默认返回true（详见Android开发艺术探索P143），即消费了down事件，所以此后的所有事件都由该方法处理，并且不再经过OnTouchListener.onTouch。可以看下图log证实了这点，当手指试图滑动时，down事件分别经过两个方法，其他的事件只经过onTouchEventx</p>
<h5 id="滑动冲突-分为三种"><a href="#滑动冲突-分为三种" class="headerlink" title="滑动冲突:分为三种"></a>滑动冲突:分为三种</h5><p>1.外部滑动方向和内部滑动方向不一致</p>
<p>典型一个左右滑动的Viewpager+上下滑动的Fragment(Viewpager已经处理了滑动冲突)</p>
<p>2.外部滑动方向和内部滑动方向一致</p>
<p>3.上述两种情况的嵌套</p>
<p>对于情况一,判断用户是上下滑动还是左右滑动,可以根据角度,距离差,速度差来进行判断</p>
<p>对于情况二,要根据业务情况来处理规则</p>
<ul>
<li><p>外部拦截法:父容器覆写onIntercepted方法,根据情况是否拦截消耗事件(通常选用该方法)</p>
</li>
<li><p>内部拦截法:父容器不做处理,由子控件是否拦截和消耗(要配合requestDisallowInterceptTouchEvent()来使用,父容器不能拦截ACTION_DOWN,因为该事件不受requestDisallowInterceptTouchEvent()控制</p>
</li>
</ul>
<h3 id="第4章-ListView使用技巧"><a href="#第4章-ListView使用技巧" class="headerlink" title="第4章 ListView使用技巧"></a>第4章 ListView使用技巧</h3><h3 id="第5章Android-Scroll分析"><a href="#第5章Android-Scroll分析" class="headerlink" title="第5章Android Scroll分析"></a>第5章Android Scroll分析</h3><h3 id="第6章Android绘图机制与处理技巧"><a href="#第6章Android绘图机制与处理技巧" class="headerlink" title="第6章Android绘图机制与处理技巧"></a>第6章Android绘图机制与处理技巧</h3><h3 id="第7章Android动画机制与使用技巧"><a href="#第7章Android动画机制与使用技巧" class="headerlink" title="第7章Android动画机制与使用技巧"></a>第7章Android动画机制与使用技巧</h3><h3 id="第8章Activity与Activity调用栈分析"><a href="#第8章Activity与Activity调用栈分析" class="headerlink" title="第8章Activity与Activity调用栈分析"></a>第8章Activity与Activity调用栈分析</h3><h4 id="8-1-Activity"><a href="#8-1-Activity" class="headerlink" title="8.1 Activity"></a>8.1 Activity</h4><h3 id="第9章Android系统信息与安全机制"><a href="#第9章Android系统信息与安全机制" class="headerlink" title="第9章Android系统信息与安全机制"></a>第9章Android系统信息与安全机制</h3><h4 id="9-1-Android系统信息获取"><a href="#9-1-Android系统信息获取" class="headerlink" title="9.1 Android系统信息获取"></a>9.1 Android系统信息获取</h4><ul>
<li>android.os.Build</li>
<li>SystemProperty（存储设置软硬件信息的类）</li>
</ul>
<h4 id="9-2-Apk应用信息的获取"><a href="#9-2-Apk应用信息的获取" class="headerlink" title="9.2 Apk应用信息的获取"></a>9.2 Apk应用信息的获取</h4><ul>
<li>PM（PackagerManager），应用的包管理</li>
<li>AM (ActivityManager)，应用的活动管理</li>
</ul>
<p><img src="https://s2.loli.net/2022/08/07/RYQx4sAkyNCJnIg.png" alt="Packager结构"></p>
<p>Activity信息使用ActivityInfo类来进行封装</p>
<p>Maninifest文件中的节点的信息，使用PackageInfo来进行封装</p>
<h3 id="第10章Android性能优化"><a href="#第10章Android性能优化" class="headerlink" title="第10章Android性能优化"></a>第10章Android性能优化</h3><h3 id="第11章搭建云端服务器"><a href="#第11章搭建云端服务器" class="headerlink" title="第11章搭建云端服务器"></a>第11章搭建云端服务器</h3><h3 id="第12章Android-5-X新特性详解"><a href="#第12章Android-5-X新特性详解" class="headerlink" title="第12章Android 5.X新特性详解"></a>第12章Android 5.X新特性详解</h3><h3 id="第13章-Android实例提高"><a href="#第13章-Android实例提高" class="headerlink" title="第13章 Android实例提高"></a>第13章 Android实例提高</h3>

	<div class="row">
    <embed src="https://maipdf.cn/pdf/a82246713196@pdf" width="100%" height="550" type="application/pdf">
	</div>






	<div class="row">
    <embed src="https://maipdf.cn/pdf/a86321716085@pdf" width="100%" height="550" type="application/pdf">
	</div>


]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发艺术探索_10_Android的消息机制</title>
    <url>/2022/08/16/Android/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2_10_Android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<hr>
<h2 id="Android开发艺术探索-10-Android的消息机制"><a href="#Android开发艺术探索-10-Android的消息机制" class="headerlink" title="Android开发艺术探索_10_Android的消息机制"></a>Android开发艺术探索_10_Android的消息机制</h2><blockquote>
<p>Android的消息机制主要是指Handler的运行机制，Handler的运行需要底层的<code>MessageQueue</code>和<code>Looper</code>的支撑。<code>MessageQueue</code>的中文翻译是消息队列，顾名思义，它的内部存储了一组消息，以队列的形式对外提供插入和删除的工作。虽然叫消息队列，但是它的内部存储结构并不是真正的队列，而是采用<code>单链表的数据结构</code>来存储消息列表。Looper的中文翻译为循环，在这里可以理解为消息循环。由于<code>MessageQueue</code>只是一个消息的存储单元，它不能去处理消息，而Looper就填补了这个功能，循环的形式去查找是否有新消息，如果有的话就处理消息，否则就一直等待着。<code>Looper</code>中还有一个特殊的概念，那就是<code>ThreadLocal</code>，<code>ThreadLocal</code>并不是线程，它的作用是可以在每个线程中存储数据。我们知道，Handler创建的时候会采用当前线程的Looper来构造消息循环系统，那么Handler内部如何获取到当前线程的Looper呢？这就要使用<code>ThreadLocal</code>了，<code>ThreadLocal</code>可以在不同的线程中互不干扰地存储并提供数据，通过<code>ThreadLocal</code>可以轻松获取每个线程的Looper。当然需要注意的是，线程是默认没有Looper的，如果需要使用Handler就必须为线程创建Looper。</p>
</blockquote>
<h3 id="1、Android消息机制概述"><a href="#1、Android消息机制概述" class="headerlink" title="1、Android消息机制概述"></a>1、Android消息机制概述</h3><p>Android的消息机制主要是指Handler的运行机制以及Handler所附带的<code>MessageQueue</code>和Looper的工作过程，三者实际上是一个整体。Handler的主要作用是将一个任务切换到某个指定的线程中去执行，1这是因为Android规定访问<code>UI</code>只能在主线程中进行，如果在子线程中访问<code>UI</code>，那么程序就会抛出异常。<code>ViewRootlmpl</code>对UI操作做了验证，这个验证工作是由<code>ViewRootlmpl</code>的<code>checkThread</code>方法来完成的，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ViewRootImpl.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//mThread是在构造方法里面初始化的</span></span><br><span class="line">    <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CalledFromWrongThreadException(</span><br><span class="line">                <span class="string">&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Handler创建完毕后，这个时候其内部的Looper以及<code>MessageQueue</code>就可以和Handler一起协同工作了，然后通过Handler的post方法将一个<code>Runnable</code>投递到Handler内部的Looper中去处理，也可以通过Handler的send方法发送一个消息，这个消息同样会在Looper中去处理。其实post方法最终也是通过send方法来完成的，接下来主要来看一下send方法的工作过程。当Handler的send方法被调用时，它会调用<code>MessageQueue</code>的<code>enqueueMessage</code>方法将这个消息放入消息队列中，然后Looper发现有新消息到来时，就会处理这个消息，最终消息中的Runnable或者Handler的<code>handleMessage</code>方法就会被调用。注意Looper是运行在创建Handler所在的线程中的，这样一来Handler中的业务逻辑就被切换到创建Handler所在的线程中去执行了，这个过程可以用图10-1来表示。</p>
<p><img src="https://s2.loli.net/2022/08/15/o2m7YCURxlpPcgZ.png" alt="Handler工作过程"></p>
<h3 id="2、Android消息机制分析"><a href="#2、Android消息机制分析" class="headerlink" title="2、Android消息机制分析"></a>2、Android消息机制分析</h3><h4 id="2-1-ThreadLocal的工作原理"><a href="#2-1-ThreadLocal的工作原理" class="headerlink" title="2.1 ThreadLocal的工作原理"></a>2.1 <code>ThreadLocal</code>的工作原理</h4><p><code>ThreadLocal</code>是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取到数据。</p>
<p>当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用<code>ThreadLocal</code>。比如对于Handler来说，它需要获取当前线程的Looper，很显然Looper的作用域就是线程并且不同线程具有不同的Looper，这个时候通过<code>ThreadLocal</code>就可以轻松实现Looper在线程中的存取。</p>
<p><code>ThreadLocal</code>另一个使用场景是复杂逻辑下的对象传递，比如监听器的传递。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ThreadLocal&lt;Boolean&gt; mBooleanThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    mBooleanThreadLocal.set(<span class="keyword">false</span>);</span><br><span class="line">    Log.i(TAG, <span class="string">&quot;demo: Thread#main:mBooleanThreadLocal:&quot;</span>+mBooleanThreadLocal.get());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">&quot;Thread#1&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">            mBooleanThreadLocal.set(<span class="keyword">true</span>);</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;run: Thread#1:mBooleanThreadLocal:&quot;</span>+mBooleanThreadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">&quot;Thread#2&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;run: Thread#2:mBooleanThreadLocal:&quot;</span>+mBooleanThreadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-消息队列的工作原理"><a href="#2-2-消息队列的工作原理" class="headerlink" title="2.2 消息队列的工作原理"></a>2.2 消息队列的工作原理</h4><p>消息队列在Android中指的是<code>MessageQueue</code>，<code>MessageQueue</code> 主要包含两个操作：插入和读取。读取操作本身会伴随着删除操作，插入和读取对应的方法分别为<code>enqueueMessage</code>和<code>next</code>，其中<code>enqueueMessage</code>的作用是往消息队列中插入一条消息，而next的作用是从消息队列中取出一条消息并将其从消息队列中移除。尽管<code>MessageQueue</code>叫消息队列，但是它的内部实现并不是用的队列，实际上它是通过一个单链表的数据结构来维护消息列表，单链表在插入和删除上比较有优势。下面主要看一下它的<code>enqueueMessage</code>和next方法的实现，<code>enqueueMessage</code>的源码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现next方法是一个无限循环的方法，如果消息队列中没有消息，那么next方法会一直阻塞在这里。当有新消息到来时，next方法会返回这条消息并将其从单链表中移除。</p>
<h4 id="2-3-Looper的工作原理"><a href="#2-3-Looper的工作原理" class="headerlink" title="2.3 Looper的工作原理"></a>2.3 Looper的工作原理</h4><p>Looper在Android的消息机制中扮演着消息循环的角色，具体来说就是它会不停地从<code>MessageQueue</code>中查看是否有新消息，如果有新消息就会立刻处理，否则就一直阻塞在那里。首先看一下它的构造方法，在构造方法中它会创建一个<code>MessageQueue</code>即消息队列，然后将当前线程的对象保存起来，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为当前线程创建Looper</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="string">&quot;Thread#3&quot;</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        Handler handler = <span class="keyword">new</span> Handler();</span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure>

<p>Looper除了prepare方法外，还提供了<code>prepareMainLooper</code>方法，这个方法主要是给主线程也就是<code>Activity Thread</code>创建Looper使用的，其本质也是通过prepare方法来实现的。由于主线程的Looper比较特殊，所以Looper 提供了一个<code>getMainLooper</code>方法，通过它可以在任何地方获取到主线程的Looper。Looper也是可以退出的，Looper 提供了<code>quit</code> 和<code>quitSafely</code>来退出一个Looper，</p>
<p>二者的区别是：quit 会直接退出Looper，而quitSafely只是设定一个退出标记，然后把消息队列中的已有消息处理完毕后才安全地退出。Looper退出后，通过Handler 发送的消息会失败，这个时候Handler的send方法会返回false。在子线程中，如果手动为其创建了Looper，那么在所有的事情完成以后应该调用quit方法来终止消息循环，否则这个子线程就会一直处于等待的状态，而如果退出Looper以后，这个线程就会立刻终止，因此建议不需要的时候终止Looper。<br>Looper最重要的一个方法是<code>loop</code>方法，只有调用了loop后，消息循环系统才会真正地起作用，它的实现如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (me.mInLoop) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Loop again would have the queued messages be executed&quot;</span></span><br><span class="line">                + <span class="string">&quot; before this one completed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    me.mInLoop = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow overriding a threshold with a system prop. e.g.</span></span><br><span class="line">    <span class="comment">// adb shell &#x27;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&#x27;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> thresholdOverride =</span><br><span class="line">            SystemProperties.getInt(<span class="string">&quot;log.looper.&quot;</span></span><br><span class="line">                    + Process.myUid() + <span class="string">&quot;.&quot;</span></span><br><span class="line">                    + Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">&quot;.slow&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> slowDeliveryDetected = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">        <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                    msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Make sure the observer won&#x27;t change while processing a transaction.</span></span><br><span class="line">        <span class="keyword">final</span> Observer observer = sObserver;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;</span><br><span class="line">        <span class="keyword">long</span> slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line">        <span class="keyword">long</span> slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;</span><br><span class="line">        <span class="keyword">if</span> (thresholdOverride &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            slowDispatchThresholdMs = thresholdOverride;</span><br><span class="line">            slowDeliveryThresholdMs = thresholdOverride;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> logSlowDelivery = (slowDeliveryThresholdMs &gt; <span class="number">0</span>) &amp;&amp; (msg.when &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> logSlowDispatch = (slowDispatchThresholdMs &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> needStartTime = logSlowDelivery || logSlowDispatch;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> needEndTime = logSlowDispatch;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> dispatchStart = needStartTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> dispatchEnd;</span><br><span class="line">        Object token = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            token = observer.messageDispatchStarting();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                observer.messageDispatched(token, msg);</span><br><span class="line">            &#125;</span><br><span class="line">            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logSlowDelivery) &#123;</span><br><span class="line">            <span class="keyword">if</span> (slowDeliveryDetected) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((dispatchStart - msg.when) &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">&quot;Drained&quot;</span>);</span><br><span class="line">                    slowDeliveryDetected = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, <span class="string">&quot;delivery&quot;</span>,</span><br><span class="line">                        msg)) &#123;</span><br><span class="line">                    <span class="comment">// Once we write a slow delivery log, suppress until the queue drains.</span></span><br><span class="line">                    slowDeliveryDetected = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logSlowDispatch) &#123;</span><br><span class="line">            showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, <span class="string">&quot;dispatch&quot;</span>, msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">        <span class="comment">// identity of the thread wasn&#x27;t corrupted.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">            Log.wtf(TAG, <span class="string">&quot;Thread identity changed from 0x&quot;</span></span><br><span class="line">                    + Long.toHexString(ident) + <span class="string">&quot; to 0x&quot;</span></span><br><span class="line">                    + Long.toHexString(newIdent) + <span class="string">&quot; while dispatching to &quot;</span></span><br><span class="line">                    + msg.target.getClass().getName() + <span class="string">&quot; &quot;</span></span><br><span class="line">                    + msg.callback + <span class="string">&quot; what=&quot;</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Looper的loop方法的工作过程也比较好理解，loop方法是一个死循环，唯一跳出循环的方式是MessageQueue的next方法返回了null。当Looper的quit方法被调用时，Looper就会调用MessageQueue的quit或者quitSafely方法来通知消息队列退出，当消息队列被标记为退出状态时，它的next方法就会返回null。也就是说，Looper必须退出，否则loop方法就会无限循环下去。loop方法会调用MessageQueue的next方法来获取新消息，而next是一个阻塞操作，当没有消息时，next方法会一直阻塞在那里，这也导致loop方法一直阻塞在那里。如果MessageQueue的next方法返回了新消息，Looper 就会处理这条消息：msg.target.dispatchMessage（msg），这里的msg.target是发送这条消息的Handler对象，这样Handler发送的消息最终又交给它的dispatchMessage方法来处理了。但是这里不同的是，Handler的dispatchMessage方法是在创建Handler时所使用的Looper中执行的，这样就成功地将代码逻辑切换到指定的线程中去执行了。</p>
<h4 id="2-4-Handler工作原理"><a href="#2-4-Handler工作原理" class="headerlink" title="2.4 Handler工作原理"></a>2.4 Handler工作原理</h4><p>Handler的工作主要包含消息的发送和接收过程。消息的发送可以通过post的一系列方法以及send的一系列方法来实现，post的一系列方法最终是通过send的一系列方法来实现的。发送一条消息的典型过程如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            delayMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="keyword">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">            Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        msg.target = <span class="keyword">this</span>;</span><br><span class="line">        msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，Handler发送消息的过程仅仅是向消息队列中插入了一条消息，MessageQueue的next方法就会返回这条消息给Looper，Looper收到消息后就开始处理了，最终消息由Looper交由Handler处理，即Handler的dispatchMessage方法会被调用，这时Handler就进入了处理消息的阶段。dispatchMessage的实现如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handle system messages here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，检查Message的callback是否为null，不为null就通过handleCallback来处理消息。Message的callback是一个Runnable对象，实际上就是Handler的post方法所传递的Runnable参数。handleCalback的逻辑也是很简单，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    message.callback.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，检查mCallback是否为null，不为null 就调用mCallback的handleMessage方法来处理消息。Callback是个接口，它的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg A &#123;<span class="doctag">@link</span> android.os.Message Message&#125; object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> True if no further handling is desired</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/08/16/P8xDwY3qER1pGUs.png" alt="image-20220816080944833"></p>
<h3 id="主线程的消息循环"><a href="#主线程的消息循环" class="headerlink" title="主线程的消息循环"></a>主线程的消息循环</h3><p>Android的主线程就是ActivityThread，主线程的入口方法为main，在main方法中系统会通过Looper.prepareMainLooper）来创建主线程的Looper以及MessageQueue，并通过Looper.loop）来开启主线程的消息循环，这个过程如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;ActivityThreadMain&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install selective syscall interception</span></span><br><span class="line">    AndroidOs.install();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></span><br><span class="line">    <span class="comment">// disable it here, but selectively enable it later (via</span></span><br><span class="line">    <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></span><br><span class="line">    CloseGuard.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></span><br><span class="line">    <span class="keyword">final</span> File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call per-process mainline module initialization.</span></span><br><span class="line">    initializeMainlineModules();</span><br><span class="line"></span><br><span class="line">    Process.setArgV0(<span class="string">&quot;&lt;pre-initialized&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line.</span></span><br><span class="line">    <span class="comment">// It will be in the format &quot;seq=114&quot;</span></span><br><span class="line">    <span class="keyword">long</span> startSeq = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = args.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (args[i] != <span class="keyword">null</span> &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123;</span><br><span class="line">                startSeq = Long.parseLong(</span><br><span class="line">                        args[i].substring(PROC_START_SEQ_IDENT.length()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                LogPrinter(Log.DEBUG, <span class="string">&quot;ActivityThread&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主线程的消息循环开始了以后，ActivityThread还需要一个Handler来和消息队列进行交互，这个Handler就是ActivityThread.H，它内部定义了一组消息类型，主要包含了四大组件的启动和停止等过程，如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BIND_APPLICATION        = <span class="number">110</span>;</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXIT_APPLICATION        = <span class="number">111</span>;</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RECEIVER                = <span class="number">113</span>;</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CREATE_SERVICE          = <span class="number">114</span>;</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVICE_ARGS            = <span class="number">115</span>;</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP_SERVICE            = <span class="number">116</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONFIGURATION_CHANGED   = <span class="number">118</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLEAN_UP_CONTEXT        = <span class="number">119</span>;</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GC_WHEN_IDLE            = <span class="number">120</span>;</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BIND_SERVICE            = <span class="number">121</span>;</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNBIND_SERVICE          = <span class="number">122</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DUMP_SERVICE            = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LOW_MEMORY              = <span class="number">124</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROFILER_CONTROL        = <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CREATE_BACKUP_AGENT     = <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DESTROY_BACKUP_AGENT    = <span class="number">129</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUICIDE                 = <span class="number">130</span>;</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REMOVE_PROVIDER         = <span class="number">131</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DISPATCH_PACKAGE_BROADCAST = <span class="number">133</span>;</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SCHEDULE_CRASH          = <span class="number">134</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DUMP_HEAP               = <span class="number">135</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DUMP_ACTIVITY           = <span class="number">136</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SLEEPING                = <span class="number">137</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SET_CORE_SETTINGS       = <span class="number">138</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UPDATE_PACKAGE_COMPATIBILITY_INFO = <span class="number">139</span>;</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DUMP_PROVIDER           = <span class="number">141</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSTABLE_PROVIDER_DIED  = <span class="number">142</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST_ASSIST_CONTEXT_EXTRAS = <span class="number">143</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSLUCENT_CONVERSION_COMPLETE = <span class="number">144</span>;</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSTALL_PROVIDER        = <span class="number">145</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ON_NEW_ACTIVITY_OPTIONS = <span class="number">146</span>;</span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ENTER_ANIMATION_COMPLETE = <span class="number">149</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> START_BINDER_TRACKING = <span class="number">150</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP_BINDER_TRACKING_AND_DUMP = <span class="number">151</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LOCAL_VOICE_INTERACTION_STARTED = <span class="number">154</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ATTACH_AGENT = <span class="number">155</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> APPLICATION_INFO_CHANGED = <span class="number">156</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUN_ISOLATED_ENTRY_POINT = <span class="number">158</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXECUTE_TRANSACTION = <span class="number">159</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RELAUNCH_ACTIVITY = <span class="number">160</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PURGE_RESOURCES = <span class="number">161</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ATTACH_STARTUP_AGENTS = <span class="number">162</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">codeToString</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MESSAGES) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">                <span class="keyword">case</span> BIND_APPLICATION: <span class="keyword">return</span> <span class="string">&quot;BIND_APPLICATION&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> EXIT_APPLICATION: <span class="keyword">return</span> <span class="string">&quot;EXIT_APPLICATION&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> RECEIVER: <span class="keyword">return</span> <span class="string">&quot;RECEIVER&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> CREATE_SERVICE: <span class="keyword">return</span> <span class="string">&quot;CREATE_SERVICE&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> SERVICE_ARGS: <span class="keyword">return</span> <span class="string">&quot;SERVICE_ARGS&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> STOP_SERVICE: <span class="keyword">return</span> <span class="string">&quot;STOP_SERVICE&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> CONFIGURATION_CHANGED: <span class="keyword">return</span> <span class="string">&quot;CONFIGURATION_CHANGED&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> CLEAN_UP_CONTEXT: <span class="keyword">return</span> <span class="string">&quot;CLEAN_UP_CONTEXT&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> GC_WHEN_IDLE: <span class="keyword">return</span> <span class="string">&quot;GC_WHEN_IDLE&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> BIND_SERVICE: <span class="keyword">return</span> <span class="string">&quot;BIND_SERVICE&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> UNBIND_SERVICE: <span class="keyword">return</span> <span class="string">&quot;UNBIND_SERVICE&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> DUMP_SERVICE: <span class="keyword">return</span> <span class="string">&quot;DUMP_SERVICE&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> LOW_MEMORY: <span class="keyword">return</span> <span class="string">&quot;LOW_MEMORY&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> PROFILER_CONTROL: <span class="keyword">return</span> <span class="string">&quot;PROFILER_CONTROL&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> CREATE_BACKUP_AGENT: <span class="keyword">return</span> <span class="string">&quot;CREATE_BACKUP_AGENT&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> DESTROY_BACKUP_AGENT: <span class="keyword">return</span> <span class="string">&quot;DESTROY_BACKUP_AGENT&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> SUICIDE: <span class="keyword">return</span> <span class="string">&quot;SUICIDE&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> REMOVE_PROVIDER: <span class="keyword">return</span> <span class="string">&quot;REMOVE_PROVIDER&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> DISPATCH_PACKAGE_BROADCAST: <span class="keyword">return</span> <span class="string">&quot;DISPATCH_PACKAGE_BROADCAST&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> SCHEDULE_CRASH: <span class="keyword">return</span> <span class="string">&quot;SCHEDULE_CRASH&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> DUMP_HEAP: <span class="keyword">return</span> <span class="string">&quot;DUMP_HEAP&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> DUMP_ACTIVITY: <span class="keyword">return</span> <span class="string">&quot;DUMP_ACTIVITY&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> SET_CORE_SETTINGS: <span class="keyword">return</span> <span class="string">&quot;SET_CORE_SETTINGS&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> UPDATE_PACKAGE_COMPATIBILITY_INFO: <span class="keyword">return</span> <span class="string">&quot;UPDATE_PACKAGE_COMPATIBILITY_INFO&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> DUMP_PROVIDER: <span class="keyword">return</span> <span class="string">&quot;DUMP_PROVIDER&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> UNSTABLE_PROVIDER_DIED: <span class="keyword">return</span> <span class="string">&quot;UNSTABLE_PROVIDER_DIED&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> REQUEST_ASSIST_CONTEXT_EXTRAS: <span class="keyword">return</span> <span class="string">&quot;REQUEST_ASSIST_CONTEXT_EXTRAS&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> TRANSLUCENT_CONVERSION_COMPLETE: <span class="keyword">return</span> <span class="string">&quot;TRANSLUCENT_CONVERSION_COMPLETE&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> INSTALL_PROVIDER: <span class="keyword">return</span> <span class="string">&quot;INSTALL_PROVIDER&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> ON_NEW_ACTIVITY_OPTIONS: <span class="keyword">return</span> <span class="string">&quot;ON_NEW_ACTIVITY_OPTIONS&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> ENTER_ANIMATION_COMPLETE: <span class="keyword">return</span> <span class="string">&quot;ENTER_ANIMATION_COMPLETE&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> LOCAL_VOICE_INTERACTION_STARTED: <span class="keyword">return</span> <span class="string">&quot;LOCAL_VOICE_INTERACTION_STARTED&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> ATTACH_AGENT: <span class="keyword">return</span> <span class="string">&quot;ATTACH_AGENT&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> APPLICATION_INFO_CHANGED: <span class="keyword">return</span> <span class="string">&quot;APPLICATION_INFO_CHANGED&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> RUN_ISOLATED_ENTRY_POINT: <span class="keyword">return</span> <span class="string">&quot;RUN_ISOLATED_ENTRY_POINT&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> EXECUTE_TRANSACTION: <span class="keyword">return</span> <span class="string">&quot;EXECUTE_TRANSACTION&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> RELAUNCH_ACTIVITY: <span class="keyword">return</span> <span class="string">&quot;RELAUNCH_ACTIVITY&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> PURGE_RESOURCES: <span class="keyword">return</span> <span class="string">&quot;PURGE_RESOURCES&quot;</span>;</span><br><span class="line">                <span class="keyword">case</span> ATTACH_STARTUP_AGENTS: <span class="keyword">return</span> <span class="string">&quot;ATTACH_STARTUP_AGENTS&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.toString(code);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">&quot;&gt;&gt;&gt; handling: &quot;</span> + codeToString(msg.what));</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> BIND_APPLICATION:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;bindApplication&quot;</span>);</span><br><span class="line">                AppBindData data = (AppBindData)msg.obj;</span><br><span class="line">                handleBindApplication(data);</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EXIT_APPLICATION:</span><br><span class="line">                <span class="keyword">if</span> (mInitialApplication != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mInitialApplication.onTerminate();</span><br><span class="line">                &#125;</span><br><span class="line">                Looper.myLooper().quit();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RECEIVER:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;broadcastReceiveComp&quot;</span>);</span><br><span class="line">                handleReceiver((ReceiverData)msg.obj);</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CREATE_SERVICE:</span><br><span class="line">                <span class="keyword">if</span> (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) &#123;</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">                            (<span class="string">&quot;serviceCreate: &quot;</span> + String.valueOf(msg.obj)));</span><br><span class="line">                &#125;</span><br><span class="line">                handleCreateService((CreateServiceData)msg.obj);</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BIND_SERVICE:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;serviceBind&quot;</span>);</span><br><span class="line">                handleBindService((BindServiceData)msg.obj);</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> UNBIND_SERVICE:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;serviceUnbind&quot;</span>);</span><br><span class="line">                handleUnbindService((BindServiceData)msg.obj);</span><br><span class="line">                schedulePurgeIdler();</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SERVICE_ARGS:</span><br><span class="line">                <span class="keyword">if</span> (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) &#123;</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">                            (<span class="string">&quot;serviceStart: &quot;</span> + String.valueOf(msg.obj)));</span><br><span class="line">                &#125;</span><br><span class="line">                handleServiceArgs((ServiceArgsData)msg.obj);</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOP_SERVICE:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;serviceStop&quot;</span>);</span><br><span class="line">                handleStopService((IBinder)msg.obj);</span><br><span class="line">                schedulePurgeIdler();</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CONFIGURATION_CHANGED:</span><br><span class="line">                handleConfigurationChanged((Configuration) msg.obj);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLEAN_UP_CONTEXT:</span><br><span class="line">                ContextCleanupInfo cci = (ContextCleanupInfo)msg.obj;</span><br><span class="line">                cci.context.performFinalCleanup(cci.who, cci.what);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> GC_WHEN_IDLE:</span><br><span class="line">                scheduleGcIdler();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DUMP_SERVICE:</span><br><span class="line">                handleDumpService((DumpComponentInfo)msg.obj);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LOW_MEMORY:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;lowMemory&quot;</span>);</span><br><span class="line">                handleLowMemory();</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PROFILER_CONTROL:</span><br><span class="line">                handleProfilerControl(msg.arg1 != <span class="number">0</span>, (ProfilerInfo)msg.obj, msg.arg2);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CREATE_BACKUP_AGENT:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;backupCreateAgent&quot;</span>);</span><br><span class="line">                handleCreateBackupAgent((CreateBackupAgentData)msg.obj);</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DESTROY_BACKUP_AGENT:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;backupDestroyAgent&quot;</span>);</span><br><span class="line">                handleDestroyBackupAgent((CreateBackupAgentData)msg.obj);</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SUICIDE:</span><br><span class="line">                Process.killProcess(Process.myPid());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> REMOVE_PROVIDER:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;providerRemove&quot;</span>);</span><br><span class="line">                completeRemoveProvider((ProviderRefCount)msg.obj);</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DISPATCH_PACKAGE_BROADCAST:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;broadcastPackage&quot;</span>);</span><br><span class="line">                handleDispatchPackageBroadcast(msg.arg1, (String[])msg.obj);</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SCHEDULE_CRASH:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RemoteServiceException((String)msg.obj);</span><br><span class="line">            <span class="keyword">case</span> DUMP_HEAP:</span><br><span class="line">                handleDumpHeap((DumpHeapData) msg.obj);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DUMP_ACTIVITY:</span><br><span class="line">                handleDumpActivity((DumpComponentInfo)msg.obj);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DUMP_PROVIDER:</span><br><span class="line">                handleDumpProvider((DumpComponentInfo)msg.obj);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SET_CORE_SETTINGS:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;setCoreSettings&quot;</span>);</span><br><span class="line">                handleSetCoreSettings((Bundle) msg.obj);</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> UPDATE_PACKAGE_COMPATIBILITY_INFO:</span><br><span class="line">                handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData)msg.obj);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> UNSTABLE_PROVIDER_DIED:</span><br><span class="line">                handleUnstableProviderDied((IBinder)msg.obj, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> REQUEST_ASSIST_CONTEXT_EXTRAS:</span><br><span class="line">                handleRequestAssistContextExtras((RequestAssistContextExtras)msg.obj);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TRANSLUCENT_CONVERSION_COMPLETE:</span><br><span class="line">                handleTranslucentConversionComplete((IBinder)msg.obj, msg.arg1 == <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> INSTALL_PROVIDER:</span><br><span class="line">                handleInstallProvider((ProviderInfo) msg.obj);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_NEW_ACTIVITY_OPTIONS:</span><br><span class="line">                Pair&lt;IBinder, ActivityOptions&gt; pair = (Pair&lt;IBinder, ActivityOptions&gt;) msg.obj;</span><br><span class="line">                onNewActivityOptions(pair.first, pair.second);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ENTER_ANIMATION_COMPLETE:</span><br><span class="line">                handleEnterAnimationComplete((IBinder) msg.obj);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> START_BINDER_TRACKING:</span><br><span class="line">                handleStartBinderTracking();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOP_BINDER_TRACKING_AND_DUMP:</span><br><span class="line">                handleStopBinderTrackingAndDump((ParcelFileDescriptor) msg.obj);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> LOCAL_VOICE_INTERACTION_STARTED:</span><br><span class="line">                handleLocalVoiceInteractionStarted((IBinder) ((SomeArgs) msg.obj).arg1,</span><br><span class="line">                        (IVoiceInteractor) ((SomeArgs) msg.obj).arg2);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ATTACH_AGENT: &#123;</span><br><span class="line">                Application app = getApplication();</span><br><span class="line">                handleAttachAgent((String) msg.obj, app != <span class="keyword">null</span> ? app.mLoadedApk : <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> APPLICATION_INFO_CHANGED:</span><br><span class="line">                handleApplicationInfoChanged((ApplicationInfo) msg.obj);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUN_ISOLATED_ENTRY_POINT:</span><br><span class="line">                handleRunIsolatedEntryPoint((String) ((SomeArgs) msg.obj).arg1,</span><br><span class="line">                        (String[]) ((SomeArgs) msg.obj).arg2);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EXECUTE_TRANSACTION:</span><br><span class="line">                <span class="keyword">final</span> ClientTransaction transaction = (ClientTransaction) msg.obj;</span><br><span class="line">                mTransactionExecutor.execute(transaction);</span><br><span class="line">                <span class="keyword">if</span> (isSystem()) &#123;</span><br><span class="line">                    <span class="comment">// Client transactions inside system process are recycled on the client side</span></span><br><span class="line">                    <span class="comment">// instead of ClientLifecycleManager to avoid being cleared before this</span></span><br><span class="line">                    <span class="comment">// message is handled.</span></span><br><span class="line">                    transaction.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// TODO(lifecycler): Recycle locally scheduled transactions.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RELAUNCH_ACTIVITY:</span><br><span class="line">                handleRelaunchActivityLocally((IBinder) msg.obj);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PURGE_RESOURCES:</span><br><span class="line">                schedulePurgeIdler();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ATTACH_STARTUP_AGENTS:</span><br><span class="line">                handleAttachStartupAgents((String) msg.obj);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object obj = msg.obj;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> SomeArgs) &#123;</span><br><span class="line">            ((SomeArgs) obj).recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">&quot;&lt;&lt;&lt; done: &quot;</span> + codeToString(msg.what));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Activity Thread 通过ApplicationThread和AMS进行进程间通信，AMS以进程间通信的方式完成Activity Thread的请求后会回调ApplicationThread中的Binder方法，然后ApplicationThread会向H发送消息，H收到消息后会将ApplicationThread中的逻辑切换到ActivityThread中去执行，即切换到主线程中去执行，这个过程就是主线程的消息循环模型。</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发艺术探索_2_IPC机制</title>
    <url>/2022/08/16/Android/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2_2_IPC%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<hr>
<h2 id="Android开发艺术探索-2-IPC机制"><a href="#Android开发艺术探索-2-IPC机制" class="headerlink" title="Android开发艺术探索_2_IPC机制"></a>Android开发艺术探索_2_IPC机制</h2><blockquote>
<p>IPC:Inter-Process Communication(进程间通信或跨进程通常)，是指两个进程之间进行数据交换的过程。</p>
</blockquote>
<p>跨进程通信方式：</p>
<ul>
<li>Binder</li>
<li>Socket：可以任意两个终端之间，也可以同一个设备上两个进程。</li>
<li>ContentProvider：</li>
</ul>
<p>多进程通信的场景：</p>
<ul>
<li>应用因为某些原因自身需要采用多进程模式来实现</li>
<li>当前应用需要向其他应用获取数据</li>
</ul>
<h4 id="2-2-Android-多进程模式"><a href="#2-2-Android-多进程模式" class="headerlink" title="2.2 Android 多进程模式"></a>2.2 Android 多进程模式</h4><blockquote>
<p>Android 多进程模式，通过给四大组件指定Android:process属性，只有这一个办法。特殊方法：通过JNI在native层去fork一个新的进程。</p>
</blockquote>
<h5 id="2-2-1-开启多进程模式"><a href="#2-2-1-开启多进程模式" class="headerlink" title="2.2.1 开启多进程模式"></a>2.2.1 开启多进程模式</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.CustomView&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.ThirdActivity&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:process</span>=<span class="string">&quot;com.example.customview&quot;</span>/&gt;</span></span><br><span class="line">       </span><br><span class="line">       <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.SecondActivity&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:process</span>=<span class="string">&quot;:remote&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">               <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>查看进程名：adb shell ps或adb shell ps | grep 包名</p>
<blockquote>
<p>android:process=”:remote”与android:process=com.ryg.chapter_2.remote”区别？</p>
<ul>
<li>“:” : 指要在当前的进程名前面附加上当前的包名，属于当前应用的私有进程，其他组件不可以和它跑在同一个进程中。</li>
<li>android:process=com.ryg.chapter_2.remote”：完整的命名方式，不会附加包名信息。全局进程，其他应用通过shareUID方法可以和它跑在同一个进程中【需要两个应用有相同的ShareUID并且签名相同，之后可以互相访问对方的私有数据。】。</li>
</ul>
</blockquote>
<h5 id="2-2-2-多进程模式的运行机制"><a href="#2-2-2-多进程模式的运行机制" class="headerlink" title="2.2.2 多进程模式的运行机制"></a>2.2.2 多进程模式的运行机制</h5><blockquote>
<p>Android为每一个应用分配一个独立的虚拟机或者每个进程都分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间。</p>
</blockquote>
<p>多进程需要考虑的问题</p>
<ul>
<li>静态成员和单例模式完全失效</li>
<li>线程同步机制完全失效</li>
<li>SharedPreferences的可靠性下降</li>
<li>Application会多次创建</li>
</ul>
<p>实现跨进程通信的方法：</p>
<ul>
<li>通过Intent来传递数据</li>
<li>共享文件</li>
<li>SharePreferences</li>
<li>基于Binder的Messenger和AIDL</li>
<li>Socket</li>
</ul>
<h4 id="2-3-IPC基础概念介绍"><a href="#2-3-IPC基础概念介绍" class="headerlink" title="2.3 IPC基础概念介绍"></a>2.3 IPC基础概念介绍</h4><blockquote>
<p>Serializable接口、Parcelable接口以及Binder</p>
<p>Serializable接口、Parcelable接口可以完成对象的序列化过程【Intent和Binder传输数据、对象持久化到存储设备、通过网络传输到其他客户端】</p>
</blockquote>
<h6 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h6><p>序列化对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.ipc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5641651313215615L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> userId;</span><br><span class="line">    <span class="keyword">public</span> String userName;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isMale;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> userId, String userName, <span class="keyword">boolean</span> isMale)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        <span class="keyword">this</span>.isMale = isMale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getSerialVersionUID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serialVersionUID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUserId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserId</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isMale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMale</span><span class="params">(<span class="keyword">boolean</span> male)</span> </span>&#123;</span><br><span class="line">        isMale = male;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;userId=&quot;</span> + userId +</span><br><span class="line">                <span class="string">&quot;, userName=&#x27;&quot;</span> + userName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, isMale=&quot;</span> + isMale +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>序列化与反序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序列化</span></span><br><span class="line">User user = <span class="keyword">new</span> User(<span class="number">0</span>,<span class="string">&quot;jake&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">Log.i(TAG, <span class="string">&quot;onCreate: user:&quot;</span>+user.hashCode());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;cache.txt&quot;</span>));</span><br><span class="line">    out.writeObject(user);</span><br><span class="line">    out.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;cache.txt&quot;</span>));</span><br><span class="line">    User newUser = (User) in.readObject();</span><br><span class="line">    Log.i(TAG, <span class="string">&quot;onCreate: usernew :&quot;</span>+newUser.hashCode());</span><br><span class="line">    in.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>恢复后的内容一样，不是同一个对象</p>
<p>serialVersionUID的详细工作机制是这样的：序列化的时候系统会把当前类的serialVersionUID写入序列化的文件中（也可能是其他中介），当反序列化的时候系统会去检测文件中的serialVersionUID，看它是否和当前类的serialVersionUID一致，如果一致就说明序列化的类的版本和当前类的版本是相同的，这个时候可以成功反序列化；否则就说明当前类和序列化的类相比发生了某些变换，比如成员变量的数量、类型可能发生了改变，这个时候是无法正常反序列化的。</p>
<blockquote>
<ul>
<li><p>静态成员变量属于类不属于对象，不会参与序列化过程</p>
</li>
<li><p>其次用transient关键词标记的成员变量不参与序列化过程</p>
</li>
</ul>
</blockquote>
<h6 id="Parcelable接口"><a href="#Parcelable接口" class="headerlink" title="Parcelable接口"></a>Parcelable接口</h6><p>可以在Binder中传输</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.ipc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Parcel;</span><br><span class="line"><span class="keyword">import</span> android.os.Parcelable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserR</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> userId;</span><br><span class="line">    <span class="keyword">public</span> String userName;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isMale;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Book book;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">UserR</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        userId = in.readInt();</span><br><span class="line">        userName = in.readString();</span><br><span class="line">        isMale = in.readInt() == <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//book是另一个可序列对象，所以它的反序列化过程需要传递当前线程的上下文类加载器，否则会报无法找到类的错误。</span></span><br><span class="line">        book = in.readParcelable(Thread.currentThread().getContextClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserR</span><span class="params">(<span class="keyword">int</span> userId, String userName, <span class="keyword">boolean</span> isMale)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        <span class="keyword">this</span>.isMale = isMale;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//内容描述功能</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//仅当当前对象存在文件描述符时，才返回1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//序列化</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel out, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        out.writeInt(userId);</span><br><span class="line">        out.writeString(userName);</span><br><span class="line">        out.writeInt(isMale ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        out.writeParcelable(book, <span class="number">0</span>);        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反序列化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;UserR&gt; CREATOR = <span class="keyword">new</span> Creator&lt;UserR&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UserR <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> UserR(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> UserR[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> UserR[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
<th>标记位</th>
</tr>
</thead>
<tbody><tr>
<td>createFromParcel（Parcel in）</td>
<td>从序列化后的对象中创建原始对象</td>
<td></td>
</tr>
<tr>
<td>newAray（int size）</td>
<td>创建指定长度的原始对象数组</td>
<td></td>
</tr>
<tr>
<td></td>
<td>从序列化后的对象中创建原始对象</td>
<td></td>
</tr>
<tr>
<td>User（Parcel in） write ToParcel（Parcel out，int flags）</td>
<td>将当前对象写入序列化结构中，其中flags标识有两种值：0或者1（参见右侧标记位）。为1时标识当前对象需要作为返回值返回，不能立即释放资源，几乎所有情况都为0</td>
<td>PARCELABLE_ WRITE_RETURN_ VALUE</td>
</tr>
<tr>
<td>describeContents</td>
<td>返回当前对象的内容描述。如果含有文件描述符，返回1（参见右侧标记位），否则返回0.几乎所有情况都返回0</td>
<td>CONTENTS FILE DESCRIPTOR</td>
</tr>
</tbody></table>
<p>已经实现了序列化的类：Intent、Bundle、Bitmap、List、Map</p>
<p>既然Parcelable和Serializable都能实现序列化并且都可用于Intent间的数据传递，那么二者该如何选取呢？<code>Serializable</code>是Java中的序列化接口，其使用起来<code>简单但是开销很大</code>，序列化和反序列化过程需要大量I/O操作。</p>
<p>而<code>Parcelable</code>是Android中的序列化方式，因此更适合用在Android平台上，它的缺点就是使用起来稍微麻烦点，但是它的<code>效率很高</code>，这是Android推荐的序列化方式，因此我们要首选Parcelable。<strong>Parcelable主要用在内存序列化上，通过Parcelable将对象序列化到存储设备中或者将对象序列化后通过网络传输也都是可以的，但是这个过程会稍显复杂，因此在这两种情况下建议大家使用Serializable。</strong></p>
<h6 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h6><blockquote>
<p>直观来说，Binder是Android中的一个类，它实现了IBinder接口。</p>
<p>从IPC角度来说，Binder是Android中的一种跨进程通信方式，Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在Linux中没有；</p>
<p>从Android Framework角度来说，Binder是ServiceManager连接各种Manager（ActivityManager、WindowManager，等等）和相应ManagerService的桥梁；</p>
<p>从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。</p>
</blockquote>
<p>Book.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.chapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Parcel;</span><br><span class="line"><span class="keyword">import</span> android.os.Parcelable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Books</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> bookId;</span><br><span class="line">    <span class="keyword">public</span> String bookName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Books</span><span class="params">(<span class="keyword">int</span> bookId, String bookName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookId = bookId;</span><br><span class="line">        <span class="keyword">this</span>.bookName = bookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Books</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        bookId = in.readInt();</span><br><span class="line">        bookName = in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;Books&gt; CREATOR = <span class="keyword">new</span> Creator&lt;Books&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Books <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Books(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Books[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Books[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        dest.writeInt(bookId);</span><br><span class="line">        dest.writeString(bookName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Book.aidl</p>
<blockquote>
<p>Book类在AIDL中的声明。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IBookManager.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.example.chapter;</span><br><span class="line"></span><br><span class="line">parcelable Books;</span><br></pre></td></tr></table></figure>

<p>IBookManager.aidl</p>
<blockquote>
<p>定义的接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IBookManager.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.example.chapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.chapter.Books;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">     * and return values in AIDL.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//从远程服务端获取图书列表</span></span><br><span class="line">     <span class="function">List&lt;Books&gt; <span class="title">getBookList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//往图书列表添加一本书</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(in Books book)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IBookManager.java</p>
<p>编译之后，系统生成的binder类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This file is auto-generated.  DO NOT MODIFY.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.example.chapter;</span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="comment">/** Default implementation for IBookManager. */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Default</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">chapter</span>.<span class="title">IBookManager</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">         * and return values in AIDL.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> java.util.List&lt;com.example.chapter.Books&gt; getBookList() <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(com.example.chapter.Books book)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** Local-side IPC implementation stub class. */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">chapter</span>.<span class="title">IBookManager</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">&quot;com.example.chapter.IBookManager&quot;</span>;</span><br><span class="line">    <span class="comment">/** Construct the stub at attach it to the interface. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cast an IBinder object into an com.example.chapter.IBookManager interface,</span></span><br><span class="line"><span class="comment">     * generating a proxy if needed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> com.example.chapter.<span class="function">IBookManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> ((obj==<span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">      <span class="keyword">if</span> (((iin!=<span class="keyword">null</span>)&amp;&amp;(iin <span class="keyword">instanceof</span> com.example.chapter.IBookManager))) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((com.example.chapter.IBookManager)iin);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> com.example.chapter.IBookManager.Stub.Proxy(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      java.lang.String descriptor = DESCRIPTOR;</span><br><span class="line">      <span class="keyword">switch</span> (code)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> INTERFACE_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">          reply.writeString(descriptor);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_getBookList:</span><br><span class="line">        &#123;</span><br><span class="line">          data.enforceInterface(descriptor);</span><br><span class="line">          java.util.List&lt;com.example.chapter.Books&gt; _result = <span class="keyword">this</span>.getBookList();</span><br><span class="line">          reply.writeNoException();</span><br><span class="line">          reply.writeTypedList(_result);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> TRANSACTION_addBook:</span><br><span class="line">        &#123;</span><br><span class="line">          data.enforceInterface(descriptor);</span><br><span class="line">          com.example.chapter.Books _arg0;</span><br><span class="line">          <span class="keyword">if</span> ((<span class="number">0</span>!=data.readInt())) &#123;</span><br><span class="line">            _arg0 = com.example.chapter.Books.CREATOR.createFromParcel(data);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            _arg0 = <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">this</span>.addBook(_arg0);</span><br><span class="line">          reply.writeNoException();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">example</span>.<span class="title">chapter</span>.<span class="title">IBookManager</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line">      Proxy(android.os.IBinder remote)</span><br><span class="line">      &#123;</span><br><span class="line">        mRemote = remote;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mRemote;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">           * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">           * and return values in AIDL.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> java.util.List&lt;com.example.chapter.Books&gt; getBookList() <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">      &#123;</span><br><span class="line">        android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">        android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">        java.util.List&lt;com.example.chapter.Books&gt; _result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">          <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> getDefaultImpl().getBookList();</span><br><span class="line">          &#125;</span><br><span class="line">          _reply.readException();</span><br><span class="line">          _result = _reply.createTypedArrayList(com.example.chapter.Books.CREATOR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">          _reply.recycle();</span><br><span class="line">          _data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(com.example.chapter.Books book)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">        android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">          <span class="keyword">if</span> ((book!=<span class="keyword">null</span>)) &#123;</span><br><span class="line">            _data.writeInt(<span class="number">1</span>);</span><br><span class="line">            book.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            _data.writeInt(<span class="number">0</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            getDefaultImpl().addBook(book);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          _reply.readException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">          _reply.recycle();</span><br><span class="line">          _data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> com.example.chapter.IBookManager sDefaultImpl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_getBookList = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_addBook = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setDefaultImpl</span><span class="params">(com.example.chapter.IBookManager impl)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Only one user of this interface can use this function</span></span><br><span class="line">      <span class="comment">// at a time. This is a heuristic to detect if two different</span></span><br><span class="line">      <span class="comment">// users in the same process use this function.</span></span><br><span class="line">      <span class="keyword">if</span> (Stub.Proxy.sDefaultImpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;setDefaultImpl() called twice&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Stub.Proxy.sDefaultImpl = impl;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> com.example.chapter.<span class="function">IBookManager <span class="title">getDefaultImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Stub.Proxy.sDefaultImpl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">       * and return values in AIDL.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">  <span class="keyword">public</span> java.util.List&lt;com.example.chapter.Books&gt; getBookList() <span class="keyword">throws</span> android.os.RemoteException;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(com.example.chapter.Books book)</span> <span class="keyword">throws</span> android.os.RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明了两个方法getBookList和addBook，在IBookManager.aidl中所声明的方法，同时还声明了两个整型的id分别用于标识这两个方法，这两个id用于标识在transact过程中客户端所请求的到底是哪个方法。</p>
<p>接着，它声明了一个内部类Stub，这个Stub就是一个Binder类，当客户端和服务端都位于同一个进程时，方法调用不会走跨进程的transact过程，而当两者位于不同进程时，方法调用需要走transact过程，这个逻辑由Stub的内部代理类Proxy来完成。</p>
<p>IBookManager接口的核心实现就是它的内部类Stub和Stub的内部代理类Proxy</p>
<ul>
<li><p>DESCRIPTOR:Binder的唯一标识，一般用当前Bindre的类名表示。</p>
</li>
<li><p>asInterface(android.os.IBinder obj)：用于将服务端的Binder对象转换为客户端所需的AIDL接口类型的对象。如果客户端和服务端位于同一进程，此方法返回的就是服务器的stub对象本身，否则返回系统封装后的Stub.proxy对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> com.example.chapter.<span class="function">IBookManager <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((obj==<span class="keyword">null</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">  <span class="keyword">if</span> (((iin!=<span class="keyword">null</span>)&amp;&amp;(iin <span class="keyword">instanceof</span> com.example.chapter.IBookManager))) &#123;</span><br><span class="line">    <span class="keyword">return</span> ((com.example.chapter.IBookManager)iin);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> com.example.chapter.IBookManager.Stub.Proxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>asBinder：用于返回当前对 Binder对象</p>
</li>
<li><p>onTransact：这个方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。该方法的原型为public Boolean on Transact（int code，android.os.Parcel data，android.os.Parcel reply，int flags）。服务端通过code可以确定客户端所请求的目标方法是什么，接着从data中取出目标方法所需的参数（如果目标方法有参数的话），然后执行目标方法。当目标方法执行完毕后，就向reply中写入返回值（如果目标方法有返回值的话），onTransact方法的执行过程就是这样的。需要注意的是，如果此方法返回false，那么客户端的请求会失败，因此我们可以利用这个特性来做权限验证，毕竟我们也不希望随便一个进程都能远程调用我们的服务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">  java.lang.String descriptor = DESCRIPTOR;</span><br><span class="line">  <span class="keyword">switch</span> (code)&#123;</span><br><span class="line">    <span class="keyword">case</span> INTERFACE_TRANSACTION:</span><br><span class="line">          &#123;</span><br><span class="line">        	reply.writeString(descriptor);</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">    <span class="keyword">case</span> TRANSACTION_getBookList: </span><br><span class="line">          &#123;</span><br><span class="line">        	data.enforceInterface(descriptor);</span><br><span class="line">      		java.util.List&lt;com.example.chapter.Books&gt; _result = <span class="keyword">this</span>.getBookList();</span><br><span class="line">      		reply.writeNoException();</span><br><span class="line">      		reply.writeTypedList(_result);</span><br><span class="line">      		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">    <span class="keyword">case</span> TRANSACTION_addBook:</span><br><span class="line">    	&#123;</span><br><span class="line">      		data.enforceInterface(descriptor);</span><br><span class="line">      		com.example.chapter.Books _arg0;</span><br><span class="line">      		<span class="keyword">if</span> ((<span class="number">0</span>!=data.readInt())) &#123;</span><br><span class="line">        		_arg0 = com.example.chapter.Books.CREATOR.createFromParcel(data);</span><br><span class="line">      		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       			_arg0 = <span class="keyword">null</span>;</span><br><span class="line">      		&#125;</span><br><span class="line">      		<span class="keyword">this</span>.addBook(_arg0);</span><br><span class="line">      		reply.writeNoException();</span><br><span class="line">      		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    	&#123;</span><br><span class="line">      		<span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">    	&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Proxy#getBookList：这个方法运行在客户端，当客户端远程调用此方法时，它的内部实现是这样的：首先创建该方法所需要的输入型Parcel对象data、输出型Parcel对象reply和返回值对象List；</p>
<p>然后把该方法的参数信息写入data中（如果有参数的话）；接着调用transact 万法来发起RPC（远程过程调用）请求，同时当前线程挂起；然后服务端的onTransact方法会被调用，直到RPC过程返回后，当前线程继续执行，并从 _ reply中取出RPC过程的返回结果；最后返回_reply中的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> java.util.List&lt;com.example.chapter.Books&gt; getBookList() <span class="keyword">throws</span> android.os.RemoteException &#123;</span><br><span class="line">  android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">  android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">  java.util.List&lt;com.example.chapter.Books&gt; _result;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">    <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> getDefaultImpl().getBookList();</span><br><span class="line">    &#125;</span><br><span class="line">    _reply.readException();</span><br><span class="line">    _result = _reply.createTypedArrayList(com.example.chapter.Books.CREATOR);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    _reply.recycle();</span><br><span class="line">    _data.recycle();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Proxy#addBook</p>
<p>这个方法运行在客户端，它的执行过程和getBookList是一样的，addBook没有返回值，所以它不需要从_reply中取出返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(com.example.chapter.Books book)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">  android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">  android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">    <span class="keyword">if</span> ((book!=<span class="keyword">null</span>)) &#123;</span><br><span class="line">      _data.writeInt(<span class="number">1</span>);</span><br><span class="line">      book.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _data.writeInt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> _status = mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!_status &amp;&amp; getDefaultImpl() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      getDefaultImpl().addBook(book);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _reply.readException();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    _reply.recycle();</span><br><span class="line">    _data.recycle();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/08/12/JZx6tIbrmpGYhXv.png" alt="Binder的工作机制"></p>
</li>
</ul>
<h4 id="2-4-Android中IPC方式"><a href="#2-4-Android中IPC方式" class="headerlink" title="2.4 Android中IPC方式"></a>2.4 Android中IPC方式</h4><p>跨进程通信方式</p>
<ul>
<li>Intent中附加extras俩传递信息</li>
<li>通过共享文件的方式共享数据</li>
<li>Binder是跨进程通信</li>
<li>ContentProvier</li>
<li>Socket</li>
</ul>
<h6 id="2-4-1-Bundle"><a href="#2-4-1-Bundle" class="headerlink" title="2.4.1 Bundle"></a>2.4.1 Bundle</h6><p>Activity、Service、Receiver都支持intent中传递Bundle数据，由于Bundle实现了Parcelable接口，可以方便在不同的进程传输。（传输的数据必须能够被序列化，比如基本类型、实现了Parcellable接口的对象、实现了Serializable接口的对象以及一些Android支持的特殊对象）</p>
<h6 id="2-4-2-使用文件共享"><a href="#2-4-2-使用文件共享" class="headerlink" title="2.4.2 使用文件共享"></a>2.4.2 使用文件共享</h6><p>共享文件也是一种不错的进程间通信方式，两个进程通过读/写同一个文件来交换数据，比如A进程把数据写入文件，B进程通过读取这个文件来获取数据。</p>
<h6 id="2-4-3-使用Messenger"><a href="#2-4-3-使用Messenger" class="headerlink" title="2.4.3 使用Messenger"></a>2.4.3 使用Messenger</h6><ul>
<li><p>服务端进程</p>
<p>首先，我们需要在服务端创建一个Service来处理客户端的连接请求，同时创建一个Handler并通过它来创建一个Messenger对象，然后在Service的onBind中返回这个Messenger对象底层的Binder即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.mydemo813;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Service;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.Looper;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"><span class="keyword">import</span> android.os.Messenger;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.annotation.NonNull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessengerService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;MessengerService&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MSG_FROM_CLIENT = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> MSG_FROM_CLIENT:</span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;handleMessage: receive msg from Client:&quot;</span>+msg.getData().getString(<span class="string">&quot;msg&quot;</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Messenger mMessenger = <span class="keyword">new</span> Messenger(<span class="keyword">new</span> MessengerHandler());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMessenger.getBinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.MessengerService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">&quot;:MessengerService&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>客户端进程</p>
<p>客户端进程中，首先要绑定服务端的Service，绑定成功后用服务端返回的IBinder对象创建一个Messenger，通过这个Messenger就可以向服务端发送消息了，发消息类型为Message对象。如果需要服务端能够回应客户端，就和服务端一样，我们还需要创建一个Handler并创建一个新的Messenger，并把这个Messenger 对象通过Message的 replyTo参数传递给服务端，服务端通过这个replyTo参数就可以回应客户端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.mydemo813;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.ComponentName;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.content.ServiceConnection;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"><span class="keyword">import</span> android.os.Messenger;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.example.mydemo813.MessengerService.MSG_FROM_CLIENT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;MessengerActivity&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Messenger mService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            mService = <span class="keyword">new</span> Messenger(service);</span><br><span class="line">            Message msg = Message.obtain(<span class="keyword">null</span>,MSG_FROM_CLIENT);</span><br><span class="line">            Bundle data = <span class="keyword">new</span> Bundle();</span><br><span class="line">            data.putString(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;hello,this is client&quot;</span>);</span><br><span class="line">            msg.setData(data);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mService.send(msg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,MessengerService.class);</span><br><span class="line">        bindService(intent,mConnection,BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        unbindService(mConnection);</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://s2.loli.net/2022/08/13/RC8abYmzogX6iuj.png" alt="Messenger工作原理"></p>
<h6 id="2-4-4-AIDL"><a href="#2-4-4-AIDL" class="headerlink" title="2.4.4 AIDL"></a>2.4.4 AIDL</h6><ul>
<li><p><strong><code>服务端</code></strong></p>
<p>服务端首先要创建一个Service用来监听客户端的连接请求，然后创建一个AIDL文件，将暴露给客户端的接口在这个AIDL文件中声明，最后在Service中实现这个AIDL接口即可。</p>
</li>
<li><p><strong><code>客户端</code></strong></p>
<p>客户端所要做事情就稍微简单一些，首先需要绑定服务端的Service，绑定成功后，将服务端返回的Binder对象转成AIDL接口所属的类型，接着就可以调用AIDL中的方法了。</p>
</li>
<li><p><strong><code>AIDL接口创建</code></strong></p>
<p>首先看AIDL接口的创建，如下所示，我们创建了一个后缀为AIDL的文件，在里面声明了一个接口和两个接口方法。</p>
</li>
</ul>
<p>AIDL文件支持哪些数据类型？</p>
<ul>
<li>基本数据类型（int、long、char、boolean、double等）</li>
<li>String 和CharSequence</li>
<li>List：只支持ArrayList，里面的每个元素都必须能够被AIDL支持；</li>
<li>Mao：只迟迟HashMap，里面的每个元素都必须被AIDL支持，包括key和value</li>
<li>Parcelable：所有实现了Parcelable接口的对象</li>
<li>AIDL：所有的AIDL接口本身也可以在AIDL文件中使用。</li>
</ul>
<blockquote>
<p>自定义的Parcelable对象和AIDL对象必须要显式的import进来</p>
<p>如果AIDL文件中用到了自定义的Parcelable对象，必须新建一个和它同名的AIDL文件，并且声明它为Parcelable类型。</p>
<p>除了基本数据类型，其他类型的参数必须标上方向：in（输入型参数）、out（输出型参数）或inout（输入输出型参数）。</p>
<p>接口中只支持方法，不支持声明静态变量。</p>
<p>AIDL的包结构在服务端和客户端要保持一致，因为客户端需要反序列化服务端中和AIDL接口相关的所有的类，如果类的完整路径不一致，无法成功反序列化，程序无法正常运行。</p>
</blockquote>
<ul>
<li><strong><code>远程服务端的实现</code></strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.BookManagerService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">&quot;:remote&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.mydemo813;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Service;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Binder;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookManagerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;BMS&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> CopyOnWriteArrayList&lt;Book&gt; mBookList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;Book&gt;();</span><br><span class="line">    <span class="keyword">private</span> Binder mBinder = <span class="keyword">new</span> IBookManager.Stub() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mBookList;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            mBookList.add(book);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat, <span class="keyword">double</span> aDouble, String aString)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookManagerService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        mBookList.add(<span class="keyword">new</span> Book(<span class="number">1</span>,<span class="string">&quot;Android&quot;</span>));</span><br><span class="line">        mBookList.add(<span class="keyword">new</span> Book(<span class="number">2</span>,<span class="string">&quot;IOS&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>客户端实现</code></strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.mydemo813;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.ComponentName;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.content.ServiceConnection;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookManagerActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;BookManagerActivity&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            IBookManager bookManager = IBookManager.Stub.asInterface(service);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                List&lt;Book&gt; list = bookManager.getBookList();</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;onServiceConnected: query book list , list type : &quot;</span>+list.getClass().getCanonicalName());</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;onServiceConnected: query book list: &quot;</span>+ list.toString());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_book_manager);</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,BookManagerService.class);</span><br><span class="line">        bindService(intent,mConnection,BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        unbindService(mConnection);</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加书籍方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">    IBookManager bookManager = IBookManager.Stub.asInterface(service);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mRemoteBookManager = bookManager;</span><br><span class="line"></span><br><span class="line">        List&lt;Book&gt; list = bookManager.getBookList();</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onServiceConnected: query book list , list type : &quot;</span>+list.getClass().getCanonicalName());</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onServiceConnected: query book list: &quot;</span>+ list.toString());</span><br><span class="line">        Book newBook = <span class="keyword">new</span> Book(<span class="number">3</span>,<span class="string">&quot;Android开发艺术探索&quot;</span>);</span><br><span class="line">        bookManager.addBook(newBook);</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onServiceConnected: add Book:&quot;</span>+newBook);</span><br><span class="line">        List&lt;Book&gt; newList = bookManager.getBookList();</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onServiceConnected: query book list: &quot;</span>+newList.toString());</span><br><span class="line">        bookManager.registerListener(mOnNewBookArrivedListener);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当有新内容时，服务端主动发起通知。新增AIDL接口，客户端需要实现这个接口并向图书馆申请新书的提醒功能呢，也可以取消这个提醒。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IOnNewBookArrivedListener.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.example.mydemo813;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.mydemo813.Book;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOnNewBookArrivedListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">     * and return values in AIDL.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onNewBookArrived</span><span class="params">(in Book newBook)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">double</span> aDouble, String aString)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IBookManager.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.example.mydemo813;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"><span class="keyword">import</span> com.example.mydemo813.Book;</span><br><span class="line"><span class="keyword">import</span> com.example.mydemo813.IOnNewBookArrivedListener;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Demonstrates some basic types that you can use as parameters</span></span><br><span class="line"><span class="comment">     * and return values in AIDL.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(in Book book)</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//观察是否有新的书籍，通知所有的用户</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerListener</span><span class="params">(IOnNewBookArrivedListener listener)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unregisterListener</span><span class="params">(IOnNewBookArrivedListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">double</span> aDouble, String aString)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>//服务端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.mydemo813;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Service;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.Binder;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookManagerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;BMS&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> AtomicBoolean mIsServiceDestroyed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CopyOnWriteArrayList&lt;Book&gt; mBookList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;Book&gt;();</span><br><span class="line">    <span class="keyword">private</span> CopyOnWriteArrayList&lt;IOnNewBookArrivedListener&gt; mListenerList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Binder mBinder = <span class="keyword">new</span> IBookManager.Stub() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mBookList;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            mBookList.add(book);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerListener</span><span class="params">(IOnNewBookArrivedListener listener)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">             <span class="keyword">if</span> (!mListenerList.contains(listener)) &#123;</span><br><span class="line">                 mListenerList.add(listener);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 Log.i(TAG, <span class="string">&quot;registerListener: already exists.&quot;</span>);</span><br><span class="line">             &#125;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;registerListener: size:&quot;</span>+mListenerList.size());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterListener</span><span class="params">(IOnNewBookArrivedListener listener)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (mListenerList.contains(listener)) &#123;</span><br><span class="line">                mListenerList.remove(listener);</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;unregisterListener: listener succeed.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;unregisterListener: not found ,can not unregister.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;unregisterListener: current size:&quot;</span>+mListenerList.size());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat, <span class="keyword">double</span> aDouble, String aString)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookManagerService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        mBookList.add(<span class="keyword">new</span> Book(<span class="number">1</span>,<span class="string">&quot;Android&quot;</span>));</span><br><span class="line">        mBookList.add(<span class="keyword">new</span> Book(<span class="number">2</span>,<span class="string">&quot;IOS&quot;</span>));</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ServiceWorker()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onNewBookArrived</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        mBookList.add(book);</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onNewBookArrived: notify listeners:&quot;</span>+mListenerList.size());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mListenerList.size(); i++) &#123;</span><br><span class="line">            IOnNewBookArrivedListener listener = mListenerList.get(i);</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;onNewBookArrived: notify listener :&quot;</span>+listener);</span><br><span class="line">            listener.onNewBookArrived(book);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//do background processing her。。。</span></span><br><span class="line">            <span class="keyword">while</span> (!mIsServiceDestroyed.get()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> bookId = mBookList.size()+<span class="number">1</span>;</span><br><span class="line">                Book newBook = <span class="keyword">new</span> Book(bookId,<span class="string">&quot;new book#&quot;</span>+bookId);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    onNewBookArrived(newBook);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mIsServiceDestroyed.set(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端：主要有两方面：首先客户端要注册IOnNewBookArrivedListener到远程服务端，这样当有新书时服务端才能通知当前客户端，同时我们要在Activity退出时解除这个注册；另一方面，当有新书时，服务端会回调客户端的IOnNewBookArivedListener对象中的onNewBookArrived方法，但是这个方法是在客户端的Binder线程池中执行的，因此，为了便于进行UI操作，我们需要有一个Handler可以将其切换到客户端的主线程中去执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.mydemo813;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.annotation.NonNull;</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.ComponentName;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.content.ServiceConnection;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"><span class="keyword">import</span> android.os.RemoteException;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookManagerActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;BookManagerActivity&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_NEW_BOOK_ARRIVED = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> IBookManager mRemoteBookManager;</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> MESSAGE_NEW_BOOK_ARRIVED:</span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;handleMessage: receive new book:&quot;</span>+msg.obj);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            IBookManager bookManager = IBookManager.Stub.asInterface(service);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mRemoteBookManager = bookManager;</span><br><span class="line"></span><br><span class="line">                List&lt;Book&gt; list = bookManager.getBookList();</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;onServiceConnected: query book list , list type : &quot;</span>+list.getClass().getCanonicalName());</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;onServiceConnected: query book list: &quot;</span>+ list.toString());</span><br><span class="line">                Book newBook = <span class="keyword">new</span> Book(<span class="number">3</span>,<span class="string">&quot;Android开发艺术探索&quot;</span>);</span><br><span class="line">                bookManager.addBook(newBook);</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;onServiceConnected: add Book:&quot;</span>+newBook);</span><br><span class="line">                List&lt;Book&gt; newList = bookManager.getBookList();</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;onServiceConnected: query book list: &quot;</span>+newList.toString());</span><br><span class="line">                bookManager.registerListener(mOnNewBookArrivedListener);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">            mRemoteBookManager = <span class="keyword">null</span>;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;onServiceDisconnected: binder died&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IOnNewBookArrivedListener mOnNewBookArrivedListener = <span class="keyword">new</span> IOnNewBookArrivedListener.Stub() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNewBookArrived</span><span class="params">(Book newBook)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            mHandler.obtainMessage(MESSAGE_NEW_BOOK_ARRIVED,newBook).sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean, <span class="keyword">float</span> aFloat, <span class="keyword">double</span> aDouble, String aString)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_book_manager);</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,BookManagerService.class);</span><br><span class="line">        bindService(intent,mConnection,BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mRemoteBookManager !=<span class="keyword">null</span>&amp;&amp;mRemoteBookManager.asBinder().isBinderAlive())&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;onDestroy: unregister listener:&quot;</span>+mOnNewBookArrivedListener);</span><br><span class="line">                mRemoteBookManager.unregisterListener(mOnNewBookArrivedListener);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        unbindService(mConnection);</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h6><blockquote>
<p>创建一个自定义的ContentProvider很简单，只需要继承ContentProvider类并实现六个抽象方法即可：onCreate、query、update、insert、delete和getType。</p>
<ul>
<li>onCreate代表ContentProvider的创建，一般来说我们需要做一些初始化工作；</li>
<li>getType用来返回一个Uri请求所对应的MIME类型（媒体类型），比如图片、视频等，这个媒体类型还是有点复杂的，如果我们的应用不关注这个选项，可以直接在这个方法中返回null或者“*/*”；</li>
<li>剩下的四个方法对应于CRUD操作，即实现对数据表的增删改查功能。根据Binder的工作原理，\这六个方法均运行在ContentProvider的进程中，除了onCreate由系统回调并运行在主线程里，其他五个方法均由外界回调并运行在Binder线程池中。</li>
</ul>
</blockquote>
<p>ContentProvider主要以表格的形式来组织数据，并且可以包含多个表，对于每个表格来说，它们都具有行和列的层次性，行往往对应一条记录，而列对应一条记录中的一个字段，这点和数据库很类似。除了表格的形式，ContentProvider还支持文件数据，比如图片、视频等。文件数据和表格数据的结构不同，因此处理这类数据时可以在ContentProvider中返回文件的句柄给外界从而让文件来访问ContentProvider中的文件信息，虽然ContentProvider的底层数据看起来很像一个SQLite数据库，但是ContentProvider对底层的数据存储方式没有任何要求，我们既可以使用SQLite数据库，也可以使用普通的文件，甚至可以采用内存中的一个对象来进行数据的存储。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.conprovider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.ContentProvider;</span><br><span class="line"><span class="keyword">import</span> android.content.ContentValues;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.UriMatcher;</span><br><span class="line"><span class="keyword">import</span> android.database.Cursor;</span><br><span class="line"><span class="keyword">import</span> android.database.sqlite.SQLiteDatabase;</span><br><span class="line"><span class="keyword">import</span> android.net.Uri;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;BookProvider&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTHORITY = <span class="string">&quot;com.example.conprovider.book.provider&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri BOOK_CONTENT_URI = Uri.parse(<span class="string">&quot;content://&quot;</span>+AUTHORITY+<span class="string">&quot;/book&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri USER_CONTENT_URI = Uri.parse(<span class="string">&quot;content://&quot;</span>+AUTHORITY+<span class="string">&quot;/user&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BOOK_URI_CODE = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> USER_URI_CODE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> UriMatcher sUriMatcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getTableName</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">        String tableName = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (sUriMatcher.match(uri)) &#123;</span><br><span class="line">            <span class="keyword">case</span> BOOK_URI_CODE:</span><br><span class="line">                tableName = DbOpenHelper.Book_TABLE_NAME;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> USER_URI_CODE:</span><br><span class="line">                tableName = DbOpenHelper.USER_TABLE_NAME;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tableName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        sUriMatcher.addURI(AUTHORITY,<span class="string">&quot;book&quot;</span>,BOOK_URI_CODE);</span><br><span class="line">        sUriMatcher.addURI(AUTHORITY,<span class="string">&quot;user&quot;</span>,USER_URI_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> SQLiteDatabase mDd;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;delete: delete&quot;</span>);</span><br><span class="line">        String table = getTableName(uri);</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;unsupported uri:&quot;</span>+uri);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = mDd.delete(table,selection,selectionArgs);</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            getContext().getContentResolver().notifyChange(uri,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Implement this to handle requests for the MIME type of the data</span></span><br><span class="line">        <span class="comment">// at the given URI.</span></span><br><span class="line">        Log.i(TAG, <span class="string">&quot;getType: getType&quot;</span>);</span><br><span class="line">        String tableName = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (sUriMatcher.match(uri)) &#123;</span><br><span class="line">            <span class="keyword">case</span> BOOK_URI_CODE:</span><br><span class="line">                tableName = DbOpenHelper.Book_TABLE_NAME;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> USER_URI_CODE:</span><br><span class="line">                tableName = DbOpenHelper.USER_TABLE_NAME;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tableName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;insert: insert&quot;</span>);</span><br><span class="line">        String table = getTableName(uri);</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;unsupported uri:&quot;</span>+uri);</span><br><span class="line">        &#125;</span><br><span class="line">        mDd.insert(table,<span class="keyword">null</span>,values);</span><br><span class="line">        mContext.getContentResolver().notifyChange(uri,<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;onCreate: current thread:&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        mContext = getContext();</span><br><span class="line">        initProviderData();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initProviderData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mDd = <span class="keyword">new</span> DbOpenHelper(mContext).getWritableDatabase();</span><br><span class="line">        mDd.execSQL(<span class="string">&quot;delete from &quot;</span> + DbOpenHelper.Book_TABLE_NAME);</span><br><span class="line">        mDd.execSQL(<span class="string">&quot;delete from &quot;</span> + DbOpenHelper.USER_TABLE_NAME);</span><br><span class="line">        mDd.execSQL(<span class="string">&quot;insert into book values(3,&#x27;Android&#x27;);&quot;</span>);</span><br><span class="line">        mDd.execSQL(<span class="string">&quot;insert into book values(4,&#x27;IOS&#x27;);&quot;</span>);</span><br><span class="line">        mDd.execSQL(<span class="string">&quot;insert into book values(5,&#x27;Html&#x27;);&quot;</span>);</span><br><span class="line">        mDd.execSQL(<span class="string">&quot;insert into user values(1,&#x27;jake&#x27;,1);&quot;</span>);</span><br><span class="line">        mDd.execSQL(<span class="string">&quot;insert into user values(2,&#x27;tom&#x27;,0);&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection,</span></span></span><br><span class="line"><span class="params"><span class="function">                        String[] selectionArgs, String sortOrder)</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;query: current thread:&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        String table = getTableName(uri);</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unsupported URI&quot;</span>+uri);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mDd.query(table,projection,selection,selectionArgs,<span class="keyword">null</span>,<span class="keyword">null</span>,sortOrder,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection,</span></span></span><br><span class="line"><span class="params"><span class="function">                      String[] selectionArgs)</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;update: update&quot;</span>);</span><br><span class="line">        String table = getTableName(uri);</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unsupported URI&quot;</span>+uri);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> row = mDd.update(table,values,selection,selectionArgs);</span><br><span class="line">        <span class="keyword">if</span> (row &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            getContext().getContentResolver().notifyChange(uri,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> row;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>android:authorities是ContentProvider的唯一标识，通过这个属性外部应用就可以访问我们的BookProvider，因此，android:authorities必须是唯一的，BookProvider运行在独立的进程中并给它添加了权限，这样外界应用如果想访问BookProvider，就必须声明“com.ryg.PROVIDER”这个权限。ContentProvider的权限还可以细分为读权限和写权限，分别对应android:readPermission和android:writePermission属性，如果分别声明了读权限和写权限，那么外界应用也必须依次声明相应的权限才可以进行读/写操作，否则外界应用会异常终止。</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">uses-permission android:name=&quot;com.example.PROVIDER&quot; /&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.MyDemo813&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.conprovider.ProviderActivity&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;com.example.conprovider.BookProvider&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:authorities</span>=<span class="string">&quot;com.example.conprovider.book.provider&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:permission</span>=<span class="string">&quot;com.example.PROVIDER&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:process</span>=<span class="string">&quot;:provider&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.conprovider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.database.sqlite.SQLiteDatabase;</span><br><span class="line"><span class="keyword">import</span> android.database.sqlite.SQLiteOpenHelper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.annotation.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DbOpenHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DB_NAME = <span class="string">&quot;book_provider.db&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String Book_TABLE_NAME = <span class="string">&quot;book&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String USER_TABLE_NAME = <span class="string">&quot;user&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DB_VERSION = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String CREATE_BOOK_TABLE = <span class="string">&quot;Create table if not exists &quot;</span></span><br><span class="line">            + Book_TABLE_NAME + <span class="string">&quot;(_id integer primary key,&quot;</span> + <span class="string">&quot;name text)&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String CREATE_USER_TABLE = <span class="string">&quot;create table if not exists &quot;</span></span><br><span class="line">            + USER_TABLE_NAME + <span class="string">&quot;(_id integer primary key,&quot;</span>+<span class="string">&quot;name text,&quot;</span>+<span class="string">&quot;sex int)&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbOpenHelper</span><span class="params">(<span class="meta">@Nullable</span> Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, DB_NAME, <span class="keyword">null</span>, DB_VERSION);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</span><br><span class="line">        db.execSQL(CREATE_BOOK_TABLE);</span><br><span class="line">        db.execSQL(CREATE_USER_TABLE);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.conprovider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.ContentValues;</span><br><span class="line"><span class="keyword">import</span> android.database.Cursor;</span><br><span class="line"><span class="keyword">import</span> android.net.Uri;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.mydemo813.Book;</span><br><span class="line"><span class="keyword">import</span> com.example.mydemo813.R;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;ProviderActivity&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_provider);</span><br><span class="line">        Uri bookUri = Uri.parse(<span class="string">&quot;content://com.example.conprovider.book.provider/book&quot;</span>);</span><br><span class="line">        ContentValues values = <span class="keyword">new</span> ContentValues();</span><br><span class="line">        values.put(<span class="string">&quot;_id&quot;</span>,<span class="number">6</span>);</span><br><span class="line">        values.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;程序设计的艺术&quot;</span>);</span><br><span class="line">        getContentResolver().insert(bookUri,values);</span><br><span class="line">        Cursor bookCursor = getContentResolver().query(bookUri,<span class="keyword">new</span> String[]&#123;<span class="string">&quot;_id&quot;</span>,<span class="string">&quot;name&quot;</span>&#125;,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (bookCursor.moveToNext()) &#123;</span><br><span class="line">            Book book = <span class="keyword">new</span> Book();</span><br><span class="line">            book.bookId = bookCursor.getInt(<span class="number">0</span>);</span><br><span class="line">            book.bookName = bookCursor.getString(<span class="number">1</span>);</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;onCreate: query book:&quot;</span>+book.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        bookCursor.close();</span><br><span class="line"></span><br><span class="line">        Uri userUri = Uri.parse(<span class="string">&quot;content://com.example.conprovider.book.provider/user&quot;</span>);</span><br><span class="line">        Cursor userCursor = getContentResolver().query(userUri,<span class="keyword">new</span> String[]&#123;<span class="string">&quot;_id&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;sex&quot;</span>&#125;,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (userCursor.moveToNext()) &#123;</span><br><span class="line">            User user = <span class="keyword">new</span> User();</span><br><span class="line">            user.userId = userCursor.getInt(<span class="number">0</span>);</span><br><span class="line">            user.userName = userCursor.getString(<span class="number">1</span>);</span><br><span class="line">            user.isMale = userCursor.getInt(<span class="number">2</span>) ==<span class="number">1</span>;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;onCreate: query book:&quot;</span>+user.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        userCursor.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h6><p>Socket也称为“套接字”，是网络通信中的概念，它分为流式套接字和用户数据报套接字两种，分别对应于网络的传输控制层中的TCP和UDP协议。TCP协议是面向连接的协议，提供稳定的双向通信功能，TCP连接的建立需要经过“三次握手”才能完成，为了提供稳定的数据传输功能，其本身提供了超时重传机制，因此具有很高的稳定性；</p>
<p>而UDP是无连接的，提供不稳定的单向通信功能，当然UDP也可以实现双向通信功能。在性能上，UDP具有更好的效率，其缺点是不保证数据一定能够正确传输，尤其是在网络拥塞的情况下。</p>
<blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--socket 连接权限--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.ACCESS_NETWORK_STATE&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>不能在主线程访问网络。</p>
</blockquote>
<p><strong><code>服务端：</code></strong></p>
<p>先看一下服务端的设计，当Service启动时，会在线程中建立TCP服务，这里监听的是8688端口，然后就可以等待客户端的连接请求。当有客户端连接时，就会生成一个新的Socket，通过每次新创建的Socket就可以分别和不同的客户端通信了。服务端每收到一次客户端的消息就会随机回复一句话给客户端。当客户端断开连接时，服务端这边也会相应的关闭对应Socket并结束通话线程。方法有很多，这里是通过判断服务端输入流的返回值来确定的，当客户端断开连接后，服务端这边的输入流会返回null，这个时候我们就知道客户端退出了。服务端的代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Service;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.os.IBinder;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpServerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;TcpServerService&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mIsServiceDestroyed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> String[] mDefinedMessages = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">            <span class="string">&quot;你好啊，哈哈&quot;</span>,</span><br><span class="line">            <span class="string">&quot;请问你叫什么名字？&quot;</span>,</span><br><span class="line">            <span class="string">&quot;今天天气真不错啊，打晴天&quot;</span>,</span><br><span class="line">            <span class="string">&quot;你知道吗，我可以和多个人同时聊天&quot;</span>,</span><br><span class="line">            <span class="string">&quot;给你讲个笑话把，爱拼才会赢&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TcpServerService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TcpServer()).start();</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mIsServiceDestroyed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TcpServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//监听本地8688端口</span></span><br><span class="line">                serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8688</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;establish tcp server failed,port:8688&quot;</span>);</span><br><span class="line">                Log.e(TAG, <span class="string">&quot;run: establish tcp server failed,port:8688 &quot;</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!mIsServiceDestroyed) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//接收客户端请求</span></span><br><span class="line">                    <span class="keyword">final</span> Socket client = serverSocket.accept();</span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;run: accept&quot;</span>);</span><br><span class="line">                    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                responseClient(client);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;.start();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">responseClient</span><span class="params">(Socket client)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//用于接收客户端消息</span></span><br><span class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream()));</span><br><span class="line">        <span class="comment">//用于向客户端发送消息</span></span><br><span class="line">        PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(client.getOutputStream())),<span class="keyword">true</span>);</span><br><span class="line">        out.println(<span class="string">&quot;欢迎来到聊天室&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDefinedMessages.length; i++) &#123;</span><br><span class="line">            out.println(mDefinedMessages[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!mIsServiceDestroyed) &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;responseClient: start&quot;</span>);</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;responseClient: msg from client:&quot;</span>);</span><br><span class="line">            String str = in.readLine();</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;responseClient: msg from client:&quot;</span>+str);</span><br><span class="line">            <span class="keyword">if</span> (str == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//客户端断开连接</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;responseClient: emd&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> i = <span class="keyword">new</span> Random().nextInt(mDefinedMessages.length);</span><br><span class="line">            String msg = mDefinedMessages[i];</span><br><span class="line">            out.println(msg);</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;responseClient: send:&quot;</span>+msg);</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;responseClient: client quit.&quot;</span>);</span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>客户端</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.annotation.NonNull;</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> androidx.core.app.ActivityCompat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.Manifest;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.content.pm.PackageManager;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"><span class="keyword">import</span> android.os.SystemClock;</span><br><span class="line"><span class="keyword">import</span> android.text.TextUtils;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.EditText;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.mydemo813.R;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClientActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;TCPClientActivity&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_RECEIVE_NEW_MSG = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_SOCKET_CONNECTED = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Button mSendButton;</span><br><span class="line">    <span class="keyword">private</span> TextView mMessageTextView;</span><br><span class="line">    <span class="keyword">private</span> EditText mMessageEdit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PrintWriter mPrintWrite;</span><br><span class="line">    <span class="keyword">private</span> Socket mClientSocket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> MESSAGE_RECEIVE_NEW_MSG:</span><br><span class="line">                    mMessageTextView.setText(mMessageTextView.getText()+(String)msg.obj);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MESSAGE_SOCKET_CONNECTED:</span><br><span class="line">                    mSendButton.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_tcpclient_actiivity);</span><br><span class="line">        mMessageTextView = (TextView)findViewById(R.id.msg);</span><br><span class="line">        mSendButton = (Button)findViewById(R.id.send);</span><br><span class="line">        mSendButton.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        mMessageEdit = (EditText)findViewById(R.id.sendMsg);</span><br><span class="line">        <span class="keyword">if</span> (ActivityCompat.checkSelfPermission(<span class="keyword">this</span>, Manifest.permission.ACCESS_NETWORK_STATE) == PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>,<span class="string">&quot;网络权限赋值&quot;</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ActivityCompat.requestPermissions(<span class="keyword">this</span>,<span class="keyword">new</span> String[]&#123;Manifest.permission.ACCESS_NETWORK_STATE&#125;,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Intent service = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,TcpServerService.class);</span><br><span class="line">        startService(service);</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                connectTCPServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectTCPServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (socket == <span class="keyword">null</span> )&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket = <span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>,<span class="number">8688</span>);</span><br><span class="line">                mClientSocket = socket;</span><br><span class="line">                mPrintWrite = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(socket.getOutputStream())),<span class="keyword">true</span>);</span><br><span class="line">                mHandler.sendEmptyMessage(MESSAGE_SOCKET_CONNECTED);</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;connectTCPServer: connect server success&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                SystemClock.sleep(<span class="number">1000</span>);</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;connectTCPServer: connect tcp server failed ,retry...&quot;</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//接收服务端消息</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">            <span class="keyword">while</span> (!TCPClientActivity.<span class="keyword">this</span>.isFinishing()) &#123;</span><br><span class="line">                String msg = bufferedReader.readLine();</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;connectTCPServer: receive:&quot;</span>+msg);</span><br><span class="line">                <span class="keyword">if</span> (msg!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                    String time = formatDateTime(System.currentTimeMillis());</span><br><span class="line">                    <span class="keyword">final</span> String showedMsg = <span class="string">&quot;server&quot;</span>+time+<span class="string">&quot;:&quot;</span>+msg+<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                    mHandler.obtainMessage(MESSAGE_RECEIVE_NEW_MSG,showedMsg).sendToTarget();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;connectTCPServer: quit...&quot;</span>);</span><br><span class="line">            mPrintWrite.close();</span><br><span class="line">            bufferedReader.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">formatDateTime</span><span class="params">(<span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;HH:mm:ss&quot;</span>).format(<span class="keyword">new</span> Date(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v==mSendButton) &#123;</span><br><span class="line">            <span class="keyword">final</span> String msg = mMessageEdit.getText().toString();</span><br><span class="line">            <span class="keyword">if</span> (!TextUtils.isEmpty(msg)&amp;&amp;mPrintWrite!=<span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//mPrintWrite.println(msg);</span></span><br><span class="line">                mMessageEdit.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                String time = formatDateTime(System.currentTimeMillis());</span><br><span class="line">                <span class="keyword">final</span> String showedMsg = <span class="string">&quot;self&quot;</span>+time+<span class="string">&quot;:&quot;</span>+msg+<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                mMessageTextView.setText(mMessageTextView.getText()+showedMsg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mClientSocket!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mClientSocket.shutdownInput();</span><br><span class="line">                mClientSocket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-5-binder连接池"><a href="#2-5-binder连接池" class="headerlink" title="2.5 binder连接池"></a>2.5 binder连接池</h4><blockquote>
<p>首先创建一个Service和一个AIDL接口，接着创建一个类继承自AIDL接口中的Stub类并实现Stub中的抽象方法，在Service的onBind方法中返回这个类的对象，然后客户端就可以绑定服务端 Service，建立连接后就可以访问远程服务端的方法了。</p>
</blockquote>
<h4 id="2-6-IPC对比"><a href="#2-6-IPC对比" class="headerlink" title="2.6 IPC对比"></a>2.6 IPC对比</h4><table>
<thead>
<tr>
<th>名称</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Bundle</td>
<td>简单易用</td>
<td>只能传输Bundle支持的数据</td>
<td>四大组件间的进程间通信</td>
</tr>
<tr>
<td>文件共享</td>
<td>简单易用</td>
<td>不适合高并发场景，并且无法做到进程间的即时通信</td>
<td>无并发访问情形，交换简单的数据实时性不高的场景</td>
</tr>
<tr>
<td>AIDL</td>
<td>功能强大，支持一对多并发通信，支持实时通信</td>
<td>使用稍复杂，需要处理好线</td>
<td>一对多通信且有RPC需求</td>
</tr>
<tr>
<td>Mescnger</td>
<td>功能一般，支持一对多串行通信，支持实时通信</td>
<td>不能很好处理高并发情形，不支持RPC，数据通过Mesage进行传输，因此只能传输Bundle支持的数据类型</td>
<td>低并发的一对多即时通信，无RPC需来，或者无须要运回结果的RPC需求</td>
</tr>
<tr>
<td>Contenmtprovider</td>
<td>在数据源访问方面功能强大，支持一对多并发数据共享，可通过Call方法扩展其他操作</td>
<td>可以理解为受约束的AIDL，主要提供数据源的CRUD操作</td>
<td>一对多的进程间的数据共享</td>
</tr>
<tr>
<td>socket</td>
<td>功能强大，可以通过网络传输节流，支持一对多并发实时通信</td>
<td>实现细节稍微有点烦琐，不支持直接的RPC</td>
<td>网络数据交换</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 学习记录</title>
    <url>/2022/08/29/Android/Android%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="Android笔记记录"><a href="#Android笔记记录" class="headerlink" title="Android笔记记录"></a>Android笔记记录</h1><hr>
<blockquote>
<p><a href="https://blog.csdn.net/carson_ho/article/details/125581447?spm=1001.2014.3001.5501">Android指南</a></p>
<p><a href="https://carsonho.blog.csdn.net/article/details/122185559">Android语言篇</a></p>
<p><a href="https://carsonho.blog.csdn.net/article/details/122297955">Java语言篇</a></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95.png" alt="面试记录"></p>
<h2 id="通用编程基础："><a href="#通用编程基础：" class="headerlink" title="通用编程基础："></a>通用编程基础：</h2><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><h4 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h4><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><h4 id="1、四大组件"><a href="#1、四大组件" class="headerlink" title="1、四大组件"></a>1、四大组件</h4><table>
<thead>
<tr>
<th>类型</th>
<th>定义</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Activity</td>
<td>即活动，展示型组件</td>
<td>显示界面、与用户进行交互</td>
<td>一个Activity通常是一个界面，是四大组件唯一能被用户感知的<br>·Activity之间通过Intent进行通信<br>·每个活动被实现为一个独立的类，&amp;从活动基类继承过来</td>
</tr>
<tr>
<td>serrvic</td>
<td>即照务，计算型组件</td>
<td>提供长期需要在后台运行的服务</td>
<td>长生命周期，没有用户界面，在后台运行</td>
</tr>
<tr>
<td>BroadcastReceiver</td>
<td>即广播接收器，消息型组件</td>
<td>监听事件&amp;做出响应</td>
<td>最常用场景：不同组件&amp;不同应用间传递消息</td>
</tr>
<tr>
<td>ContentProvider</td>
<td>即内容提供者，数据共享型组件</td>
<td>多个组件&amp;应用间数据共享</td>
<td>共享的数据存储在文件系统中/SQLite数据库</td>
</tr>
</tbody></table>
<h6 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h6><h4 id="2、常见使用"><a href="#2、常见使用" class="headerlink" title="2、常见使用"></a>2、常见使用</h4><h4 id="3、多线程"><a href="#3、多线程" class="headerlink" title="3、多线程"></a>3、多线程</h4><h4 id="4、自定义View"><a href="#4、自定义View" class="headerlink" title="4、自定义View"></a>4、自定义View</h4><h4 id="5、性能优化"><a href="#5、性能优化" class="headerlink" title="5、性能优化"></a>5、性能优化</h4><h5 id="1、如何全面进行性能优化"><a href="#1、如何全面进行性能优化" class="headerlink" title="1、如何全面进行性能优化"></a><a href="">1、如何全面进行性能优化</a></h5><ul>
<li><p>目的：让应用程序APP更快、更稳定&amp;更省</p>
<ul>
<li>更快：应用程序 运行得更加流畅、不卡顿，能快速响应用户操作</li>
<li>更稳定：应用程序 能 稳定运行 &amp; 解决用户需求，在用户使用过程中不出现应用程序崩溃<code>（Crash）</code> 和 无响应<code>（ANR）</code>的问题</li>
<li>更省：节省耗费的资源，包括 内存占有、电池量、网络资源等</li>
</ul>
</li>
<li><p>性能指标：<strong>流畅性、稳定性、资源节省性</strong></p>
</li>
<li><p>优化方向：</p>
<table>
<thead>
<tr>
<th>优化目的</th>
<th>性能指标</th>
<th>优化方向</th>
</tr>
</thead>
<tbody><tr>
<td>更快</td>
<td>流畅性</td>
<td>启动速度<br>·页面显示速度<br>·响应速度</td>
</tr>
<tr>
<td>更稳定</td>
<td>稳定性</td>
<td>避免出现应用崩溃（Crash）<br>避免出现 应用无响应(ANR)</td>
</tr>
<tr>
<td>更省</td>
<td>资源节省性</td>
<td>内存大小<br>·安装包大小<br>·耗电量<br>·网络流量</td>
</tr>
</tbody></table>
</li>
<li><p><strong><code>流畅性</code></strong></p>
<blockquote>
<ul>
<li>优化原因<br>利于 减少使用中的卡顿、响应时间久等问题，给与用户一个操作流畅的体验</li>
<li>优化方向<br>主要针对3个方面优化：启动速度、页面显示速度、响应速度</li>
</ul>
</blockquote>
<ul>
<li><p>启动速度</p>
<p>  采用 <strong>异步加载（多线程）、分步加载、延期加载</strong>的策略，减少启动应用时加载的任务，从而提高启动速度</p>
<table>
<thead>
<tr>
<th>措施</th>
<th>启动慢的原因</th>
<th>具体描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>1、减少OnCreate时间</td>
<td>OnCreate作为启动Activity的第一个方法，若代码逻辑过多，则容易导致慢</td>
<td>- 精简OnCreate<br/>- 将OnCreate的代码部分放在OnResume实现<br/>- 通过多线程细分页面显示View，尽可能减少OnCreate，onResume</td>
<td>-很多操作只需1次初始化，都放在OnResume里每次进入Activity会浪费初始化时间<br/>- 解决方案：<br><code>1.定义一个boolean变量</code><br><code>2.在OnCreate里标识为true</code><br><code>3.在OnResume里判断为true就进行初始化，初始化完成立刻置为false</code></td>
</tr>
<tr>
<td>2、优化布局文件</td>
<td>若布局层次过多，那么用findViewById的时间就会边多，则容易导致启动慢</td>
<td>- 优化布局的层次结构，使用include、merge、ViewStub等 <br/>使用观察布局工具Hierarchy Viewer <br>使用布局优化工具：Layoutopt</td>
<td></td>
</tr>
<tr>
<td>3、提高Adapter、AdapterView的效率</td>
<td>数据过多，绘制效率过低，从而导致慢</td>
<td>- 重用以生成过的Item View<br/> 添加ViewHolder<br>缓存Item的数据<br>分段显示</td>
<td></td>
</tr>
<tr>
<td>4、减小主线程的阻塞时间</td>
<td>导致ANR的时间：<br> <code>1、用户无响应5s</code><br><code>2、网络、数据库阻塞10s</code><br/><code>3、广播接收者执行超过10s</code></td>
<td>将耗时过长的操作放入后台线程钟执行&amp;只在需要UI时通知主线程修改</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>页面显示速度</p>
<blockquote>
<p>a. 页面需绘制的内容（布局 &amp; 控件）太多，从而导致页面测量时间过长<br>b. 绘制效率过低，从而导致绘制时间过长</p>
</blockquote>
<ul>
<li>绘制优化(<a href="https://blog.csdn.net/carson_ho/article/details/79674623">https://blog.csdn.net/carson_ho/article/details/79674623</a>)</li>
<li>布局优化</li>
</ul>
</li>
<li><p>响应速度</p>
<blockquote>
<p>程序出现ANR情况，从而导致应用程序响应速度慢</p>
</blockquote>
</li>
</ul>
<pre><code>![简介](https://raw.githubusercontent.com/dpzxka/typora_pictures/master/简介.png)

优化方案：使用多线程，将大量&amp;耗时操作放在工作线程钟执行。

&gt; 1、多线程的方式 包括：AsyncTask、继承 Thread类、实现 Runnable接口、Handler消息机制、HandlerThread等
&gt;
&gt; 2、注：实际开发中，当一个进程发生了ANR后，系统会在 /data/anr目录下创建一个文件 traces.txt，通过分析该文件可定位出ANR的原因
</code></pre>
<ul>
<li><p>其他优化方案</p>
<ul>
<li><p>合理刷新机制</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220827145556240.png" alt="image-20220827145556240"></p>
</li>
<li><p>动画使用：</p>
<ol>
<li>根据不同场景选择 合适的动画框架</li>
<li>使用 硬件加速的方式 提高流畅度</li>
<li>使用动画后需停止动画</li>
</ol>
</li>
</ul>
</li>
<li><p>总结</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220827145733758.png" alt="image-20220827145733758"></p>
</li>
<li><p><strong><code>稳定性</code></strong></p>
<ul>
<li><p>应用崩溃<code>（Crash）</code></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220827162729079.png" alt="image-20220827162729079"></p>
<p>优化方案：<strong>使用多线程</strong>，将大量 &amp; 耗时操作放在工作线程中执行</p>
</li>
<li><p>应用无响应<code>（ANR）</code></p>
<p>应用崩溃<code>Crash</code>很多情况是因为 <strong>内存溢出</strong>，即<code>OOM</code>；故 需避免出现 <code>OOM</code>现象</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220827162819942.png" alt="image-20220827162819942"></p>
<p><a href="https://blog.csdn.net/carson_ho/article/details/79549417"> 优化方案</a></p>
</li>
<li><p>总结：</p>
<table>
<thead>
<tr>
<th>优化方向</th>
<th>优化原因</th>
<th>优化方案</th>
</tr>
</thead>
<tbody><tr>
<td>ANR</td>
<td>程序出现ANR情况，从而导致应用程序响应速度慢</td>
<td>使用多线程，将大量&amp;耗时操作放在工作线程执行</td>
</tr>
<tr>
<td>Crash</td>
<td>- 应用崩溃Crash很多情况是因为内存溢出：OOM<br>故需要避免OOM现象</td>
<td>内存优化：<br>1、避免内存泄漏<br>2、避免内存抖动：避免频繁创建大量、临时，小的局部对象<br/>3、提高代码质量、减少代码数量<br/>4、日常不正常使用：ListView的缓存复用、尽量少用多进程、依赖注入框架。</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong><code>资源节省性</code></strong></p>
<blockquote>
<ul>
<li>优化原因<br>由于移动设备的硬件性能有限，故减少应用程序的资源消耗显得十分重要</li>
<li>优化方向<br>内存大小、安装包大小、耗电量 &amp; 网络流量</li>
</ul>
</blockquote>
<ul>
<li><p>内存优化</p>
<blockquote>
<p>避免因不正确使用内存 &amp; 缺乏管理，从而出现 <strong>内存泄露<code>（ML）</code>、内存溢出<code>（OOM）</code>、内存空间占用过大</strong> 等问题，最终导致应用程序崩溃（<code>Crash</code>）</p>
</blockquote>
<p>优化方向：</p>
<ol>
<li>内存泄露</li>
<li>内存抖动</li>
<li>图片Bitmap相关</li>
<li>代码质量 &amp; 数量</li>
<li>日常不正确使用</li>
</ol>
</li>
<li><p>减少安装包大小</p>
<blockquote>
<ul>
<li>优化原因<br>应用程序的安装包大小虽对应用程序的使用无影响，但影响的是：</li>
</ul>
<ol>
<li>空间占有率：即 应用程序占有手机内存的大小</li>
<li>下载门槛：应用的安装包越大，用户下载的门槛越高</li>
</ol>
</blockquote>
<ul>
<li>优化原因<br>应用程序的安装包大小虽对应用程序的使用无影响，但影响的是：</li>
</ul>
<ol>
<li>空间占有率：即 应用程序占有手机内存的大小</li>
<li>下载门槛：应用的安装包越大，用户下载的门槛越高</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220827163920588.png" alt="image-20220827163920588"></p>
<p><strong>优化方案</strong>：</p>
<table>
<thead>
<tr>
<th>优化方案</th>
<th>原理</th>
<th>具体手段</th>
</tr>
</thead>
<tbody><tr>
<td>资源优化</td>
<td>尽可能较少不必要的资源文件<br><code>(图片、xml文件)</code></td>
<td>1.使用Android Lint删除冗余资源<br/>2.根据分辨率选择合适图片<br/>3、压缩处理图片、降低图片色彩位数<br/>使用内存占有小的图片格式，如Webp</td>
</tr>
<tr>
<td>较少不必要的库</td>
<td>库本省的大小可能非常大，从而导致内存增大</td>
<td>1、尽可能避免引入内存较大的库<br/>2、不引某个方法，而引入庞大的功能库</td>
</tr>
<tr>
<td>代码混淆</td>
<td>重命名代码中的类、方法、变量名等信息，把他们改成一些无意义的名字&amp;压缩、优化大小</td>
<td>1、使用代码混淆工具，如proGuard<br/>2、含压缩、优化、混淆功能</td>
</tr>
<tr>
<td>插件化</td>
<td>将功能独立成单独模块(APK)&amp;放在服务器上按需下载、按需加载</td>
<td>主应用APK仅保留基础、核心功能<br/>其余功能以模块化的形式存放在服务器上</td>
</tr>
</tbody></table>
</li>
<li><p>减少网络流量</p>
<ul>
<li><p>优化原因<br>每次获取资源时 都通过流量 &amp; 网络加载的方式，将耗费大量网络流量</p>
</li>
<li><p>优化方案<br>主要通过 <strong>缓存</strong> 减少网络流量，采用三级缓存方案：即 内存缓存 - 硬盘缓存- 数据库- 文件 - 网络缓存</p>
<blockquote>
<p>具体描述：当加载资源时，先从内存缓存中寻找；若内存缓存中没有，则从文件缓存中寻找；若文件缓存中没有，最终再通过流量从网络中加载获取</p>
</blockquote>
<p><a href="https://www.jianshu.com/p/5e7075f4875f">WebView缓存机制及资源预加载方案</a></p>
</li>
</ul>
</li>
<li><p>减少应用的耗电量</p>
<blockquote>
<p>随着智能手机普及 &amp; 应用程序<code>App</code>的功能发展，人们的日常生活都离不开智能手机 &amp; 各式各样的应用程序<code>App</code>，故 应用程序的耗电量指标则显得十分重要</p>
</blockquote>
<table>
<thead>
<tr>
<th>优化方案</th>
<th>优化原理</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>正确使用WakeLock机制</td>
<td>·WakeLock决定了Android 设备何时进入休眠状态<br/><code>a.应用只要申请了WakeLock，那么在释放WakeLock前，系统不会进入休眠</code><br/><code>b.即使在灭屏的状态下，应用要执行的任务依旧不会被系统打断</code><br/>只有正当使用WakeLock机制，避免过度使用从而使得应用能尽可能进入休眠状态，才能最大化减少耗电量</td>
<td>·简介：WakeLock是Android框架层提供的一套唤醒机制<br/>·作用：控制Android设备状态（<code>设备状态主要指屏幕的打开关闭、休眠、cpu的保持运行</code>）<br/>·主要应用场景：防止系统进入休眠状态，从而不断执行应用任务</td>
</tr>
<tr>
<td>尽量使用JobScheduler</td>
<td>JobScheduler API 允许按需控制任务的执行时机，使得减少因时机控制引起的电池消耗</td>
<td>·简介：Android5.0后引入的1个功能API接口·<br>作用：当预置的条件被满足时，JobSchedulerAPI为你的应用执行一个操作<br>主要应用场景：执行的任务存在前提条件（非时间条件而是具体条件）</td>
</tr>
<tr>
<td>使用电量分析工具<br>（Battery Historian）</td>
<td>通过电量分析工具，获取当前应用程序的耗电情况，从而优化耗电量温高的问题。</td>
<td>·简介：Battery Historian是一款图形化数据分析接口<br/>作用：分析Cndr0g 系维电量，可真观地属示出手机的电量消过程；通过输入电量分析文件显示消耗情况，最后提供电量优化的方案<br/>（<code>Battery Historian是Android5.0后引入的可获取设备上电量消耗信息的APl</code>）</td>
</tr>
</tbody></table>
</li>
<li><p>总结</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220827213040611.png" alt="image-20220827213040611"></p>
</li>
</ul>
</li>
<li><p>总结</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220827213201978.png" alt="image-20220827213201978"></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/5b2162850c630d99ee9392112ea5d5b5.png" alt="img"></p>
</li>
</ul>
<h5 id="2、Android性能优化：布局优化（含-lt-include-gt-、-lt-Viewstub-gt-、-lt-merge-gt-）"><a href="#2、Android性能优化：布局优化（含-lt-include-gt-、-lt-Viewstub-gt-、-lt-merge-gt-）" class="headerlink" title="2、Android性能优化：布局优化（含&lt; include &gt;、&lt; Viewstub &gt;、&lt; merge &gt;）"></a><a href="">2、Android性能优化：布局优化（含&lt; include &gt;、&lt; Viewstub &gt;、&lt; merge &gt;）</a></h5><p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/%E7%9B%AE%E5%BD%95.png" alt="目录"></p>
<ul>
<li><p>**<code>影响的性能</code>**：Android应用中页面显示速度</p>
</li>
<li><p><strong><code>如何影响性能</code><strong>：</strong>页面的测量&amp;绘制时间</strong></p>
<blockquote>
<p> 1个页面通过递归 完成测量 &amp; 绘制过程 = <code>measure</code>、<code>layout</code> 过程</p>
</blockquote>
</li>
<li><p><strong><code>优化思路</code></strong></p>
<ul>
<li>选择耗费性能少的布局</li>
<li>较少布局的层级(嵌套)</li>
<li>提高布局的复用性</li>
<li>减少测量&amp;绘制的时间</li>
</ul>
</li>
<li><p><strong><code>具体优化方案</code></strong></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220827221956160.png" alt="image-20220827221956160"></p>
<ul>
<li><p><strong><a href="">选择耗费性能少的布局</a></strong></p>
<ul>
<li>性能耗费低的布局 = 功能简单 = <code>FrameLayout</code>、<code>LinearLayout</code></li>
<li>性能耗费高的布局 = 功能复杂 = <code>RelativeLayout</code></li>
</ul>
<blockquote>
<p>即 布局过程需消耗更多性能（CPU资源 &amp; 时间）</p>
<p>注：</p>
<ol>
<li>嵌套所耗费的性能 &gt; 单个布局本身耗费的性能</li>
<li>即 完成需求时：宁选择 1个耗费性能高的布局，也不采用嵌套多个耗费性能低的布局</li>
</ol>
</blockquote>
</li>
<li><p><strong><a href="">较少布局的层级(嵌套)</a></strong></p>
<ul>
<li>原理：布局层级少 -&gt;&gt; 绘制的工作量少 -&gt;&gt; 绘制速度快 -&gt;&gt; 性能提高</li>
<li>优化方式：使用布局标签<code>&lt;merge&gt;</code> &amp; 合适选择布局类型</li>
</ul>
<p><code>使用布局标签</code>：减少布局层级</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// 使用说明：</span><br><span class="line">// 1. <span class="tag">&lt;<span class="name">merge</span>&gt;</span>作为被引用布局A的根标签</span><br><span class="line">// 2. 当其他布局通过<span class="tag">&lt;<span class="name">include</span>&gt;</span>标签引用布局A时，布局A中的<span class="tag">&lt;<span class="name">merge</span>&gt;</span>标签内容（根节点）会被去掉，在<span class="tag">&lt;<span class="name">include</span>&gt;</span>里存放的是布局A中的<span class="tag">&lt;<span class="name">merge</span>&gt;</span>标签内容（根节点）的子标签（即子节点），以此减少布局文件的层次</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line"> * 实例说明：在上述例子，在布局B中 通过<span class="tag">&lt;<span class="name">include</span>&gt;</span>标签引用布局C</span><br><span class="line"> * 此时：布局层级为 =  RelativeLayout -&gt;&gt; Button </span><br><span class="line"> *                                  —&gt;&gt; RelativeLayout -&gt;&gt; Button</span><br><span class="line"> *                                                     -&gt;&gt; TextView</span><br><span class="line"> * 现在使用<span class="tag">&lt;<span class="name">merge</span>&gt;</span>优化：将 被引用布局C根标签 的RelativeLayout 改为 <span class="tag">&lt;<span class="name">merge</span>&gt;</span></span><br><span class="line"> * 在引用布局C时，布局C中的<span class="tag">&lt;<span class="name">merge</span>&gt;</span>标签内容（根节点）会被去掉，在<span class="tag">&lt;<span class="name">include</span>&gt;</span>里存放的是布局C中的<span class="tag">&lt;<span class="name">merge</span>&gt;</span>标签内容（根节点）的子标签（即子节点）</span><br><span class="line"> * 即 <span class="tag">&lt;<span class="name">include</span>&gt;</span>里存放的是：<span class="tag">&lt;<span class="name">Button</span>&gt;</span>、<span class="tag">&lt;<span class="name">TextView</span>&gt;</span></span><br><span class="line"> * 此时布局层级为 =  RelativeLayout -&gt;&gt; Button </span><br><span class="line"> *                                -&gt;&gt; Button</span><br><span class="line"> *                                -&gt;&gt; TextView</span><br><span class="line"> * 即 已去掉之前无意义、多余的<span class="tag">&lt;<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"> */  </span><br><span class="line"></span><br><span class="line"> // 被引用的公共部分：布局C = layout_c.xml</span><br><span class="line"> <span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">merge</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;@dimen/dp_10&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/textview&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;@dimen/dp_10&quot;</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">merge</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  // 布局B：layout_b.xml</span><br><span class="line">  <span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line">   </span><br><span class="line">      <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:id</span>=<span class="string">&quot;@+id/Button&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;@dimen/dp_10&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">&quot;@layout/layout_c.xml&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>合适选择布局类型：</code></p>
<p>过合理选择布局类型，从而减少嵌套，即：完成 复杂的UI效果时，尽可能选择<code>1个功能复杂的布局</code>（如RelativeLayout）完成，而<code>不要选择多个功能简单的布局</code>（如：LinerLayout）通过嵌套完成</p>
</li>
<li><p><strong><a href="">提高布局的复用性</a></strong></p>
<p><strong>优化原理</strong>：提取布局间的公共部分，通过提高布局的复用性从而减少测量 &amp; 绘制时间</p>
<p><strong>优化方案</strong>：使用 布局标签 <include>，其作用是实现 布局模块化，即 提取布局中的公共部分 供其他布局共用。</p>
<p><strong>使用说明：</strong>通过标签引入抽取的公共部分布局C；标签所需属性 = 公共部分的layout属性，作用 = 指定需引入、包含的布局文件</p>
<p><strong>具体使用</strong><br>抽取布局A、B中的公共部分布局C &amp; 放入到布局B中使用.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">/** </span><br><span class="line"> * 布局B：layout_b.xml</span><br><span class="line"> */  </span><br><span class="line">  <span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line">   </span><br><span class="line">      <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:id</span>=<span class="string">&quot;@+id/Button&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;@dimen/dp_10&quot;</span> /&gt;</span></span><br><span class="line">      </span><br><span class="line">      // 通过<span class="tag">&lt;<span class="name">include</span>&gt;</span>标签引入抽取的公共部分布局C</span><br><span class="line">      // <span class="tag">&lt;<span class="name">include</span>&gt;</span>标签所需属性 = 公共部分的layout属性，作用 = 指定需引入、包含的布局文件</span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">&quot;@layout/layout_c.xml&quot;</span> /&gt;</span></span><br><span class="line">   </span><br><span class="line">  <span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line"> * 公共部分的布局C：layout_c.xml</span><br><span class="line"> */</span><br><span class="line">   <span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line">   </span><br><span class="line">      <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_height</span>=<span class="string">&quot;@dimen/dp_10&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:id</span>=<span class="string">&quot;@+id/textview&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_height</span>=<span class="string">&quot;@dimen/dp_10&quot;</span>/&gt;</span></span><br><span class="line">   </span><br><span class="line">  <span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li><p><strong><a href="">减少测量&amp;绘制的时间</a></strong></p>
<blockquote>
<p>使用 布局标签<code>&lt;ViewStub&gt;</code> &amp; 尽可能少用布局属性 <code>wrap_content</code></p>
</blockquote>
<p><strong>作用</strong>：按需加载 外部引入的布局，属 轻量级View、不占用显示 &amp; 位置<br>应用场景：引入 只在特殊情况下才显示的布局（即 默认不显示），如：进度显示布局、信息出错出现的提示布局等<br><strong>使用说明</strong></p>
<ol>
<li>先设置好预显示的布局</li>
<li>在其他布局通过标签引入外部布局（类似）；注：此时该布局还未被加载显示</li>
<li>只有当ViewStub被设置为可见 / 调用了ViewStub.inflate()时，ViewStub所指向的布局文件才会被inflate 、实例化，最终 显示指向的布局</li>
</ol>
<p><strong>具体使用</strong>：在布局A中引入布局B，只有在特定时刻C中才显示</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// 步骤1：先设置好预显示的布局B = layout_b.xml</span><br><span class="line"> <span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;@dimen/dp_10&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/textview&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;@dimen/dp_10&quot;</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 步骤2：在布局A通过<span class="tag">&lt;<span class="name">ViewStub</span>&gt;</span>标签引入布局B（类似<span class="tag">&lt;<span class="name">include</span>&gt;</span>）；注：此时该布局还未被加载显示</span><br><span class="line">// 布局A：layout_a.xml</span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/Button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;@dimen/dp_10&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ViewStub</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/Blayout&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout</span>=<span class="string">&quot;@layout/layout_b&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 步骤3：只有当ViewStub被设置为可见 / 调用了ViewStub.inflate()时，ViewStub所指向的布局文件才会被inflate 、实例化，最终 显示<span class="tag">&lt;<span class="name">ViewStub</span>&gt;</span>指向的布局</span><br><span class="line">ViewStub stub = (ViewStub) findViewById(R.id.Blayout);   </span><br><span class="line">stub.inflate();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>ViewStub中的layout布局不能使用merge标签，否则会报错</li>
<li>ViewStub的inflate只能执行一次，显示了之后，就不能再使用ViewStub控制它了</li>
<li>与View.setVisible(View.Gone)的区别：View 的可见性设置为 gone 后，在inflate 时，该View 及其子View依然会被解析；而使用ViewStub就能避免解析其中指定的布局文件，从而节省布局文件的解析时间 &amp; 内存的占用</li>
</ol>
<p>布局属性<code>wrap_content</code> 会增加布局测量时计算成本，应尽可能少用；特别是在已知宽高为固定值时，不使用<code>wrap_content</code>。</p>
</blockquote>
</li>
<li><p>布局调优工具</p>
<ul>
<li><p>Lint</p>
<p><a href="https://blog.csdn.net/u011240877/article/details/54141714">使用教程</a></p>
</li>
<li><p>Systrace</p>
<p>简介: Android 4.1以上版本提供的性能数据采样 &amp; 分析工具<br>作用:检测 Android系统各个组件随着时间的运行状态 &amp; 提供解决方案</p>
<blockquote>
<ol>
<li>收集 等运行信息，从而帮助开发者更直观地分析系统瓶颈，改进性能<br>检测范围包括：Android 关键子系统（如WindowManagerService 等 Framework 部分关键模块）、服务、View系统</li>
<li>功能包括：跟踪系统的I/O 操作、内核工作队列、CPU 负载等，在 UI 显示性能分析上提供很好的数据，特别是在动画播放不流畅、渲染卡等问题上</li>
</ol>
</blockquote>
<p><a href="http://gityuan.com/2016/01/17/systrace/">使用教程</a></p>
</li>
</ul>
</li>
</ul>
<h5 id="3、Android性能优化：内存泄露"><a href="#3、Android性能优化：内存泄露" class="headerlink" title="3、Android性能优化：内存泄露"></a><a href="">3、Android性能优化：内存泄露</a></h5><ul>
<li><p><strong><code>1、简介：</code></strong></p>
<ul>
<li>ML(Memory  Leak)</li>
<li>程序在申请内存后，当该内存不需要再使用<strong>但却无法被释放&amp;归还给程序</strong> 的现象</li>
</ul>
</li>
<li><p><strong><code>2、对应用程序的影响</code></strong></p>
<p>容易使得应用程序发生内存溢出，即<code>OOM</code></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220828001331700.png" alt="image-20220828001331700"></p>
</li>
<li><p><strong><code>3、发生内存泄漏的本质原因</code></strong></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220828001421068.png" alt="image-20220828001421068"></p>
<p>注意：</p>
</li>
<li><p><strong><code>4、Android内存管理机制</code></strong></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220828081537409.png" alt="image-20220828081537409"></p>
<p><strong><code>1、针对进程的内存策略</code></strong></p>
<p><strong>内存分配策略：</strong></p>
<p>由ActivityManagerService集中分配所有进程的内存分配</p>
<p>内存回收策略：</p>
<ol>
<li>Application FrameWork决定回收的进程类型</li>
</ol>
</li>
</ul>
<pre><code> ![进程优先级](https://www.processon.com/view/link/630ab73e63768906ff6909b6)

 ![image-20220828083228966](https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220828083228966.png)
</code></pre>
<ol start="2">
<li>Linux内核真正回收具体进程</li>
</ol>
<p><strong><code>2、针对对象、变量 的内存策略</code></strong></p>
<p><strong>内存分配策略</strong><br>对象 / 变量的内存分配 由程序自动 负责，共有3种：静态分配、栈式分配、 &amp; 堆式分配，分别面向静态变量、局部变量 &amp; 对象实例</p>
<table>
<thead>
<tr>
<th>内存分配策略</th>
<th>使用的内存空间</th>
<th>存储的数据</th>
<th>分配策略描述</th>
</tr>
</thead>
<tbody><tr>
<td>静态分配</td>
<td>方法区<br><code>（静态存储区）</code></td>
<td>存储已被虚拟机加载的类信息、常量、静态变量</td>
<td>在程序编译时就已分配好&amp;存在于程序整个运行期间<br><code>（不需回收）</code></td>
</tr>
<tr>
<td>栈式分配区</td>
<td>栈区<code>（Stack）</code></td>
<td>存储方法执行时的局部变量（含教据类型、对象的引用）<br><code>以桢栈形式</code></td>
<td>方法执行时，定义局部变量则由程序自动在栈中分配内存<br>方法执行结来/超出变量境时，则由栈自动释放该部分内存<br>效率高<br>（<code>因栈内存分配运算内置于处理器的指令集中</code>）<br>但分配的内存容量有限</td>
</tr>
<tr>
<td>堆式分配<br>(动态内存分配)</td>
<td>堆区<br>（Heap）</td>
<td>存储Java对象的实例&amp;实例内成员变量<br><code>即采用关键字new出来的对象</code><br><code>实例的成员变量=基本数据类型、引用&amp;引用的对象实体</code></td>
<td>创建对象实例时，有程序分配<br>（<code>由Java垃级回收管理器自动管理；不使用时则回收</code>）<br>访问方式<br>.1在堆中创建1个对象/数组&amp;在栈中定义一个特殊的变量(引用变量)=数组/对象在堆内存中的首地址<br>2.通过引用变量来访问堆内存中的对象/数组</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>基本数据类型、局部变量、</strong>对象的引用变量<strong>都是存放在栈内存中的，用完就消失</strong></p>
<p><strong>new创建的实例化对象及数组，是存放在堆内存中的，用完之后靠垃圾回收机制不定期自动消除</strong></p>
</blockquote>
<p><strong>内存释放</strong>：垃圾回收算法</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220828091450126.png" alt="image-20220828091450126"></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p><strong><code>5、内存泄漏原因&amp;解决方案</code></strong></p>
<ol>
<li><strong>集合类</strong></li>
</ol>
<p><a href="">原因</a>：集合类添加元素后，仍引用着集合元素对象，导致该集合元素对象不可被回收，从而 导致内存泄漏。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 循环申请Object 对象 &amp; 将申请的对象逐个放入到集合List</span></span><br><span class="line">List&lt;Object&gt; objectList = <span class="keyword">new</span> ArrayList&lt;&gt;();        </span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Object o = <span class="keyword">new</span> Object();</span><br><span class="line">            objectList.add(o);</span><br><span class="line">            o = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 虽释放了集合元素引用的本身：o=null）</span></span><br><span class="line"><span class="comment">// 但集合List 仍然引用该对象，故垃圾回收器GC 依然不可回收该对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="null">解决方案</a>:集合类 添加集合元素对象 后，在使用后必须从集合中删除</p>
<blockquote>
<p>由于1个集合中有许多元素，故最简单的方法 = 清空集合对象 &amp; 设置为<code>null</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放objectList</span></span><br><span class="line">       objectList.clear();</span><br><span class="line">       objectList=<span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong><code>Static</code>关键字修饰的成员变量</strong></p>
<blockquote>
<p>被 Static 关键字修饰的成员变量的生命周期 = 应用程序的生命周期</p>
</blockquote>
<p><a href="">原因</a>:使被 Static 关键字修饰的成员变量 引用耗费资源过多的实例（如Context），则容易出现该成员变量的生命周期 &gt; 引用实例生命周期的情况，当引用实例需结束生命周期销毁时，会因静态变量的持有而无法被回收，从而出现内存泄露.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 定义1个静态变量</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Context mContext;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line"><span class="comment">// 引用的是Activity的context</span></span><br><span class="line"> mContext = context; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 当Activity需销毁时，由于mContext = 静态 &amp; 生命周期 = 应用程序的生命周期，故 Activity无法被回收，从而出现内存泄露</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="null">解决方案</a>:</p>
<p>1、尽量避免 Static 成员变量引用资源耗费过多的实例。若需引用 Context，则尽量使用Applicaiton的Context。</p>
<p>2、使用 弱引用<code>（WeakReference）</code> 代替 强引用 持有实例。</p>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建单例时，需传入一个Context</span></span><br><span class="line"><span class="comment">// 若传入的是Activity的Context，此时单例 则持有该Activity的引用</span></span><br><span class="line"><span class="comment">// 由于单例一直持有该Activity的引用（直到整个应用生命周期结束），即使该Activity退出，该Activity的内存也不会被回收</span></span><br><span class="line"><span class="comment">// 特别是一些庞大的Activity，此处非常容易导致OOM</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstanceClass</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleInstanceClass instance;    </span><br><span class="line">    <span class="keyword">private</span> Context mContext;    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleInstanceClass</span><span class="params">(Context context)</span> </span>&#123;        </span><br><span class="line">        <span class="comment">//this.mContext = context; // 传递的是Activity的context</span></span><br><span class="line">        <span class="comment">//解决方式</span></span><br><span class="line">        <span class="keyword">this</span>.mContext = context.getApplicationContext();</span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> SingleInstanceClass <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingleInstanceClass(context);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>非静态内部类 / 匿名类</strong></p>
<blockquote>
<p>非静态内部类 / 匿名类 默认持有 外部类的引用；而静态内部类则不会</p>
<p>3种情况非静态内部类的实例 = 静态、多线程、消息传递机制（Handler）</p>
</blockquote>
<ul>
<li><p><code>非静态内部类的实例 = 静态</code></p>
<p><a href="">原因：</a>若非静态内部类所创建的实例 = 静态（其生命周期 = 应用的生命周期），会因<strong>非静态内部类默认持有外部类的引用</strong> 而导致外部类无法释放，最终造成内存泄露。(即外部类中持有非静态内部类的静态对象)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 背景：</span></span><br><span class="line">   <span class="comment">/*a. 在启动频繁的Activity中，为了避免重复创建相同的数据资源，会在Activity内部创建一个非静态内部类的单例</span></span><br><span class="line"><span class="comment">   b. 每次启动Activity时都会使用该单例的数据*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 非静态内部类的实例的引用</span></span><br><span class="line">    <span class="comment">// 注：设置为静态  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> InnerClass innerClass = <span class="keyword">null</span>; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);   </span><br><span class="line">        <span class="comment">// 保证非静态内部类的实例只有1个</span></span><br><span class="line">        <span class="keyword">if</span> (innerClass == <span class="keyword">null</span>)</span><br><span class="line">            innerClass = <span class="keyword">new</span> InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非静态内部类的定义    </span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;        </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 造成内存泄露的原因：</span></span><br><span class="line">    <span class="comment">// a. 当TestActivity销毁时，因非静态内部类单例的引用（innerClass）的生命周期 = 应用App的生命周期、持有外部类TestActivity的引用</span></span><br><span class="line">    <span class="comment">// b. 故 TestActivity无法被GC回收，从而导致内存泄漏</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="null">解决方案</a>:</p>
<ol>
<li>将非静态内部类设置为：静态内部类（静态内部类默认不持有外部类的引用）</li>
<li>该内部类抽取出来封装成一个单例</li>
<li>尽量 避免 非静态内部类所创建的实例 = 静态</li>
</ol>
</li>
<li><p><code>非静态内部类的实例 = 多线程</code></p>
<blockquote>
<p>多线程的使用方法 = 非静态内部类 / 匿名类；即 线程类 属于 非静态内部类 / 匿名类。</p>
<p>多线程主要使用的是：AsyncTask、实现Runnable接口 &amp; 继承Thread类</p>
</blockquote>
<p><a href="">原因：</a>:</p>
<p>当 工作线程正在处理任务 &amp; 外部类需销毁时， <strong>由于 工作线程实例 持有外部类引用</strong>，将使得外部类无法被垃圾回收器（GC）回收，从而造成 内存泄露.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 方式1：新建Thread子类（内部类）</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;carson：&quot;</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">            setContentView(R.layout.activity_main);</span><br><span class="line">            <span class="comment">// 通过创建的内部类 实现多线程</span></span><br><span class="line">            <span class="keyword">new</span> MyThread().start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自定义的Thread子类</span></span><br><span class="line">        <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;执行了多线程&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 方式2：匿名Thread内部类</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">     <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;carson：&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过匿名内部类 实现多线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;执行了多线程&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 分析：内存泄露原因</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">  <span class="comment">// 工作线程Thread类属于非静态内部类 / 匿名内部类，运行时默认持有外部类的引用</span></span><br><span class="line">  <span class="comment">// 当工作线程运行时，若外部类MainActivity需销毁</span></span><br><span class="line">  <span class="comment">// 由于此时工作线程类实例持有外部类的引用，将使得外部类无法被垃圾回收器（GC）回收，从而造成 内存泄露</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="null">解决方案</a>:</p>
<ol>
<li><p>存在 ”工作线程实例 持有外部类引用“ 的引用关系</p>
</li>
<li><p>工作线程实例的生命周期 &gt; 外部类的生命周期，即工作线程仍在运行 而 外部类需销毁。</p>
<p>思路：上述条件任意1个不成立。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 共有2个解决方案：静态内部类 &amp; 当外部类结束生命周期时，强制结束线程</span></span><br><span class="line"><span class="comment">// 具体描述如下</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 解决方式1：静态内部类</span></span><br><span class="line"><span class="comment">     * 原理：静态内部类不默认持有外部类的引用，从而使得 “工作线程实例持有外部类引用” 的引用关系不复存在</span></span><br><span class="line"><span class="comment">     * 具体实现：将Thread的子类设置成 静态内部类</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;carson：&quot;</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">            setContentView(R.layout.activity_main);</span><br><span class="line">            <span class="comment">// 通过创建的内部类 实现多线程</span></span><br><span class="line">            <span class="keyword">new</span> MyThread().start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分析1：自定义Thread子类</span></span><br><span class="line">        <span class="comment">// 设置为：静态内部类</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;执行了多线程&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 解决方案2：当外部类结束生命周期时，强制结束线程</span></span><br><span class="line"><span class="comment">     * 原理：使得 工作线程实例的生命周期 与 外部类的生命周期 同步</span></span><br><span class="line"><span class="comment">     * 具体实现：当 外部类（此处以Activity为例） 结束生命周期时（此时系统会调用onDestroy（）），强制结束线程（调用stop（））</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        Thread.stop();</span><br><span class="line">        <span class="comment">// 外部类Activity生命周期结束时，强制结束线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ul>
<pre><code> - `非静态内部类的实例 = 消息传递机制（Handler）`

   [案例]():

   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 方式1：新建Handler子类（内部类）</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;carson：&quot;</span>;</span><br><span class="line">            <span class="keyword">private</span> Handler showhandler;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 主线程创建时便自动创建Looper &amp; 对应的MessageQueue</span></span><br><span class="line">            <span class="comment">// 之后执行Loop()进入消息循环</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">                setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//1. 实例化自定义的Handler类对象-&gt;&gt;分析1</span></span><br><span class="line">                <span class="comment">//注：此处并无指定Looper，故自动绑定当前线程(主线程)的Looper、MessageQueue</span></span><br><span class="line">                showhandler = <span class="keyword">new</span> FHandler();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 启动子线程1</span></span><br><span class="line">                <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// a. 定义要发送的消息</span></span><br><span class="line">                        Message msg = Message.obtain();</span><br><span class="line">                        msg.what = <span class="number">1</span>;<span class="comment">// 消息标识</span></span><br><span class="line">                        msg.obj = <span class="string">&quot;AA&quot;</span>;<span class="comment">// 消息存放</span></span><br><span class="line">                        <span class="comment">// b. 传入主线程的Handler &amp; 向其MessageQueue发送消息</span></span><br><span class="line">                        showhandler.sendMessage(msg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.start();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3. 启动子线程2</span></span><br><span class="line">                <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// a. 定义要发送的消息</span></span><br><span class="line">                        Message msg = Message.obtain();</span><br><span class="line">                        msg.what = <span class="number">2</span>;<span class="comment">// 消息标识</span></span><br><span class="line">                        msg.obj = <span class="string">&quot;BB&quot;</span>;<span class="comment">// 消息存放</span></span><br><span class="line">                        <span class="comment">// b. 传入主线程的Handler &amp; 向其MessageQueue发送消息</span></span><br><span class="line">                        showhandler.sendMessage(msg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.start();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 分析1：自定义Handler子类</span></span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">FHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 通过复写handlerMessage() 从而确定更新UI的操作</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                            Log.d(TAG, <span class="string">&quot;收到线程1的消息&quot;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                            Log.d(TAG, <span class="string">&quot; 收到线程2的消息&quot;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 方式2：匿名Handler内部类</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">     <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;carson：&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> Handler showhandler;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程创建时便自动创建Looper &amp; 对应的MessageQueue</span></span><br><span class="line">        <span class="comment">// 之后执行Loop()进入消息循环</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">            setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//1. 通过匿名内部类实例化的Handler类对象</span></span><br><span class="line">            <span class="comment">//注：此处并无指定Looper，故自动绑定当前线程(主线程)的Looper、MessageQueue</span></span><br><span class="line">            showhandler = <span class="keyword">new</span>  Handler()&#123;</span><br><span class="line">                <span class="comment">// 通过复写handlerMessage()从而确定更新UI的操作</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                                Log.d(TAG, <span class="string">&quot;收到线程1的消息&quot;</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                                Log.d(TAG, <span class="string">&quot; 收到线程2的消息&quot;</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 启动子线程1</span></span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// a. 定义要发送的消息</span></span><br><span class="line">                    Message msg = Message.obtain();</span><br><span class="line">                    msg.what = <span class="number">1</span>;<span class="comment">// 消息标识</span></span><br><span class="line">                    msg.obj = <span class="string">&quot;AA&quot;</span>;<span class="comment">// 消息存放</span></span><br><span class="line">                    <span class="comment">// b. 传入主线程的Handler &amp; 向其MessageQueue发送消息</span></span><br><span class="line">                    showhandler.sendMessage(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 启动子线程2</span></span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// a. 定义要发送的消息</span></span><br><span class="line">                    Message msg = Message.obtain();</span><br><span class="line">                    msg.what = <span class="number">2</span>;<span class="comment">// 消息标识</span></span><br><span class="line">                    msg.obj = <span class="string">&quot;BB&quot;</span>;<span class="comment">// 消息存放</span></span><br><span class="line">                    <span class="comment">// b. 传入主线程的Handler &amp; 向其MessageQueue发送消息</span></span><br><span class="line">                    showhandler.sendMessage(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

   &gt; - 主线程的`Looper`对象的生命周期 = 该应用程序的生命周期
   &gt; - 在`Java`中，**非静态内部类** &amp; **匿名内部类**都默认持有 外部类的引用

   [参考](https://www.jianshu.com/p/ed9e15eff47a)

   [原因]():

   由于Handler = 非静态内部类 / 匿名内部类（2种使用方式），故又默认持有外部类的引用（即MainActivity实例）。

   由于`Handler` = 非静态内部类 / 匿名内部类（2种使用方式），故又默认持有外部类的引用（即`MainActivity`实例）

   [解决方案]()

   **原理**：静态内部类不默认持有外部类的引用，从而使得 “未被处理 / 正处理的消息 -&gt; Handler实例 -&gt; 外部类” 的引用关系 不存在。

   **具体方案：**将Handler的子类设置成静态内部类。此外，还可使用WeakReference弱引用持有外部类，保证外部类能被回收。因为：弱引用的对象拥有短暂的生命周期，在垃圾回收器线程扫描时，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。

   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;carson：&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Handler showhandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">// 实例化自定义的Handler类对象-&gt;&gt;分析1</span></span><br><span class="line">        <span class="comment">// 注：</span></span><br><span class="line">            <span class="comment">// a. 此处并无指定Looper，故自动绑定当前线程(主线程)的Looper、MessageQueue；</span></span><br><span class="line">            <span class="comment">// b. 定义时需传入持有的Activity实例（弱引用）</span></span><br><span class="line">        showhandler = <span class="keyword">new</span> FHandler(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// a. 定义要发送的消息</span></span><br><span class="line">                Message msg = Message.obtain();</span><br><span class="line">                msg.what = <span class="number">1</span>;<span class="comment">// 消息标识</span></span><br><span class="line">                msg.obj = <span class="string">&quot;AA&quot;</span>;<span class="comment">// 消息存放</span></span><br><span class="line">                showhandler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置为：静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义 弱引用实例</span></span><br><span class="line">        <span class="keyword">private</span> WeakReference&lt;Activity&gt; reference;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在构造方法中传入需持有的Activity实例</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">FHandler</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 使用WeakReference弱引用持有Activity实例</span></span><br><span class="line">            reference = <span class="keyword">new</span> WeakReference&lt;Activity&gt;(activity); &#125;</span><br><span class="line">        <span class="comment">// 通过复写handlerMessage() 从而确定更新UI的操作</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;收到线程1的消息&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot; 收到线程2的消息&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="4">
<li><p><strong>资源对象使用后未关闭</strong></p>
<p><a href="">原因</a>:</p>
<p>对于资源的使用（如 广播<code>BraodcastReceiver</code>、文件流<code>File</code>、数据库游标<code>Cursor</code>、图片资源<code>Bitmap</code>等），若在<code>Activity</code>销毁时无及时关闭 / 注销这些资源，则这些资源将不会被回收，从而造成内存泄漏</p>
<p><a href="">解决方案</a>:</p>
<p>在Activity销毁时 及时关闭 / 注销资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于 广播BraodcastReceiver：注销注册</span></span><br><span class="line">unregisterReceiver()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 文件流File：关闭流</span></span><br><span class="line">InputStream / OutputStream.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于数据库游标cursor：使用后关闭游标</span></span><br><span class="line">cursor.close（）</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 图片资源Bitmap：Android分配给图片的内存只有8M，若1个Bitmap对象占内存较多，当它不再被使用时，应调用recycle()回收此对象的像素所占用的内存；最后再赋为null </span></span><br><span class="line">Bitmap.recycle()；</span><br><span class="line">Bitmap = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于动画（属性动画）</span></span><br><span class="line"><span class="comment">// 将动画设置成无限循环播放repeatCount = “infinite”后</span></span><br><span class="line"><span class="comment">// 在Activity退出时记得停止动画</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><strong>其他情况</strong></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220828161813990.png" alt="image-20220828161813990"></p>
</li>
</ol>
<ol start="6">
<li><p>总结：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e70c23ea7510da25a14138fc25a9a3ba.png" alt="总结"></p>
</li>
</ol>
<ul>
<li><p><strong><code>6、辅助分析内存泄露的工具</code></strong></p>
<p><a href="https://developer.android.google.cn/studio/profile/android-profiler">Android Profiler  | Android 开发者  | Android Developers (google.cn)</a></p>
<p><a href="https://www.jianshu.com/p/a16c87ecdf6f">Android优化工具Systrace - 简书 (jianshu.com)</a></p>
<p>[dumpsys:](<a href="https://developer.android.com/studio/command-line/dumpsys?hl=en">dumpsys  | Android Developers</a>) Android内核系统服务相关的计数器。<br>[heapprofd：](<a href="https://perfetto.dev/docs/design-docs/heapprofd-design">heapprofd: Android Heap Profiler - Perfetto Tracing Docs</a>)Android进程本地内存分析工具。</p>
</li>
<li><p><strong><code>7、总结</code></strong></p>
</li>
</ul>
<h5 id="4、Android性能优化：内存优化"><a href="#4、Android性能优化：内存优化" class="headerlink" title="4、Android性能优化：内存优化"></a><a href="">4、Android性能优化：内存优化</a></h5><ol>
<li><p>内存泄露:见上分析</p>
</li>
<li><p>内存抖动</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/c2a5b5b215996caf83385e6d6b370437.png" alt="img"></p>
<p><strong>尽量避免频繁创建大量、临时的小对象</strong></p>
</li>
<li><p>图片<code>Bitmap</code>相关</p>
<p>参考：<a href="https://blog.csdn.net/carson_ho/article/details/79549382">Android性能优化：那些关于Bitmap图片资源优化的小事_Carson带你学Android的博客-CSDN博客</a></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220829072715524.png" alt="image-20220829072715524"></p>
</li>
<li><p>代码质量 &amp; 数量</p>
<ul>
<li>优化原因<br>代码本身的质量（如 数据结构、数据类型等） &amp; 数量（代码量的大小）可能会导致大量的内存问题，如占用内存大、内存利用率低等</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/40ecb5de67f58041c808f1a4476698ed.png" alt="img"></p>
</li>
<li><p>日常不正确使用</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/e193ab51467c5de82501b787a8357d57.png" alt="img"></p>
</li>
<li><p>小技巧</p>
<p><strong>技巧1：获取当前可使用的内存大小</strong><br>调用 ActivityManager.getMemoryClass（）方法可获取当前应用可用的内存大小（单位 = 兆）</p>
<p><strong>技巧2：获取当前的内存使用情况</strong><br>在应用生命周期的任何阶段，调用 onTrimMemory()获取应用程序 当前内存使用情况（以内存级别进行识别），可根据该方法返回的内存紧张级别参数 来释放内存</p>
<p><strong>技巧3：当视图变为隐藏状态时，则释放内存</strong><br>当用户跳转到不同的应用 &amp; 视图不再显示时, 应释放应用视图所占的资源</p>
<blockquote>
<ol>
<li>注：此时释放所占用的资源能显著的提高系统的缓存处理容量</li>
<li>具体操作：实现当前<code>Activity</code>类的<code>onTrimMemory()</code>后，当用户离开视图时会得到通知；若得到返回的参数 = <code>TRIM_MEMORY_UI_HIDDEN</code> 即代表视图变为隐藏状态，则可释放视图所占用的资源</li>
</ol>
</blockquote>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/dd35b51f50f4ad2e2583707dbec694c8.png" alt="img"></p>
<h5 id="5、Android性能优化：Bitmap图片资源优化"><a href="#5、Android性能优化：Bitmap图片资源优化" class="headerlink" title="5、Android性能优化：Bitmap图片资源优化"></a><a href="">5、Android性能优化：Bitmap图片资源优化</a></h5><p><a href="https://carsonho.blog.csdn.net/article/details/79549382">Android性能优化：那些关于Bitmap图片资源优化的小事</a></p>
<h5 id="6、Android性能优化：绘制优化"><a href="#6、Android性能优化：绘制优化" class="headerlink" title="6、Android性能优化：绘制优化"></a><a href="">6、Android性能优化：绘制优化</a></h5><p><a href="https://carsonho.blog.csdn.net/article/details/79674623">Android性能优化：绘制优化</a></p>
<h4 id="6、常用开源框架"><a href="#6、常用开源框架" class="headerlink" title="6、常用开源框架"></a>6、常用开源框架</h4><h5 id="Android实现网络请求的主流方法"><a href="#Android实现网络请求的主流方法" class="headerlink" title="Android实现网络请求的主流方法"></a>Android实现网络请求的主流方法</h5><p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/51f7ecf5b9a606c499ac87c5b4d54d4c.png" alt="img"></p>
<h5 id="网络请求库-与-Android网络请求方法的关系"><a href="#网络请求库-与-Android网络请求方法的关系" class="headerlink" title="网络请求库 与 Android网络请求方法的关系"></a>网络请求库 与 Android网络请求方法的关系</h5><ul>
<li>网络请求库的本质 = 封装了 <strong>网络请求 + 异步 + 数据处理</strong>功能的库</li>
<li>其中，网络请求功能则是采用<code>Android</code>网络请求的原生方法（<code>HttpClient</code>或<code>HttpURLConnection</code>）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/156b09c922bd3e3cda37a4bce78c9c4b.png" alt="img"></p>
<h5 id="主流的网络请求库"><a href="#主流的网络请求库" class="headerlink" title="主流的网络请求库"></a>主流的网络请求库</h5><p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/5307f5ae81079a75369fa10cd6b3908d.png" alt="img"></p>
<h4 id="7、新技术"><a href="#7、新技术" class="headerlink" title="7、新技术"></a>7、新技术</h4><p><a href="https://carsonho.blog.csdn.net/article/details/100070713">MVC、MVP &amp; MVVM模式（含实例讲解</a></p>
<p><a href="https://carsonho.blog.csdn.net/article/details/73250163">JNI 与 NDK到底是什么？（含实例教学）</a></p>
<p><a href="https://carsonho.blog.csdn.net/article/details/88012315">热修复学习指南</a></p>
<p>插件化</p>
<p><img src="https://camo.githubusercontent.com/25fd33fb30eab376400c46bff4a8ccf5ebf704b739078654f4b926bafc4c2401/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f3934343336352d363966353830386438306330353839382e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="插件化"></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>PDF TestNew</title>
    <url>/2022/08/31/PdfTest-1/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="33.pdf" width="100%" height="550" type="application/pdf">
	</div>






	<div class="row">
    <embed src="https://cloud.tsinghua.edu.cn/f/952edbd1e02d409cbd01/" width="100%" height="550" type="application/pdf">
	</div>



]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>6、Android 开源框架</title>
    <url>/2022/09/13/Android/6%E3%80%81%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="开源框架"><a href="#开源框架" class="headerlink" title="开源框架"></a>开源框架</h2><h3 id="图片开源框架"><a href="#图片开源框架" class="headerlink" title="图片开源框架"></a>图片开源框架</h3><ul>
<li><a href="https://github.com/square/picasso">Picasso</a></li>
<li><a href="https://github.com/facebook/fresco">Fresco</a></li>
<li><a href="https://github.com/bumptech/glide">Glide</a></li>
</ul>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/4ef4a0c0a9551445eadd9c2e5ef677ad.png" alt="img"></p>
<h4 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h4><blockquote>
<p>Android图片开源库，开源项目</p>
</blockquote>
<h5 id="1、基础功能"><a href="#1、基础功能" class="headerlink" title="1、基础功能"></a>1、基础功能</h5><h6 id="1、图片的加载"><a href="#1、图片的加载" class="headerlink" title="1、图片的加载"></a>1、图片的加载</h6><ul>
<li><p>图片的异步加载(<code>基础功能</code>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ImageView targetImageView = (ImageView) findViewById(R.id.ImageView);</span><br><span class="line">String Url = <span class="string">&quot;http://218.192.170.132/1.jpg&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Glide使用了流式接口的调用方式</span></span><br><span class="line"><span class="comment">//Glide类是核心实现类。</span></span><br><span class="line">Glide.with(context).load(Url).into(targetImageView);</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现图片加载功能至少需要三个参数：</span></span><br><span class="line"><span class="comment">//with(Context context)</span></span><br><span class="line"><span class="comment">//Context对于很多Android API的调用都是必须的，这里就不多说了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//load(String imageUrl)：被加载图像的Url地址。</span></span><br><span class="line"><span class="comment">//大多情况下，一个字符串代表一个网络图片的URL。</span></span><br><span class="line">                </span><br><span class="line"><span class="comment">//into(ImageView targetImageView)：图片最终要展示的地方。</span></span><br><span class="line">                </span><br></pre></td></tr></table></figure></li>
<li><p>设置加载尺寸</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Glide.with(<span class="keyword">this</span>).load(imageUrl).override(<span class="number">800</span>, <span class="number">800</span>).into(imageView);</span><br></pre></td></tr></table></figure></li>
<li><p>设置加载中以及加载失败图片</p>
<blockquote>
<p>api里面对placeholder()、error()函数中有多态实现，用的时候可以具体的熟悉一下</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Glide.with(<span class="keyword">this</span>)</span><br><span class="line">     .load(imageUrl)</span><br><span class="line">     .placeholder(R.mipmap.ic_launcher).error(R.mipmap.ic_launcher).into(imageView);</span><br></pre></td></tr></table></figure></li>
<li><p>设置加载动画</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Glide.with(<span class="keyword">this</span>).load(imageUrl).animate(R.anim.item_alpha_in).into(imageView);</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--R.anim.item_alpha_in.xml--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">alpha</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:duration</span>=<span class="string">&quot;500&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:fromAlpha</span>=<span class="string">&quot;0.0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:toAlpha</span>=<span class="string">&quot;1.0&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>设置加载内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Glide.with(<span class="keyword">this</span>).load(imageUrl).centerCrop().into(<span class="keyword">new</span> SimpleTarget&lt;GlideDrawable&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(GlideDrawable resource, GlideAnimation&lt;? <span class="keyword">super</span> GlideDrawable&gt; glideAnimation)</span> </span>&#123;</span><br><span class="line">                imageView.setImageDrawable(resource);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="2、媒体加载"><a href="#2、媒体加载" class="headerlink" title="2、媒体加载"></a>2、媒体加载</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Glide</span><br><span class="line">     .with(context)</span><br><span class="line">     .load(imageUrl)；</span><br><span class="line">     .thumbnail(<span class="number">0.1f</span>)；<span class="comment">//设置缩略图支持：先加载缩略图 然后在加载全图</span></span><br><span class="line">                        <span class="comment">//传了一个 0.1f 作为参数，Glide 将会显示原始图像的10%的大小。</span></span><br><span class="line">                       <span class="comment">//如果原始图像有 1000x1000 像素，那么缩略图将会有 100x100 像素。</span></span><br><span class="line">     .asBitmap()<span class="comment">//显示gif静态图片 </span></span><br><span class="line">     .asGif();<span class="comment">//显示gif动态图片</span></span><br><span class="line">     .into(imageView)；</span><br></pre></td></tr></table></figure>

<h6 id="3、缓存"><a href="#3、缓存" class="headerlink" title="3、缓存"></a>3、缓存</h6><ul>
<li><p>磁盘缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Glide.with(<span class="keyword">this</span>).load(imageUrl).diskCacheStrategy(DiskCacheStrategy.ALL).into(imageView);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存参数说明</span></span><br><span class="line"><span class="comment">// DiskCacheStrategy.NONE：不缓存任何图片，即禁用磁盘缓存</span></span><br><span class="line"><span class="comment">// DiskCacheStrategy.ALL ：缓存原始图片 &amp; 转换后的图片（默认）</span></span><br><span class="line"><span class="comment">// DiskCacheStrategy.SOURCE：只缓存原始图片（原来的全分辨率的图像，即不缓存转换后的图片）</span></span><br><span class="line"><span class="comment">// DiskCacheStrategy.RESULT：只缓存转换后的图片（即最终的图像：降低分辨率后 / 或者转换后 ，不缓存原始图片</span></span><br></pre></td></tr></table></figure></li>
<li><p>跳过内存缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Glide</span><br><span class="line">  .with(<span class="keyword">this</span>)</span><br><span class="line">.load(imageUrl)</span><br><span class="line">.skipMemoryCache(<span class="keyword">true</span>)</span><br><span class="line">.into(imageView);</span><br><span class="line"><span class="comment">//设置跳过内存缓存</span></span><br><span class="line"><span class="comment">//这意味着 Glide 将不会把这张图片放到内存缓存中去</span></span><br><span class="line"><span class="comment">//这里需要明白的是，这只是会影响内存缓存！Glide 将会仍然利用磁盘缓存来避免重复的网络请求。</span></span><br></pre></td></tr></table></figure></li>
<li><p>清理缓存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Glide.get(this).clearDiskCache();//清理磁盘缓存 需要在子线程中执行 </span><br><span class="line">Glide.get(this).clearMemory();//清理内存缓存 可以在UI主线程中进行</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="4、其他相关"><a href="#4、其他相关" class="headerlink" title="4、其他相关"></a>4、其他相关</h6><ul>
<li><p>生命周期集成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.with(Context context)// 绑定Context</span><br><span class="line">.with(Activity activity);// 绑定Activity</span><br><span class="line">.with(FragmentActivity activity);// 绑定FragmentActivity</span><br><span class="line">.with(Fragment fragment);// 绑定Fragment</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ol>
<li>传入的context类型影响到Glide加载图片的优化程度</li>
<li>Glide可以监视Activity的生命周期，在Activity销毁的时候自动取消等待中的请求。但是如果你使用Application context，你就失去了这种优化效果。</li>
</ol>
</blockquote>
</li>
<li><p>设置动态转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Glide.with(<span class="keyword">this</span>).load(imageUrl).centerCrop().into(imageView);</span><br></pre></td></tr></table></figure></li>
<li><p>设置下载优先级</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Glide.with(<span class="keyword">this</span>).load(imageUrl).priority(Priority.NORMAL).into(imageView);</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>用法</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//build.gradle引用</span><br><span class="line">implementation &#x27;com.github.bumptech.glide:glide:4.13.2&#x27;</span><br><span class="line">annotationProcessor &#x27;com.github.bumptech.glide:compiler:4.13.2&#x27;</span><br></pre></td></tr></table></figure>

<p>​</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_glide);</span><br><span class="line">    imageView = (ImageView)findViewById(R.id.image);</span><br><span class="line">    Glide.with(<span class="keyword">this</span>).load(R.drawable.tst).into(imageView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h5><p><code>优点</code></p>
<ul>
<li><p>多样化媒体加载<br>Glide 不仅是一个图片缓存，它支持 Gif、WebP、缩略图。甚至是 Video</p>
</li>
<li><p>生命周期集成<br>通过设置绑定生命周期，我们可以更加高效的使用Glide提供的方式进行绑定，这样可以更好的让加载图片的请求的生命周期动态管理起来</p>
</li>
<li><p>高效的缓存策略<br>A. 支持Memory和Disk图片缓存<br>B. Picasso 只会缓存原始尺寸的图片，而 Glide 缓存的是多种规格，也就意味着 Glide 会根据你 ImageView 的大小来缓存相应大小的图片尺寸</p>
<p>C. 内存开销小<br>默认的 Bitmap 格式是 RGB_565 格式，而 Picasso 默认的是 ARGB_8888 格式，这个内存开销要小一半。</p>
<blockquote>
<p>Android关于图片内存计算，共有四种，分别是：</p>
<p>ALPHA_8：每个像素占用1byte内存<br>ARGB_4444:每个像素占用2byte内存<br>ARGB_8888:每个像素占用4byte内存（默认，色彩最细腻=显示质量最高=占用的内存也最大）<br>RGB_565:每个像素占用2byte内存（8bit = 1byte）<br>举例说明：一个32位的PNG=ARGB_8888=1204x1024,那么占用空间是:1024x1024x(32/8) = 4,194,304kb=4M左右<br>在解析图片的时候，为了避免oom和节省内存，最好使用ARGB_4444模式（节省一半的内存空间）</p>
</blockquote>
</li>
</ul>
<p><code>缺点</code></p>
<ul>
<li>使用方法复杂<br>由于Glide其功能强大，所以使用的方法非常多，其源码也相对的复杂</li>
<li>包较大</li>
</ul>
<h5 id="3、对比"><a href="#3、对比" class="headerlink" title="3、对比"></a>3、对比</h5><ul>
<li>对比Picasso<br>Glide 是在Picasso 基础之上进行的二次开发做了不少改进，不过这也导致包比 Picasso 大不少，不过也就不到 500k（Picasso 是100多k），用法较为复杂，不过毕竟级别还是蛮小的，影响不是很大</li>
<li>对比Fresco<br>使用较Fresco简单，但性能（加载速度 &amp; 缓存）却比不上Fresco</li>
</ul>
<h5 id="4、使用场景"><a href="#4、使用场景" class="headerlink" title="4、使用场景"></a>4、使用场景</h5><ul>
<li>需要更多的内容表现形式(如Gif)；</li>
<li>更高的性能要求（缓存 &amp; 加载速度）；</li>
</ul>
<h5 id="5、源码解析"><a href="#5、源码解析" class="headerlink" title="5、源码解析"></a>5、源码解析</h5><h6 id="with"><a href="#with" class="headerlink" title="with()"></a>with()</h6><p>定义：<code>Glide</code> 类中的静态方法，根据传入 不同参数 进行 方法重载</p>
<p>作用：</p>
<ol>
<li>得到一个<code>RequestManager</code>对象</li>
<li>根据传入<code>with()</code>方法的参数 <strong>将Glide图片加载的生命周期与Activity/Fragment的生命周期进行绑定，从而实现自动执行请求，暂停操作</strong></li>
</ol>
<table>
<thead>
<tr>
<th>对象名</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>RequestManagerFragment</td>
<td>连接生命周期方法</td>
<td></td>
</tr>
<tr>
<td>ReouestlManager</td>
<td>绑定Activity/Fragment生命周期，实现生命周期中请求方法<br><code>（对请求进行暂停，恢复，清除操作）</code></td>
<td>实现LifeCyclelistener接口</td>
</tr>
<tr>
<td>RequesiMansaserRetiever</td>
<td>将RequestManager和自定义Fragment（如RequestMandagerFragment）绑定，从而实现在生命周期管理回调</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Glide</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with()重载种类非常多，根据传入的参数可分为：</span></span><br><span class="line">    <span class="comment">// 1. 非Application类型的参数（Activity &amp; Fragment  ）</span></span><br><span class="line">    <span class="comment">// 2. Application类型的参数（Context）</span></span><br><span class="line">    <span class="comment">// 下面将详细分析</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数1：Application类型</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class="line">        <span class="comment">// 步骤1：调用RequestManagerRetriever类的静态get()获得RequestManagerRetriever对象 - 单例实现</span></span><br><span class="line">        <span class="keyword">return</span> retriever.get(context);</span><br><span class="line">        <span class="comment">// 步骤2：调用RequestManagerRetriever实例的get()获取RequestManager对象 &amp; 绑定图片加载的生命周期 -&gt;&gt;分析1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数2：非Application类型（Activity &amp; Fragment ）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class="line">        <span class="keyword">return</span> retriever.get(activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(Fragment fragment)</span> </span>&#123;</span><br><span class="line">        RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class="line">        <span class="keyword">return</span> retriever.get(fragment);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@TargetApi(Build.VERSION_CODES.HONEYCOMB)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(android.app.Fragment fragment)</span> </span>&#123;</span><br><span class="line">        RequestManagerRetriever retriever = RequestManagerRetriever.get();</span><br><span class="line">        <span class="keyword">return</span> retriever.get(fragment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;-- 分析<span class="number">1</span>：RequestManagerRetriever对象的实例 get（）--&gt;</span><br><span class="line"><span class="comment">// 作用：</span></span><br><span class="line">  <span class="comment">// 1. 获取RequestManager对象</span></span><br><span class="line">  <span class="comment">// 2. 将图片加载的生命周期与Activity/Fragment的生命周期进行绑定</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestManagerRetriever</span> <span class="keyword">implements</span> <span class="title">Handler</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例的get（）重载种类很多，参数分为：（与with（）类似）</span></span><br><span class="line">    <span class="comment">// 1. Application类型（Context）</span></span><br><span class="line">    <span class="comment">// 2. 非Application类型（Activity &amp; Fragment ）- &gt;&gt;分析3</span></span><br><span class="line">    <span class="comment">// 下面会详细分析</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数1：Application类型（Context） </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getApplicationManager(context);</span><br><span class="line">        <span class="comment">// 调用getApplicationManager（）最终获取一个RequestManager对象 -&gt;&gt;分析2</span></span><br><span class="line">        <span class="comment">// 因为Application对象的生命周期即App的生命周期</span></span><br><span class="line">        <span class="comment">// 所以Glide加载图片的生命周期是自动与应用程序的生命周期绑定，不需要做特殊处理（若应用程序关闭，Glide的加载也会终止）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数2：非Application类型（Activity &amp; Fragment  ）</span></span><br><span class="line"><span class="comment">// 将Glide加载图片的生命周期与Activity生命周期同步的具体做法：向当前的Activity添加一个隐藏的Fragment</span></span><br><span class="line"><span class="comment">// 原因：因Fragment的生命周期 与 Activity 的是同步的，通过添加隐藏的Fragment 从而监听Activity的生命周期，从而实现Glide加载图片的生命周期与Activity的生命周期 进行同步。</span></span><br><span class="line"> <span class="meta">@TargetApi(Build.VERSION_CODES.HONEYCOMB)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Util.isOnBackgroundThread() || Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">            <span class="keyword">return</span> get(activity.getApplicationContext());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            assertNotDestroyed(activity);</span><br><span class="line">             <span class="comment">//判断activity是否已经销毁</span></span><br><span class="line"></span><br><span class="line">            android.app.FragmentManager fm = activity.getFragmentManager();</span><br><span class="line">            <span class="comment">// 获取FragmentManager 对象</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> fragmentGet(activity, fm);</span><br><span class="line">           <span class="comment">// 通过fragmentGet返回RequestManager-&gt;&gt;分析4</span></span><br><span class="line">           </span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 逻辑同上，此处不作过多描述</span></span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(Fragment fragment)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 逻辑同上，此处不作过多描述</span></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;-- 分析<span class="number">2</span>：getApplicationManager（context）--&gt;</span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestManager <span class="title">getApplicationManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">        Glide glide = Glide.get(context);</span><br><span class="line">        <span class="comment">// 通过单例模式创建Glide实例 -&gt;&gt;分析3</span></span><br><span class="line">        applicationManager =</span><br><span class="line">            <span class="keyword">new</span> RequestManager(</span><br><span class="line">                glide, <span class="keyword">new</span> ApplicationLifecycle(), <span class="keyword">new</span> EmptyRequestManagerTreeNode());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> applicationManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;-- 分析<span class="number">3</span>：Glide.get(context) --&gt;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Glide <span class="title">get</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (glide == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="comment">// 单例模式的体现</span></span><br><span class="line">    <span class="keyword">synchronized</span> (Glide.class) &#123;</span><br><span class="line">      <span class="keyword">if</span> (glide == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Context applicationContext = context.getApplicationContext();</span><br><span class="line">        </span><br><span class="line">        List&lt;GlideModule&gt; modules = <span class="keyword">new</span> ManifestParser(applicationContext).parse();</span><br><span class="line">        <span class="comment">// 解析清单文件配置的自定义GlideModule的metadata标签，返回一个GlideModule集合</span></span><br><span class="line"></span><br><span class="line">        GlideBuilder builder = <span class="keyword">new</span> GlideBuilder(applicationContext);</span><br><span class="line">        <span class="comment">// 步骤1：创建GlideBuilder对象</span></span><br><span class="line">        <span class="keyword">for</span> (GlideModule <span class="keyword">module</span> : modules) &#123;</span><br><span class="line">          <span class="keyword">module</span>.applyOptions(applicationContext, builder);</span><br><span class="line">        &#125;</span><br><span class="line">        glide = builder.createGlide();</span><br><span class="line">        <span class="comment">// 步骤2：根据GlideBuilder对象创建Glide实例</span></span><br><span class="line">        <span class="comment">// GlideBuilder会为Glide设置一默认配置，如：Engine，RequestOptions，GlideExecutor，MemorySizeCalculator</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span> (GlideModule <span class="keyword">module</span> : modules) &#123;</span><br><span class="line">          <span class="keyword">module</span>.registerComponents(applicationContext, glide.registry);</span><br><span class="line">           <span class="comment">// 步骤3：利用GlideModule 进行延迟性的配置和ModelLoaders的注册</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> glide;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 回到分析1 进入 分析2的地方</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;--分析<span class="number">4</span>：fragmentGet(） --&gt;</span><br><span class="line"><span class="comment">// 作用：</span></span><br><span class="line">           <span class="comment">// 1. 创建Fragment</span></span><br><span class="line">           <span class="comment">// 2. 向当前的Activity中添加一个隐藏的Fragment</span></span><br><span class="line">           <span class="comment">// 3. 将RequestManager与该隐藏的Fragment进行绑定</span></span><br><span class="line"> <span class="function">RequestManager <span class="title">fragmentGet</span><span class="params">(Context context, android.app.FragmentManager fm)</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">        RequestManagerFragment current = getRequestManagerFragment(fm);</span><br><span class="line">        <span class="comment">// 获取RequestManagerFragment</span></span><br><span class="line">        <span class="comment">// 作用：利用Fragment进行请求的生命周期管理 </span></span><br><span class="line"></span><br><span class="line">        RequestManager requestManager = current.getRequestManager();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若requestManager 为空，即首次加载初始化requestManager </span></span><br><span class="line">        <span class="keyword">if</span> (requestManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建RequestManager传入Lifecycle实现类，如ActivityFragmentLifecycle</span></span><br><span class="line">            requestManager = <span class="keyword">new</span> RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode());</span><br><span class="line">            current.setRequestManager(requestManager);</span><br><span class="line">            <span class="comment">// 调用setRequestManager设置到RequestManagerFragment </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> requestManager;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>总结：<code>with（）</code>是为得到一个<code>RequestManager</code>对象 从而将<code>Glide</code>加载图片周期 与<code>Activity</code> 和<code>Fragment</code>进行绑定，从而管理<code>Glide</code>加载图片周期</p>
<h6 id="load"><a href="#load" class="headerlink" title="load()"></a>load()</h6><p>定义：由于 <code>.with()</code> 返回的是一个<code>RequestManager</code>对象，所以 第2步中调用的是 <code>RequestManager</code> 类的 <code>load()</code></p>
<p>作用：预先创建好对图片进行一系列操作（加载、编解码、转码）的对象，并全部封装到 <code>DrawableTypeRequest</code> `对象中。</p>
<blockquote>
<ol>
<li><code>Glide</code> 支持加载 图片的URL字符串、图片本地路径等，因此<code>RequestManager</code> 类 存在<code>load()</code>的重载</li>
<li>此处主要讲解 最常见的加载图片 <code>URL</code> 字符串的<code>load()</code>，即<code>load(String url)</code></li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestManager</span> <span class="keyword">implements</span> <span class="title">LifecycleListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅贴出关键代码</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> DrawableTypeRequest&lt;String&gt; <span class="title">load</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (DrawableTypeRequest&lt;String&gt;) fromString().load(string);</span><br><span class="line">        <span class="comment">// 先调用fromString（）再调用load（）</span></span><br><span class="line">        <span class="comment">// load（）作用：传入图片URL地址</span></span><br><span class="line">       <span class="comment">// fromString（）作用 -&gt;&gt;分析1</span></span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;-- 分析<span class="number">1</span>：fromString（）--&gt;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DrawableTypeRequest&lt;String&gt; <span class="title">fromString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> loadGeneric(String.class);</span><br><span class="line">         <span class="comment">// loadGeneric（）的作用 -&gt;&gt;分析2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;-- 分析<span class="number">2</span>：loadGeneric（）--&gt;</span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">DrawableTypeRequest&lt;T&gt; <span class="title">loadGeneric</span><span class="params">(Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ModelLoader&lt;T, InputStream&gt; streamModelLoader = Glide.buildStreamModelLoader(modelClass, context);</span><br><span class="line">        <span class="comment">// 创建第1个ModelLoader对象；作用：加载图片</span></span><br><span class="line">        <span class="comment">// Glide会根据load()方法传入不同类型参数，得到不同的ModelLoader对象</span></span><br><span class="line">        <span class="comment">// 此处传入参数是String.class，因此得到的是StreamStringLoader对象（实现了ModelLoader接口）</span></span><br><span class="line"></span><br><span class="line">        ModelLoader&lt;T, ParcelFileDescriptor&gt; fileDescriptorModelLoader = Glide.buildFileDescriptorModelLoader(modelClass, context);</span><br><span class="line">         <span class="comment">// 创建第2个ModelLoader对象，作用同上：加载图片</span></span><br><span class="line">        <span class="comment">// 此处得到的是FileDescriptorModelLoader对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> optionsApplier.apply(</span><br><span class="line">                <span class="keyword">new</span> DrawableTypeRequest&lt;T&gt;(modelClass, streamModelLoader, fileDescriptorModelLoader, context,</span><br><span class="line">                        glide, requestTracker, lifecycle, optionsApplier));</span><br><span class="line">            <span class="comment">// 创建DrawableTypeRequest对象 &amp; 传入刚才创建的ModelLoader对象 和 其他初始化配置的参数</span></span><br><span class="line">            <span class="comment">// DrawableTypeRequest类分析 -&gt;&gt;分析3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;-- 分析<span class="number">3</span>：DrawableTypeRequest类（）--&gt;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawableTypeRequest</span>&lt;<span class="title">ModelType</span>&gt; <span class="keyword">extends</span> <span class="title">DrawableRequestBuilder</span>&lt;<span class="title">ModelType</span>&gt; <span class="keyword">implements</span> <span class="title">DownloadOptions</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关注1：构造方法</span></span><br><span class="line">      DrawableTypeRequest(Class&lt;ModelType&gt; modelClass, ModelLoader&lt;ModelType, InputStream&gt; streamModelLoader,</span><br><span class="line">            ModelLoader&lt;ModelType, ParcelFileDescriptor&gt; fileDescriptorModelLoader, Context context, Glide glide,</span><br><span class="line">            RequestTracker requestTracker, Lifecycle lifecycle, RequestManager.OptionsApplier optionsApplier) &#123;</span><br><span class="line">        <span class="keyword">super</span>(context, modelClass,</span><br><span class="line">                buildProvider(glide, streamModelLoader, fileDescriptorModelLoader, GifBitmapWrapper.class,</span><br><span class="line">                        GlideDrawable.class, <span class="keyword">null</span>),</span><br><span class="line">                glide, requestTracker, lifecycle);</span><br><span class="line">      <span class="comment">// 调用buildProvider()方法 --&gt;分析4</span></span><br><span class="line">      <span class="comment">// 并把上述创建的streamModelLoader和fileDescriptorModelLoader等参数传入到buildProvider()中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关注2：DrawableTypeRequest类主要提供2个方法： asBitmap() &amp; asGif() </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// asBitmap()作用：强制加载 静态图片</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BitmapTypeRequest&lt;ModelType&gt; <span class="title">asBitmap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> optionsApplier.apply(<span class="keyword">new</span> BitmapTypeRequest&lt;ModelType&gt;(<span class="keyword">this</span>, streamModelLoader,</span><br><span class="line">                fileDescriptorModelLoader, optionsApplier));</span><br><span class="line">        <span class="comment">// 创建BitmapTypeRequest对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// asGif() 作用：强制加载 动态图片</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GifTypeRequest&lt;ModelType&gt; <span class="title">asGif</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> optionsApplier.apply(<span class="keyword">new</span> GifTypeRequest&lt;ModelType&gt;(<span class="keyword">this</span>, streamModelLoader, optionsApplier));</span><br><span class="line">        <span class="comment">// 创建GifTypeRequest对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注：若没指定，则默认使用DrawableTypeRequest</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;-- 分析<span class="number">4</span>：buildProvider(）--&gt;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;A, Z, R&gt; <span class="function">FixedLoadProvider&lt;A, ImageVideoWrapper, Z, R&gt; <span class="title">buildProvider</span><span class="params">(Glide glide,</span></span></span><br><span class="line"><span class="params"><span class="function">            ModelLoader&lt;A, InputStream&gt; streamModelLoader,</span></span></span><br><span class="line"><span class="params"><span class="function">            ModelLoader&lt;A, ParcelFileDescriptor&gt; fileDescriptorModelLoader, Class&lt;Z&gt; resourceClass,</span></span></span><br><span class="line"><span class="params"><span class="function">            Class&lt;R&gt; transcodedClass,</span></span></span><br><span class="line"><span class="params"><span class="function">            ResourceTranscoder&lt;Z, R&gt; transcoder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (transcoder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            transcoder = glide.buildTranscoder(resourceClass, transcodedClass);</span><br><span class="line">            <span class="comment">// 创建GifBitmapWrapperDrawableTranscoder对象（实现了ResourceTranscoder接口）</span></span><br><span class="line">            <span class="comment">// 作用：对图片进行转码</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DataLoadProvider&lt;ImageVideoWrapper, Z&gt; dataLoadProvider = glide.buildDataProvider(ImageVideoWrapper.class,</span><br><span class="line">                resourceClass);</span><br><span class="line">        <span class="comment">// 创建ImageVideoGifDrawableLoadProvider对象（实现了DataLoadProvider接口）</span></span><br><span class="line">        <span class="comment">// 作用：对图片进行编解码</span></span><br><span class="line"></span><br><span class="line">        ImageVideoModelLoader&lt;A&gt; modelLoader = <span class="keyword">new</span> ImageVideoModelLoader&lt;A&gt;(streamModelLoader,</span><br><span class="line">                fileDescriptorModelLoader);</span><br><span class="line">        <span class="comment">// 创建ImageVideoModelLoader</span></span><br><span class="line">        <span class="comment">// 并把上面创建的两个ModelLoader：streamModelLoader和fileDescriptorModelLoader封装到了ImageVideoModelLoader中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FixedLoadProvider&lt;A, ImageVideoWrapper, Z, R&gt;(modelLoader, transcoder, dataLoadProvider);</span><br><span class="line">       <span class="comment">// 创建FixedLoadProvider对象</span></span><br><span class="line">       <span class="comment">// 把上面创建的GifBitmapWrapperDrawableTranscoder、ImageVideoModelLoader、ImageVideoGifDrawableLoadProvider都封装进去</span></span><br><span class="line">      <span class="comment">// 注：FixedLoadProvider对象就是第3步into（）中onSizeReady()的loadProvider对象</span></span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 回到分析3的关注点2</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>在<code>RequestManager</code>的<code>load()</code>中，通过<code>fromString()</code>最终返回一个<code>DrawableTypeRequest</code>对象，并调用该对象的<code>load()</code> 传入图片的URL地址</p>
</li>
<li><p>但从上面的分析3可看出，<code>DrawableTypeRequest</code>类中并没有<code>load()</code>和第3步需要分析的<code>into（）</code>，所以<code>load()</code> 和 <code>into（）</code> 是在<code>DrawableTypeRequest</code>类的父类中：<code>DrawableRequestBuilder</code>类中。继承关系如下：</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/e6ae59d2ec5e1368fad1a971e89b72d3.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawableRequestBuilder</span>&lt;<span class="title">ModelType</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">GenericRequestBuilder</span>&lt;<span class="title">ModelType</span>, <span class="title">ImageVideoWrapper</span>, <span class="title">GifBitmapWrapper</span>, <span class="title">GlideDrawable</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BitmapOptions</span>, <span class="title">DrawableOptions</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ... </span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终load()方法返回的其实就是一个DrawableTypeRequest对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Target&lt;GlideDrawable&gt; <span class="title">into</span><span class="params">(ImageView view)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.into(view);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特别注意：DrawableRequestBuilder类中有很多使用Glide的API方法，此处不做过多描述</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：<code>load（）</code>中预先创建好对图片进行一系列操作（加载、编解码、转码）的对象，并全部封装到 <code>DrawableTypeRequest</code>对象中。</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/a06a17ea4d3f8e2e45e0dc1cb108e60c.png" alt="img"></p>
<h6 id="into（）"><a href="#into（）" class="headerlink" title="into（）"></a>into（）</h6><p>作用：构建网络请求对象 并 执行 该网络请求（即 获取图片资源 &amp; 加载图片并显示）</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/2bb5c51efa246b068662038443091719.png" alt="img"></p>
<h3 id="网络请求库"><a href="#网络请求库" class="headerlink" title="网络请求库"></a>网络请求库</h3><h4 id="1、为什么使用网络请求库"><a href="#1、为什么使用网络请求库" class="headerlink" title="1、为什么使用网络请求库"></a>1、为什么使用网络请求库</h4><ul>
<li>因为Android的主线程不能进行网络请求，需另开1个线程请求、考虑到线程池,缓存等一堆问题</li>
</ul>
<h4 id="2、Android网络主流方式"><a href="#2、Android网络主流方式" class="headerlink" title="2、Android网络主流方式"></a>2、Android网络主流方式</h4><table>
<thead>
<tr>
<th>类型</th>
<th>简介</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>HttpURLConnection</td>
<td>Androd2.2前；有个重大Bug，即调用close0函数会影响连接池，导致连接复用失效<br>Android2.2后：默认开启了gzip压缩&amp;提高了HTTPS的性能</td>
<td>Android22前不建议使用HtpURLComection Android 4.4后，底层实现已被OkHttp替换</td>
</tr>
<tr>
<td>HtttpClient</td>
<td>优点：相比于HttpURLConmection，更加高效简洁·<br>缺点：结构过于复杂，维护成本高</td>
<td>Android5.0后被Androd官方弃用</td>
</tr>
</tbody></table>
<p><strong>网络请求库与Android网络请求方法联系</strong>？</p>
<ul>
<li>网络请求库本质=<code>封装了网络请求+异步+数据处理</code>功能的库</li>
<li>网络请求功能采用<code>Android</code>网络请求的原生方法（HttpURLConnection 、HtttpClient ）</li>
</ul>
<h4 id="3、网络请求库"><a href="#3、网络请求库" class="headerlink" title="3、网络请求库"></a>3、网络请求库</h4><p>使用情况：</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220902080958566.png" alt="image-20220902080958566"></p>
<p>对比</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220902081225827.png" alt="image-20220902081225827"></p>
<h5 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h5><table>
<thead>
<tr>
<th>定义</th>
<th>一个RESTful的HTTP网络请求框架（基于OkHttp）</th>
</tr>
</thead>
<tbody><tr>
<td>功能</td>
<td>·基于OkHttp&amp;遵循Restful APl设计风格<br/>·通过注解配置网络请求参数<br/>·支持同步&amp;异步网络请求<br/>·支持多种数据的解析&amp;序列化格式（Gson、Json、XML、Protobuf）<br/>·提供对RxJava支持</td>
</tr>
<tr>
<td>优点</td>
<td>·功能强大：支持同步&amp;异步、支持多种数据的解析&amp;序列化格式、支持RxJava<br>·简洁易用：通过注解配置网络请求参数、采用大量设计模式简化使用<br>·可拓展性好：功能模块高度封装、解耦彻底，如自定义Converters等等</td>
</tr>
<tr>
<td>应用场景</td>
<td>任何网络请求的需求场景都应优先选择<br>(<code>特别是后台AP通循Resttu A1设计风格&amp;项目中使用到RxJava）</code></td>
</tr>
</tbody></table>
<blockquote>
<p>特别注意：</p>
<p>准确来说，<strong>Retrofit 是一个 RESTful 的 HTTP 网络请求框架的封装。</strong></p>
<p>原因：网络请求的工作本质上是 OkHttp 完成，而 Retrofit 仅负责 网络请求接口的封装</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/e5bcf132aa733d34cacb091cb17eeaa2.png" alt="img"></p>
<p>App应用程序通过 Retrofit 请求网络，实际上是使用 Retrofit 接口层封装请求参数、Header、Url 等信息，之后由 OkHttp 完成后续的请求操作</p>
<p>在服务端返回数据之后，OkHttp 将原始的结果交给 Retrofit，Retrofit根据用户的需求对结果进行解析</p>
</blockquote>
<h6 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong><code>使用方法</code></strong></h6><ol>
<li><p>添加Retrofit库的依赖</p>
</li>
<li><p>创建 接收服务器返回数据 的类</p>
</li>
<li><p>创建 用于描述网络请求 的接口</p>
</li>
<li><p>创建 Retrofit 实例</p>
</li>
<li><p>创建 网络请求接口实例 并 配置网络请求参数</p>
</li>
<li><p>发送网络请求（异步 / 同步）</p>
<blockquote>
<p>封装了 数据转换、线程切换的操作</p>
</blockquote>
</li>
<li><p>处理服务器返回的数据</p>
</li>
</ol>
<h6 id="1、添加Retrofit库的依赖"><a href="#1、添加Retrofit库的依赖" class="headerlink" title="1、添加Retrofit库的依赖"></a>1、添加Retrofit库的依赖</h6><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//build.gradle</span></span><br><span class="line">implementation <span class="string">&#x27;com.squareup.retrofit2:retrofit:2.9.0&#x27;</span></span><br></pre></td></tr></table></figure>

<p>添加网络权限</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="2、创建-接收服务器返回数据-的类"><a href="#2、创建-接收服务器返回数据-的类" class="headerlink" title="2、创建 接收服务器返回数据 的类"></a>2、创建 接收服务器返回数据 的类</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Reception.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reception</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 根据返回数据的格式和数据解析方式（Json、XML等）定义</span></span><br><span class="line">    <span class="comment">// 下面会在实例进行说明</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h6 id="3、创建-用于描述网络请求-的接口"><a href="#3、创建-用于描述网络请求-的接口" class="headerlink" title="3、创建 用于描述网络请求 的接口"></a>3、创建 用于描述网络请求 的接口</h6><ul>
<li>Retrofit将 Http请求 抽象成 Java接口：采用 <strong>注解</strong> 描述网络请求参数 和配置网络请求参数</li>
</ul>
<blockquote>
<ol>
<li>用 动态代理 动态 将该接口的注解“翻译”成一个 Http 请求，最后再执行 Http 请求</li>
<li>注：接口中的每个方法的参数都需要使用注解标注，否则会报错</li>
</ol>
</blockquote>
<p>​</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//GetRequest_Interface.interface</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GetRequest_Interface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET(&quot;openapi.do?keyfrom=Yanzhikai&amp;key=2032414398&amp;type=data&amp;doctype=json&amp;version=1.1&amp;q=car&quot;)</span></span><br><span class="line">    <span class="function">Call&lt;Translation&gt;  <span class="title">getCall</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// @GET注解的作用:采用Get方法发送网络请求</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// getCall() = 接收网络请求数据的方法</span></span><br><span class="line">    <span class="comment">// 其中返回类型为Call&lt;*&gt;，*是接收数据的类（即上面定义的Translation类）</span></span><br><span class="line">    <span class="comment">// 如果想直接获得Responsebody中的内容，可以定义网络请求返回值为Call&lt;ResponseBody&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​          <strong>注解类型</strong></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/df2f0197ea4e18f40893fd668af1a35a.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/46938759db21ff43e90220d4025f3408.png" alt="img"></p>
<ol>
<li><p>网络请求方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GetRequest_Interface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET(&quot;openapi.do?keyfrom=Yanzhikai&amp;key=2032414398&amp;type=data&amp;doctype=json&amp;version=1.1&amp;q=car&quot;)</span></span><br><span class="line">    <span class="function">Call&lt;Translation&gt;  <span class="title">getCall</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// @GET注解的作用:采用Get方法发送网络请求</span></span><br><span class="line">    <span class="comment">// getCall() = 接收网络请求数据的方法</span></span><br><span class="line">    <span class="comment">// 其中返回类型为Call&lt;*&gt;，*是接收数据的类（即上面定义的Translation类）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>URL的组成：Retrofit把 网络请求的URL 分成了两部分设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第1部分：在网络请求接口的注解设置</span></span><br><span class="line"> <span class="meta">@GET(&quot;openapi.do?keyfrom=Yanzhikai&amp;key=2032414398&amp;type=data&amp;doctype=json&amp;version=1.1&amp;q=car&quot;)</span></span><br><span class="line"><span class="function">Call&lt;Translation&gt;  <span class="title">getCall</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第2部分：在创建Retrofit实例时通过.baseUrl()设置</span></span><br><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">                .baseUrl(<span class="string">&quot;http://fanyi.youdao.com/&quot;</span>) <span class="comment">//设置网络请求的Url地址</span></span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create()) <span class="comment">//设置数据解析器</span></span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从上面看出：一个请求的URL可以通过 替换块 和 请求方法的参数 来进行动态的URL更新。</span></span><br><span class="line"><span class="comment">// 替换块是由 被&#123;&#125;包裹起来的字符串构成</span></span><br><span class="line"><span class="comment">// 即：Retrofit支持动态改变网络请求根目录</span></span><br></pre></td></tr></table></figure>

<p>网络请求的完整 Url =在创建Retrofit实例时通过.baseUrl()设置 +网络请求接口的注解设置（下面称 “path“ ）</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/7ea5deecbd4321f7e124229c7015bdd8.png" alt="img"></p>
<p><strong><code>@http</code></strong></p>
<ul>
<li>作用：替换**@GET、@POST、@PUT、@DELETE、@HEAD**注解的作用 及 更多功能拓展</li>
<li>具体使用：通过属性<strong>method、path、hasBody</strong>进行设置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GetRequest_Interface</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * method：网络请求的方法（区分大小写）</span></span><br><span class="line"><span class="comment">     * path：网络请求地址路径</span></span><br><span class="line"><span class="comment">     * hasBody：是否有请求体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@HTTP(method = &quot;GET&quot;, path = &quot;blog/&#123;id&#125;&quot;, hasBody = false)</span></span><br><span class="line">    <span class="function">Call&lt;ResponseBody&gt; <span class="title">getCall</span><span class="params">(<span class="meta">@Path(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    <span class="comment">// &#123;id&#125; 表示是一个变量</span></span><br><span class="line">    <span class="comment">// method 的值 retrofit 不会做处理，所以要自行保证准确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="2">
<li><p>标记类</p>
<ul>
<li><p>@FormUrlEncoded</p>
<blockquote>
<p>表示发送form-encoded的数据</p>
<p>每个键值对需要用@Filed来注解键名，随后的对象需要提供值。</p>
</blockquote>
</li>
<li><p>@Multipart</p>
<blockquote>
<p>作用：表示发送form-encoded的数据（适用于 有文件 上传的场景）</p>
<p>每个键值对需要用@Part来注解键名，随后的对象需要提供值。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GetRequest_Interface</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *表明是一个表单格式的请求（Content-Type:application/x-www-form-urlencoded）</span></span><br><span class="line"><span class="comment">         * &lt;code&gt;Field(&quot;username&quot;)&lt;/code&gt; 表示将后面的 &lt;code&gt;String name&lt;/code&gt; 中name的取值作为 username 的值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@POST(&quot;/form&quot;)</span></span><br><span class="line">        <span class="meta">@FormUrlEncoded</span></span><br><span class="line">        <span class="function">Call&lt;ResponseBody&gt; <span class="title">testFormUrlEncoded1</span><span class="params">(<span class="meta">@Field(&quot;username&quot;)</span> String name, <span class="meta">@Field(&quot;age&quot;)</span> <span class="keyword">int</span> age)</span></span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> Part&#125; 后面支持三种类型，&#123;<span class="doctag">@link</span> RequestBody&#125;、&#123;<span class="doctag">@link</span> okhttp3.MultipartBody.Part&#125; 、任意类型</span></span><br><span class="line"><span class="comment">         * 除 &#123;<span class="doctag">@link</span> okhttp3.MultipartBody.Part&#125; 以外，其它类型都必须带上表单字段(&#123;<span class="doctag">@link</span> okhttp3.MultipartBody.Part&#125; 中已经包含了表单字段的信息)，</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@POST(&quot;/form&quot;)</span></span><br><span class="line">        <span class="meta">@Multipart</span></span><br><span class="line">        <span class="function">Call&lt;ResponseBody&gt; <span class="title">testFileUpload1</span><span class="params">(<span class="meta">@Part(&quot;name&quot;)</span> RequestBody name, <span class="meta">@Part(&quot;age&quot;)</span> RequestBody age, <span class="meta">@Part</span> MultipartBody.Part file)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体使用</span></span><br><span class="line">       GetRequest_Interface service = retrofit.create(GetRequest_Interface.class);</span><br><span class="line">        <span class="comment">// @FormUrlEncoded </span></span><br><span class="line">        Call&lt;ResponseBody&gt; call1 = service.testFormUrlEncoded1(<span class="string">&quot;Carson&quot;</span>, <span class="number">24</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  @Multipart</span></span><br><span class="line">        RequestBody name = RequestBody.create(textType, <span class="string">&quot;Carson&quot;</span>);</span><br><span class="line">        RequestBody age = RequestBody.create(textType, <span class="string">&quot;24&quot;</span>);</span><br><span class="line"></span><br><span class="line">        MultipartBody.Part filePart = MultipartBody.Part.createFormData(<span class="string">&quot;file&quot;</span>, <span class="string">&quot;test.txt&quot;</span>, file);</span><br><span class="line">        Call&lt;ResponseBody&gt; call3 = service.testFileUpload1(name, age, filePart);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="3">
<li><p>网络请求参数</p>
<ul>
<li><p>@Header &amp; @Headers</p>
<p>作用：添加请求头 &amp;添加不固定的请求头</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Header</span></span><br><span class="line"><span class="meta">@GET(&quot;user&quot;)</span></span><br><span class="line"><span class="function">Call&lt;User&gt; <span class="title">getUser</span><span class="params">(<span class="meta">@Header(&quot;Authorization&quot;)</span> String authorization)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// @Headers</span></span></span><br><span class="line"><span class="function">@<span class="title">Headers</span><span class="params">(<span class="string">&quot;Authorization: authorization&quot;</span>)</span></span></span><br><span class="line"><span class="function">@<span class="title">GET</span><span class="params">(<span class="string">&quot;user&quot;</span>)</span></span></span><br><span class="line"><span class="function">Call&lt;User&gt; <span class="title">getUser</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 以上的效果是一致的。</span></span></span><br><span class="line"><span class="function"><span class="comment">// 区别在于使用场景和使用方式</span></span></span><br><span class="line"><span class="function"><span class="comment">// 1. 使用场景：@Header用于添加不固定的请求头，@Headers用于添加固定的请求头</span></span></span><br><span class="line"><span class="function"><span class="comment">// 2. 使用方式：@Header作用于方法的参数；@Headers作用于方法</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ul>
<li><p>@Body</p>
<p>作用：以 Post方式 传递 自定义数据类型 给服务器<br>特别注意：如果提交的是一个Map，那么作用相当于 @Field</p>
<blockquote>
<p>不过Map要经过 <code>FormBody.Builder</code> 类处理成为符合 Okhttp 格式的表单，如：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FormBody.Builder builder = <span class="keyword">new</span> FormBody.Builder();</span><br><span class="line">builder.add(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>@Field &amp; @FieldMap</p>
<p>作用：发送 Post请求 时提交请求的表单字段<br>具体使用：与 @FormUrlEncoded 注解配合使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GetRequest_Interface</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *表明是一个表单格式的请求（Content-Type:application/x-www-form-urlencoded）</span></span><br><span class="line"><span class="comment">         * &lt;code&gt;Field(&quot;username&quot;)&lt;/code&gt; 表示将后面的 &lt;code&gt;String name&lt;/code&gt; 中name的取值作为 username 的值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@POST(&quot;/form&quot;)</span></span><br><span class="line">        <span class="meta">@FormUrlEncoded</span></span><br><span class="line">        <span class="function">Call&lt;ResponseBody&gt; <span class="title">testFormUrlEncoded1</span><span class="params">(<span class="meta">@Field(&quot;username&quot;)</span> String name, <span class="meta">@Field(&quot;age&quot;)</span> <span class="keyword">int</span> age)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Map的key作为表单的键</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@POST(&quot;/form&quot;)</span></span><br><span class="line">        <span class="meta">@FormUrlEncoded</span></span><br><span class="line">        <span class="function">Call&lt;ResponseBody&gt; <span class="title">testFormUrlEncoded2</span><span class="params">(<span class="meta">@FieldMap</span> Map&lt;String, Object&gt; map)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体使用</span></span><br><span class="line">         <span class="comment">// @Field</span></span><br><span class="line">        Call&lt;ResponseBody&gt; call1 = service.testFormUrlEncoded1(<span class="string">&quot;Carson&quot;</span>, <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// @FieldMap</span></span><br><span class="line">        <span class="comment">// 实现的效果与上面相同，但要传入Map</span></span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;Carson&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>, <span class="number">24</span>);</span><br><span class="line">        Call&lt;ResponseBody&gt; call2 = service.testFormUrlEncoded2(map);</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>@Part &amp; @PartMap</p>
<p>作用：发送 Post请求 时提交请求的表单字段</p>
<blockquote>
<p>与@Field的区别：功能相同，但携带的参数类型更加丰富，包括数据流，所以适用于 有文件上传 的场景</p>
<p>与 <code>@Multipart</code> 注解配合使用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GetRequest_Interface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> Part&#125; 后面支持三种类型，&#123;<span class="doctag">@link</span> RequestBody&#125;、&#123;<span class="doctag">@link</span> okhttp3.MultipartBody.Part&#125; 、任意类型</span></span><br><span class="line"><span class="comment">         * 除 &#123;<span class="doctag">@link</span> okhttp3.MultipartBody.Part&#125; 以外，其它类型都必须带上表单字段(&#123;<span class="doctag">@link</span> okhttp3.MultipartBody.Part&#125; 中已经包含了表单字段的信息)，</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@POST(&quot;/form&quot;)</span></span><br><span class="line">        <span class="meta">@Multipart</span></span><br><span class="line">        <span class="function">Call&lt;ResponseBody&gt; <span class="title">testFileUpload1</span><span class="params">(<span class="meta">@Part(&quot;name&quot;)</span> RequestBody name, <span class="meta">@Part(&quot;age&quot;)</span> RequestBody age, <span class="meta">@Part</span> MultipartBody.Part file)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * PartMap 注解支持一个Map作为参数，支持 &#123;<span class="doctag">@link</span> RequestBody &#125; 类型，</span></span><br><span class="line"><span class="comment">         * 如果有其它的类型，会被&#123;<span class="doctag">@link</span> retrofit2.Converter&#125;转换，如后面会介绍的 使用&#123;<span class="doctag">@link</span> com.google.gson.Gson&#125; 的 &#123;<span class="doctag">@link</span> retrofit2.converter.gson.GsonRequestBodyConverter&#125;</span></span><br><span class="line"><span class="comment">         * 所以&#123;<span class="doctag">@link</span> MultipartBody.Part&#125; 就不适用了,所以文件只能用&lt;b&gt; <span class="doctag">@Part</span> MultipartBody.Part &lt;/b&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@POST(&quot;/form&quot;)</span></span><br><span class="line">        <span class="meta">@Multipart</span></span><br><span class="line">        <span class="function">Call&lt;ResponseBody&gt; <span class="title">testFileUpload2</span><span class="params">(<span class="meta">@PartMap</span> Map&lt;String, RequestBody&gt; args, <span class="meta">@Part</span> MultipartBody.Part file)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@POST(&quot;/form&quot;)</span></span><br><span class="line">        <span class="meta">@Multipart</span></span><br><span class="line">        <span class="function">Call&lt;ResponseBody&gt; <span class="title">testFileUpload3</span><span class="params">(<span class="meta">@PartMap</span> Map&lt;String, RequestBody&gt; args)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体使用</span></span><br><span class="line"> MediaType textType = MediaType.parse(<span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">        RequestBody name = RequestBody.create(textType, <span class="string">&quot;Carson&quot;</span>);</span><br><span class="line">        RequestBody age = RequestBody.create(textType, <span class="string">&quot;24&quot;</span>);</span><br><span class="line">        RequestBody file = RequestBody.create(MediaType.parse(<span class="string">&quot;application/octet-stream&quot;</span>), <span class="string">&quot;这里是模拟文件的内容&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// @Part</span></span><br><span class="line">        MultipartBody.Part filePart = MultipartBody.Part.createFormData(<span class="string">&quot;file&quot;</span>, <span class="string">&quot;test.txt&quot;</span>, file);</span><br><span class="line">        Call&lt;ResponseBody&gt; call3 = service.testFileUpload1(name, age, filePart);</span><br><span class="line">        ResponseBodyPrinter.printResponseBody(call3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// @PartMap</span></span><br><span class="line">        <span class="comment">// 实现和上面同样的效果</span></span><br><span class="line">        Map&lt;String, RequestBody&gt; fileUpload2Args = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        fileUpload2Args.put(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">        fileUpload2Args.put(<span class="string">&quot;age&quot;</span>, age);</span><br><span class="line">        <span class="comment">//这里并不会被当成文件，因为没有文件名(包含在Content-Disposition请求头中)，但上面的 filePart 有</span></span><br><span class="line">        <span class="comment">//fileUpload2Args.put(&quot;file&quot;, file);</span></span><br><span class="line">        Call&lt;ResponseBody&gt; call4 = service.testFileUpload2(fileUpload2Args, filePart); <span class="comment">//单独处理文件</span></span><br><span class="line">        ResponseBodyPrinter.printResponseBody(call4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>@Query和@QueryMap</p>
<p>作用：用于 @GET 方法的查询参数（Query = Url 中 ‘?’ 后面的 key-value）</p>
<blockquote>
<p>如：url = <a href="http://www.println.net/?cate=android%EF%BC%8C%E5%85%B6%E4%B8%AD%EF%BC%8CQuery">http://www.println.net/?cate=android，其中，Query</a> = cate</p>
<p>配置时只需要在接口方法中增加一个参数即可：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@GET(&quot;/&quot;)</span>    </span><br><span class="line">   <span class="function">Call&lt;String&gt; <span class="title">cate</span><span class="params">(<span class="meta">@Query(&quot;cate&quot;)</span> String cate)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其使用方式同 @Field与@FieldMap，这里不作过多描述</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>@Path</p>
<p>作用：URL地址的缺省值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GetRequest_Interface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@GET(&quot;users/&#123;user&#125;/repos&quot;)</span></span><br><span class="line">        Call&lt;ResponseBody&gt;  getBlog（<span class="meta">@Path(&quot;user&quot;)</span> String user ）;</span><br><span class="line">        <span class="comment">// 访问的API是：https://api.github.com/users/&#123;user&#125;/repos</span></span><br><span class="line">        <span class="comment">// 在发起请求时， &#123;user&#125; 会被替换为方法的第一个参数 user（被@Path注解作用）</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>@Url</p>
<p>作用：直接传入一个请求的 URL变量 用于URL设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GetRequest_Interface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@GET</span></span><br><span class="line">        <span class="function">Call&lt;ResponseBody&gt; <span class="title">testUrlAndQuery</span><span class="params">(<span class="meta">@Url</span> String url, <span class="meta">@Query(&quot;showAll&quot;)</span> <span class="keyword">boolean</span> showAll)</span></span>;</span><br><span class="line">       <span class="comment">// 当有URL注解时，@GET传入的URL就可以省略</span></span><br><span class="line">       <span class="comment">// 当GET、POST...HTTP等方法中没有设置Url时，则必须使用 &#123;@link Url&#125;提供</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="4、创建-Retrofit-实例"><a href="#4、创建-Retrofit-实例" class="headerlink" title="4、创建 Retrofit 实例"></a>4、创建 Retrofit 实例</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">               .baseUrl(<span class="string">&quot;http://fanyi.youdao.com/&quot;</span>) <span class="comment">// 设置网络请求的Url地址</span></span><br><span class="line">               .addConverterFactory(GsonConverterFactory.create()) <span class="comment">// 设置数据解析器</span></span><br><span class="line">               .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) <span class="comment">// 支持RxJava平台</span></span><br><span class="line">               .build();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>数据解析器（Converter）</p>
<p>Retrofit支持多种数据解析方式</p>
<p><a href="https://s01.oss.sonatype.org/content/repositories/snapshots/com/squareup/retrofit2/">Index of /repositories/snapshots/com/squareup/retrofit2 (sonatype.org)</a></p>
<table>
<thead>
<tr>
<th>数据解析器</th>
<th>Gradle依赖</th>
</tr>
</thead>
<tbody><tr>
<td>Gson</td>
<td>com.squareup.retrofit2:converter-gson:2.10.0</td>
</tr>
<tr>
<td>Jackson</td>
<td>com.squareup.retrofit2:converter-jackson:2.10.0</td>
</tr>
<tr>
<td>Simple XML</td>
<td>com.squareup.retrofit2:converter-simplexml:2.10.0</td>
</tr>
<tr>
<td>Protobuf</td>
<td>com.squareup.retrofit2:converter-protobuf:2.10.0</td>
</tr>
<tr>
<td>Moshi</td>
<td>com.squareup.retrofit2:converter-moshi:2.10.0</td>
</tr>
<tr>
<td>Wire</td>
<td>com.squareup.retrofit2:converter-wire:2.10.0</td>
</tr>
<tr>
<td>Scalars</td>
<td>com.squareup.retrofit2:converter-scalars:2.10.0</td>
</tr>
</tbody></table>
</li>
<li><p>网络请求适配器（CallAdapter）</p>
<p>Retrofit支持多种网络请求适配器方式：guava、Java8和rxjava</p>
<blockquote>
<p>使用时如使用的是 <code>Android</code> 默认的 <code>CallAdapter</code>，则不需要添加网络请求适配器的依赖，否则则需要按照需求进行添加<br>Retrofit 提供的 <code>CallAdapter</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>网络请求适配器</th>
<th>Gradle依赖</th>
</tr>
</thead>
<tbody><tr>
<td>guava</td>
<td>com.squareup.retrofit2:adapter-guava:2.0.2</td>
</tr>
<tr>
<td>Java8</td>
<td>com.squareup.retrofit2:adapter-java8:2.0.2</td>
</tr>
<tr>
<td>rxjava</td>
<td>com.squareup.retrofit2:adapter-rxjava:2.0.2</td>
</tr>
</tbody></table>
</li>
</ul>
<h6 id="5、网络请求接口实例"><a href="#5、网络请求接口实例" class="headerlink" title="5、网络请求接口实例"></a>5、网络请求接口实例</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 网络请求接口 的实例</span></span><br><span class="line">GetRequest_Interface request = retrofit.create(GetRequest_Interface.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对 发送请求 进行封装</span></span><br><span class="line">Call&lt;Reception&gt; call = request.getCall();</span><br></pre></td></tr></table></figure>

<h6 id="6、发送网络请求（异步-同步）"><a href="#6、发送网络请求（异步-同步）" class="headerlink" title="6、发送网络请求（异步 / 同步）"></a>6、发送网络请求（异步 / 同步）</h6><blockquote>
<p>封装了 数据转换、线程切换的操作</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送网络请求(异步)</span></span><br><span class="line">        call.enqueue(<span class="keyword">new</span> Callback&lt;Translation&gt;() &#123;</span><br><span class="line">            <span class="comment">//请求成功时回调</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;Translation&gt; call, Response&lt;Translation&gt; response)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//请求处理,输出结果</span></span><br><span class="line">                response.body().show();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//请求失败时候的回调</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;Translation&gt; call, Throwable throwable)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;连接失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送网络请求（同步）</span></span><br><span class="line">Response&lt;Reception&gt; response = call.execute();</span><br></pre></td></tr></table></figure>

<h6 id="6、数据处理"><a href="#6、数据处理" class="headerlink" title="6、数据处理"></a>6、数据处理</h6><p>通过<code>response</code>类的 <code>body（）</code>对返回的数据进行处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送网络请求(异步)</span></span><br><span class="line">        call.enqueue(<span class="keyword">new</span> Callback&lt;Translation&gt;() &#123;</span><br><span class="line">            <span class="comment">//请求成功时回调</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;Translation&gt; call, Response&lt;Translation&gt; response)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 对返回数据进行处理</span></span><br><span class="line">                response.body().show();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//请求失败时候的回调</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;Translation&gt; call, Throwable throwable)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;连接失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送网络请求（同步）</span></span><br><span class="line">  Response&lt;Reception&gt; response = call.execute();</span><br><span class="line">  <span class="comment">// 对返回数据进行处理</span></span><br><span class="line">  response.body().show();</span><br></pre></td></tr></table></figure>

<h4 id="4、实例"><a href="#4、实例" class="headerlink" title="4、实例"></a>4、实例</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">implementation &#x27;com.squareup.retrofit2:retrofit:2.9.0&#x27;</span><br><span class="line">implementation &#x27;com.squareup.retrofit2:converter-gson:2.6.1&#x27;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.retrofit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> retrofit2.Call;</span><br><span class="line"><span class="keyword">import</span> retrofit2.http.Field;</span><br><span class="line"><span class="keyword">import</span> retrofit2.http.FormUrlEncoded;</span><br><span class="line"><span class="keyword">import</span> retrofit2.http.POST;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GetRequest_Interface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@POST(&quot;translate?doctype=json&amp;jsonversion=&amp;type=&amp;keyfrom=&amp;model=&amp;mid=&amp;imei=&amp;vendor=&amp;screen=&amp;ssid=&amp;network=&amp;abtest=&quot;)</span></span><br><span class="line">    <span class="meta">@FormUrlEncoded</span></span><br><span class="line">    <span class="function">Call&lt;Translation&gt; <span class="title">getCall</span><span class="params">(<span class="meta">@Field(&quot;i&quot;)</span> String targetSentence)</span></span>;</span><br><span class="line">    <span class="comment">//采用@Post表示Post方法进行请求（传入部分url地址）</span></span><br><span class="line">    <span class="comment">// 采用@FormUrlEncoded注解的原因:API规定采用请求格式x-www-form-urlencoded,即表单形式</span></span><br><span class="line">    <span class="comment">// 需要配合@Field 向服务器提交需要的字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.retrofit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Translation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> errorCode;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> elapsedTime;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;TranslateResultBean&gt;&gt; translateResult;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getErrorCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> errorCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setErrorCode</span><span class="params">(<span class="keyword">int</span> errorCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorCode = errorCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getElapsedTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elapsedTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setElapsedTime</span><span class="params">(<span class="keyword">int</span> elapsedTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elapsedTime = elapsedTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;TranslateResultBean&gt;&gt; getTranslateResult() &#123;</span><br><span class="line">        <span class="keyword">return</span> translateResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTranslateResult</span><span class="params">(List&lt;List&lt;TranslateResultBean&gt;&gt; translateResult)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.translateResult = translateResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TranslateResultBean</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * src : merry me</span></span><br><span class="line"><span class="comment">         * tgt : 我快乐</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String src;</span><br><span class="line">        <span class="keyword">public</span> String tgt;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getSrc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> src;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSrc</span><span class="params">(String src)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.src = src;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getTgt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> tgt;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTgt</span><span class="params">(String tgt)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.tgt = tgt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.retrofit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.mydemo813.R;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> retrofit2.Call;</span><br><span class="line"><span class="keyword">import</span> retrofit2.Callback;</span><br><span class="line"><span class="keyword">import</span> retrofit2.Response;</span><br><span class="line"><span class="keyword">import</span> retrofit2.Retrofit;</span><br><span class="line"><span class="keyword">import</span> retrofit2.converter.gson.GsonConverterFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetrofitActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;zhangtao&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_retrofit);</span><br><span class="line">        request();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//步骤4:创建Retrofit对象</span></span><br><span class="line">        Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">                .baseUrl(<span class="string">&quot;https://fanyi.youdao.com/&quot;</span>) <span class="comment">// 设置 网络请求 Url</span></span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create()) <span class="comment">//设置使用Gson解析(记得加入依赖)</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 步骤5:创建 网络请求接口 的实例</span></span><br><span class="line">        GetRequest_Interface request = retrofit.create(GetRequest_Interface.class);</span><br><span class="line">        <span class="comment">//对 发送请求 进行封装(设置需要翻译的内容)</span></span><br><span class="line">        Call&lt;Translation&gt; call = request.getCall(<span class="string">&quot;I love you&quot;</span>);</span><br><span class="line">        <span class="comment">//步骤6:发送网络请求(异步)</span></span><br><span class="line">        call.enqueue(<span class="keyword">new</span> Callback&lt;Translation&gt;() &#123;</span><br><span class="line">            <span class="comment">//请求成功时回调</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;Translation&gt; call, Response&lt;Translation&gt; response)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 步骤7：处理返回的数据结果：输出翻译的内容</span></span><br><span class="line">                Log.i(TAG, <span class="string">&quot;onResponse: &quot;</span>+response.body().getTranslateResult().get(<span class="number">0</span>).get(<span class="number">0</span>).getTgt());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//请求失败时回调</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;Translation&gt; call, Throwable throwable)</span> </span>&#123;</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;onFailure: 请求失败&quot;</span>);</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;onFailure: &quot;</span>+throwable.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5、拓展"><a href="#5、拓展" class="headerlink" title="5、拓展"></a>5、拓展</h4><ul>
<li>Retrofit的使用场景非常丰富，如支持<code>RxJava</code>和<code>Prototocobuff</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;-- 主要在创建Retrofit对象中设置 --&gt;</span><br><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">  .baseUrl(<span class="string">&quot;&quot;</span>http:<span class="comment">//fanyi.youdao.com/&quot;&quot;)</span></span><br><span class="line">  .addConverterFactory(ProtoConverterFactory.create()) <span class="comment">// 支持Prototocobuff解析</span></span><br><span class="line">  .addConverterFactory(GsonConverterFactory.create()) <span class="comment">// 支持Gson解析</span></span><br><span class="line">  .addCallAdapterFactory(RxJavaCallAdapterFactory.create()) <span class="comment">// 支持RxJava</span></span><br><span class="line">  .build();</span><br></pre></td></tr></table></figure>

<h4 id="6、源码解析"><a href="#6、源码解析" class="headerlink" title="6、源码解析"></a>6、源码解析</h4><p><a href="https://blog.csdn.net/carson_ho/article/details/73732115">Android：网络请求库Retrofit源码分析</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>5、性能优化</title>
    <url>/2022/09/13/Android/5%E3%80%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h4 id="5、性能优化"><a href="#5、性能优化" class="headerlink" title="5、性能优化"></a>5、性能优化</h4><h5 id="1、如何全面进行性能优化"><a href="#1、如何全面进行性能优化" class="headerlink" title="1、如何全面进行性能优化"></a><a href="">1、如何全面进行性能优化</a></h5><ul>
<li><p>目的：让应用程序APP更快、更稳定&amp;更省</p>
<ul>
<li>更快：应用程序 运行得更加流畅、不卡顿，能快速响应用户操作</li>
<li>更稳定：应用程序 能 稳定运行 &amp; 解决用户需求，在用户使用过程中不出现应用程序崩溃<code>（Crash）</code> 和 无响应<code>（ANR）</code>的问题</li>
<li>更省：节省耗费的资源，包括 内存占有、电池量、网络资源等</li>
</ul>
</li>
<li><p>性能指标：<strong>流畅性、稳定性、资源节省性</strong></p>
</li>
<li><p>优化方向：</p>
<table>
<thead>
<tr>
<th>优化目的</th>
<th>性能指标</th>
<th>优化方向</th>
</tr>
</thead>
<tbody><tr>
<td>更快</td>
<td>流畅性</td>
<td>启动速度<br>·页面显示速度<br>·响应速度</td>
</tr>
<tr>
<td>更稳定</td>
<td>稳定性</td>
<td>避免出现应用崩溃（Crash）<br>避免出现 应用无响应(ANR)</td>
</tr>
<tr>
<td>更省</td>
<td>资源节省性</td>
<td>内存大小<br>·安装包大小<br>·耗电量<br>·网络流量</td>
</tr>
</tbody></table>
</li>
<li><p><strong><code>流畅性</code></strong></p>
<blockquote>
<ul>
<li>优化原因<br>利于 减少使用中的卡顿、响应时间久等问题，给与用户一个操作流畅的体验</li>
<li>优化方向<br>主要针对3个方面优化：启动速度、页面显示速度、响应速度</li>
</ul>
</blockquote>
<ul>
<li><p>启动速度</p>
<ul>
<li><p>采用 <strong>异步加载（多线程）、分步加载、延期加载</strong>的策略，减少启动应用时加载的任务，从而提高启动速度</p>
<table>
<thead>
<tr>
<th>措施</th>
<th>启动慢的原因</th>
<th>具体描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>1、减少OnCreate时间</td>
<td>OnCreate作为启动Activity的第一个方法，若代码逻辑过多，则容易导致慢</td>
<td>- 精简OnCreate<br/>- 将OnCreate的代码部分放在OnResume实现<br/>- 通过多线程细分页面显示View，尽可能减少OnCreate，onResume</td>
<td>-很多操作只需1次初始化，都放在OnResume里每次进入Activity会浪费初始化时间<br/>- 解决方案：<br><code>1.定义一个boolean变量</code><br><code>2.在OnCreate里标识为true</code><br><code>3.在OnResume里判断为true就进行初始化，初始化完成立刻置为false</code></td>
</tr>
<tr>
<td>2、优化布局文件</td>
<td>若布局层次过多，那么用findViewById的时间就会边多，则容易导致启动慢</td>
<td>- 优化布局的层次结构，使用include、merge、ViewStub等 <br/>使用观察布局工具Hierarchy Viewer <br>使用布局优化工具：Layoutopt</td>
<td></td>
</tr>
<tr>
<td>3、提高Adapter、AdapterView的效率</td>
<td>数据过多，绘制效率过低，从而导致慢</td>
<td>- 重用以生成过的Item View<br/> 添加ViewHolder<br>缓存Item的数据<br>分段显示</td>
<td></td>
</tr>
<tr>
<td>4、减小主线程的阻塞时间</td>
<td>导致ANR的时间：<br> <code>1、用户无响应5s</code><br><code>2、网络、数据库阻塞10s</code><br/><code>3、广播接收者执行超过10s</code></td>
<td>将耗时过长的操作放入后台线程钟执行&amp;只在需要UI时通知主线程修改</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>页面显示速度</p>
<blockquote>
<p>a. 页面需绘制的内容（布局 &amp; 控件）太多，从而导致页面测量时间过长<br>b. 绘制效率过低，从而导致绘制时间过长</p>
</blockquote>
<ul>
<li>绘制优化(<a href="https://blog.csdn.net/carson_ho/article/details/79674623">https://blog.csdn.net/carson_ho/article/details/79674623</a>)</li>
<li>布局优化</li>
</ul>
</li>
<li><p>响应速度</p>
<blockquote>
<p>程序出现ANR情况，从而导致应用程序响应速度慢</p>
</blockquote>
</li>
</ul>
<pre><code>![简介](https://raw.githubusercontent.com/dpzxka/typora_pictures/master/简介.png)

优化方案：使用多线程，将大量&amp;耗时操作放在工作线程钟执行。

&gt; 1、多线程的方式 包括：AsyncTask、继承 Thread类、实现 Runnable接口、Handler消息机制、HandlerThread等
&gt;
&gt; 2、注：实际开发中，当一个进程发生了ANR后，系统会在 /data/anr目录下创建一个文件 traces.txt，通过分析该文件可定位出ANR的原因
</code></pre>
<ul>
<li><p>其他优化方案</p>
<ul>
<li><p>合理刷新机制</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220827145556240.png" alt="image-20220827145556240"></p>
</li>
<li><p>动画使用：</p>
<ol>
<li>根据不同场景选择 合适的动画框架</li>
<li>使用 硬件加速的方式 提高流畅度</li>
<li>使用动画后需停止动画</li>
</ol>
</li>
</ul>
</li>
<li><p>总结</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220827145733758.png" alt="image-20220827145733758"></p>
</li>
<li><p><strong><code>稳定性</code></strong></p>
<ul>
<li><p>应用崩溃<code>（Crash）</code></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220827162729079.png" alt="image-20220827162729079"></p>
<p>优化方案：<strong>使用多线程</strong>，将大量 &amp; 耗时操作放在工作线程中执行</p>
</li>
<li><p>应用无响应<code>（ANR）</code></p>
<p>应用崩溃<code>Crash</code>很多情况是因为 <strong>内存溢出</strong>，即<code>OOM</code>；故 需避免出现 <code>OOM</code>现象</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220827162819942.png" alt="image-20220827162819942"></p>
<p><a href="https://blog.csdn.net/carson_ho/article/details/79549417"> 优化方案</a></p>
</li>
<li><p>总结：</p>
<table>
<thead>
<tr>
<th>优化方向</th>
<th>优化原因</th>
<th>优化方案</th>
</tr>
</thead>
<tbody><tr>
<td>ANR</td>
<td>程序出现ANR情况，从而导致应用程序响应速度慢</td>
<td>使用多线程，将大量&amp;耗时操作放在工作线程执行</td>
</tr>
<tr>
<td>Crash</td>
<td>- 应用崩溃Crash很多情况是因为内存溢出：OOM<br>故需要避免OOM现象</td>
<td>内存优化：<br>1、避免内存泄漏<br>2、避免内存抖动：避免频繁创建大量、临时，小的局部对象<br/>3、提高代码质量、减少代码数量<br/>4、日常不正常使用：ListView的缓存复用、尽量少用多进程、依赖注入框架。</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong><code>资源节省性</code></strong></p>
<blockquote>
<ul>
<li>优化原因<br>由于移动设备的硬件性能有限，故减少应用程序的资源消耗显得十分重要</li>
<li>优化方向<br>内存大小、安装包大小、耗电量 &amp; 网络流量</li>
</ul>
</blockquote>
<ul>
<li><p>内存优化</p>
<blockquote>
<p>避免因不正确使用内存 &amp; 缺乏管理，从而出现 <strong>内存泄露<code>（ML）</code>、内存溢出<code>（OOM）</code>、内存空间占用过大</strong> 等问题，最终导致应用程序崩溃（<code>Crash</code>）</p>
</blockquote>
<p>优化方向：</p>
<ol>
<li>内存泄露</li>
<li>内存抖动</li>
<li>图片Bitmap相关</li>
<li>代码质量 &amp; 数量</li>
<li>日常不正确使用</li>
</ol>
</li>
<li><p>减少安装包大小</p>
<blockquote>
<ul>
<li>优化原因<br>应用程序的安装包大小虽对应用程序的使用无影响，但影响的是：</li>
</ul>
<ol>
<li>空间占有率：即 应用程序占有手机内存的大小</li>
<li>下载门槛：应用的安装包越大，用户下载的门槛越高</li>
</ol>
</blockquote>
<ul>
<li>优化原因<br>应用程序的安装包大小虽对应用程序的使用无影响，但影响的是：</li>
</ul>
<ol>
<li>空间占有率：即 应用程序占有手机内存的大小</li>
<li>下载门槛：应用的安装包越大，用户下载的门槛越高</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220827163920588.png" alt="image-20220827163920588"></p>
<p><strong>优化方案</strong>：</p>
<table>
<thead>
<tr>
<th>优化方案</th>
<th>原理</th>
<th>具体手段</th>
</tr>
</thead>
<tbody><tr>
<td>资源优化</td>
<td>尽可能较少不必要的资源文件<br><code>(图片、xml文件)</code></td>
<td>1.使用Android Lint删除冗余资源<br/>2.根据分辨率选择合适图片<br/>3、压缩处理图片、降低图片色彩位数<br/>使用内存占有小的图片格式，如Webp</td>
</tr>
<tr>
<td>较少不必要的库</td>
<td>库本省的大小可能非常大，从而导致内存增大</td>
<td>1、尽可能避免引入内存较大的库<br/>2、不引某个方法，而引入庞大的功能库</td>
</tr>
<tr>
<td>代码混淆</td>
<td>重命名代码中的类、方法、变量名等信息，把他们改成一些无意义的名字&amp;压缩、优化大小</td>
<td>1、使用代码混淆工具，如proGuard<br/>2、含压缩、优化、混淆功能</td>
</tr>
<tr>
<td>插件化</td>
<td>将功能独立成单独模块(APK)&amp;放在服务器上按需下载、按需加载</td>
<td>主应用APK仅保留基础、核心功能<br/>其余功能以模块化的形式存放在服务器上</td>
</tr>
</tbody></table>
</li>
<li><p>减少网络流量</p>
<ul>
<li><p>优化原因<br>每次获取资源时 都通过流量 &amp; 网络加载的方式，将耗费大量网络流量</p>
</li>
<li><p>优化方案<br>主要通过 <strong>缓存</strong> 减少网络流量，采用三级缓存方案：即 内存缓存 - 硬盘缓存- 数据库- 文件 - 网络缓存</p>
<blockquote>
<p>具体描述：当加载资源时，先从内存缓存中寻找；若内存缓存中没有，则从文件缓存中寻找；若文件缓存中没有，最终再通过流量从网络中加载获取</p>
</blockquote>
<p><a href="https://www.jianshu.com/p/5e7075f4875f">WebView缓存机制及资源预加载方案</a></p>
</li>
</ul>
</li>
<li><p>减少应用的耗电量</p>
<blockquote>
<p>随着智能手机普及 &amp; 应用程序<code>App</code>的功能发展，人们的日常生活都离不开智能手机 &amp; 各式各样的应用程序<code>App</code>，故 应用程序的耗电量指标则显得十分重要</p>
</blockquote>
<table>
<thead>
<tr>
<th>优化方案</th>
<th>优化原理</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>正确使用WakeLock机制</td>
<td>·WakeLock决定了Android 设备何时进入休眠状态<br/><code>a.应用只要申请了WakeLock，那么在释放WakeLock前，系统不会进入休眠</code><br/><code>b.即使在灭屏的状态下，应用要执行的任务依旧不会被系统打断</code><br/>只有正当使用WakeLock机制，避免过度使用从而使得应用能尽可能进入休眠状态，才能最大化减少耗电量</td>
<td>·简介：WakeLock是Android框架层提供的一套唤醒机制<br/>·作用：控制Android设备状态（<code>设备状态主要指屏幕的打开关闭、休眠、cpu的保持运行</code>）<br/>·主要应用场景：防止系统进入休眠状态，从而不断执行应用任务</td>
</tr>
<tr>
<td>尽量使用JobScheduler</td>
<td>JobScheduler API 允许按需控制任务的执行时机，使得减少因时机控制引起的电池消耗</td>
<td>·简介：Android5.0后引入的1个功能API接口·<br>作用：当预置的条件被满足时，JobSchedulerAPI为你的应用执行一个操作<br>主要应用场景：执行的任务存在前提条件（非时间条件而是具体条件）</td>
</tr>
<tr>
<td>使用电量分析工具<br>（Battery Historian）</td>
<td>通过电量分析工具，获取当前应用程序的耗电情况，从而优化耗电量温高的问题。</td>
<td>·简介：Battery Historian是一款图形化数据分析接口<br/>作用：分析Cndr0g 系维电量，可真观地属示出手机的电量消过程；通过输入电量分析文件显示消耗情况，最后提供电量优化的方案<br/>（<code>Battery Historian是Android5.0后引入的可获取设备上电量消耗信息的APl</code>）</td>
</tr>
</tbody></table>
</li>
<li><p>总结</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220827213040611.png" alt="image-20220827213040611"></p>
</li>
</ul>
</li>
<li><p>总结</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220827213201978.png" alt="image-20220827213201978"></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/5b2162850c630d99ee9392112ea5d5b5.png" alt="img"></p>
</li>
</ul>
<h5 id="2、Android性能优化：布局优化（含-lt-include-gt-、-lt-Viewstub-gt-、-lt-merge-gt-）"><a href="#2、Android性能优化：布局优化（含-lt-include-gt-、-lt-Viewstub-gt-、-lt-merge-gt-）" class="headerlink" title="2、Android性能优化：布局优化（含&lt; include &gt;、&lt; Viewstub &gt;、&lt; merge &gt;）"></a><a href="">2、Android性能优化：布局优化（含&lt; include &gt;、&lt; Viewstub &gt;、&lt; merge &gt;）</a></h5><p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/%E7%9B%AE%E5%BD%95.png" alt="目录"></p>
<ul>
<li><p>**<code>影响的性能</code>**：Android应用中页面显示速度</p>
</li>
<li><p><strong><code>如何影响性能</code><strong>：</strong>页面的测量&amp;绘制时间</strong></p>
<blockquote>
<p> 1个页面通过递归 完成测量 &amp; 绘制过程 = <code>measure</code>、<code>layout</code> 过程</p>
</blockquote>
</li>
<li><p><strong><code>优化思路</code></strong></p>
<ul>
<li>选择耗费性能少的布局</li>
<li>较少布局的层级(嵌套)</li>
<li>提高布局的复用性</li>
<li>减少测量&amp;绘制的时间</li>
</ul>
</li>
<li><p><strong><code>具体优化方案</code></strong></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220827221956160.png" alt="image-20220827221956160"></p>
<ul>
<li><p><strong><a href="">选择耗费性能少的布局</a></strong></p>
<ul>
<li>性能耗费低的布局 = 功能简单 = <code>FrameLayout</code>、<code>LinearLayout</code></li>
<li>性能耗费高的布局 = 功能复杂 = <code>RelativeLayout</code></li>
</ul>
<blockquote>
<p>即 布局过程需消耗更多性能（CPU资源 &amp; 时间）</p>
<p>注：</p>
<ol>
<li>嵌套所耗费的性能 &gt; 单个布局本身耗费的性能</li>
<li>即 完成需求时：宁选择 1个耗费性能高的布局，也不采用嵌套多个耗费性能低的布局</li>
</ol>
</blockquote>
</li>
<li><p><strong><a href="">较少布局的层级(嵌套)</a></strong></p>
<ul>
<li>原理：布局层级少 -&gt;&gt; 绘制的工作量少 -&gt;&gt; 绘制速度快 -&gt;&gt; 性能提高</li>
<li>优化方式：使用布局标签<code>&lt;merge&gt;</code> &amp; 合适选择布局类型</li>
</ul>
<p><code>使用布局标签</code>：减少布局层级</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// 使用说明：</span><br><span class="line">// 1. <span class="tag">&lt;<span class="name">merge</span>&gt;</span>作为被引用布局A的根标签</span><br><span class="line">// 2. 当其他布局通过<span class="tag">&lt;<span class="name">include</span>&gt;</span>标签引用布局A时，布局A中的<span class="tag">&lt;<span class="name">merge</span>&gt;</span>标签内容（根节点）会被去掉，在<span class="tag">&lt;<span class="name">include</span>&gt;</span>里存放的是布局A中的<span class="tag">&lt;<span class="name">merge</span>&gt;</span>标签内容（根节点）的子标签（即子节点），以此减少布局文件的层次</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line"> * 实例说明：在上述例子，在布局B中 通过<span class="tag">&lt;<span class="name">include</span>&gt;</span>标签引用布局C</span><br><span class="line"> * 此时：布局层级为 =  RelativeLayout -&gt;&gt; Button </span><br><span class="line"> *                                  —&gt;&gt; RelativeLayout -&gt;&gt; Button</span><br><span class="line"> *                                                     -&gt;&gt; TextView</span><br><span class="line"> * 现在使用<span class="tag">&lt;<span class="name">merge</span>&gt;</span>优化：将 被引用布局C根标签 的RelativeLayout 改为 <span class="tag">&lt;<span class="name">merge</span>&gt;</span></span><br><span class="line"> * 在引用布局C时，布局C中的<span class="tag">&lt;<span class="name">merge</span>&gt;</span>标签内容（根节点）会被去掉，在<span class="tag">&lt;<span class="name">include</span>&gt;</span>里存放的是布局C中的<span class="tag">&lt;<span class="name">merge</span>&gt;</span>标签内容（根节点）的子标签（即子节点）</span><br><span class="line"> * 即 <span class="tag">&lt;<span class="name">include</span>&gt;</span>里存放的是：<span class="tag">&lt;<span class="name">Button</span>&gt;</span>、<span class="tag">&lt;<span class="name">TextView</span>&gt;</span></span><br><span class="line"> * 此时布局层级为 =  RelativeLayout -&gt;&gt; Button </span><br><span class="line"> *                                -&gt;&gt; Button</span><br><span class="line"> *                                -&gt;&gt; TextView</span><br><span class="line"> * 即 已去掉之前无意义、多余的<span class="tag">&lt;<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"> */  </span><br><span class="line"></span><br><span class="line"> // 被引用的公共部分：布局C = layout_c.xml</span><br><span class="line"> <span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">merge</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;@dimen/dp_10&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/textview&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;@dimen/dp_10&quot;</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">merge</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  // 布局B：layout_b.xml</span><br><span class="line">  <span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line">   </span><br><span class="line">      <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:id</span>=<span class="string">&quot;@+id/Button&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;@dimen/dp_10&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">&quot;@layout/layout_c.xml&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>合适选择布局类型：</code></p>
<p>过合理选择布局类型，从而减少嵌套，即：完成 复杂的UI效果时，尽可能选择<code>1个功能复杂的布局</code>（如RelativeLayout）完成，而<code>不要选择多个功能简单的布局</code>（如：LinerLayout）通过嵌套完成</p>
</li>
<li><p><strong><a href="">提高布局的复用性</a></strong></p>
<p><strong>优化原理</strong>：提取布局间的公共部分，通过提高布局的复用性从而减少测量 &amp; 绘制时间</p>
<p><strong>优化方案</strong>：使用 布局标签 <include>，其作用是实现 布局模块化，即 提取布局中的公共部分 供其他布局共用。</p>
<p><strong>使用说明：</strong>通过标签引入抽取的公共部分布局C；标签所需属性 = 公共部分的layout属性，作用 = 指定需引入、包含的布局文件</p>
<p><strong>具体使用</strong><br>抽取布局A、B中的公共部分布局C &amp; 放入到布局B中使用.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">/** </span><br><span class="line"> * 布局B：layout_b.xml</span><br><span class="line"> */  </span><br><span class="line">  <span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line">   </span><br><span class="line">      <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:id</span>=<span class="string">&quot;@+id/Button&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;@dimen/dp_10&quot;</span> /&gt;</span></span><br><span class="line">      </span><br><span class="line">      // 通过<span class="tag">&lt;<span class="name">include</span>&gt;</span>标签引入抽取的公共部分布局C</span><br><span class="line">      // <span class="tag">&lt;<span class="name">include</span>&gt;</span>标签所需属性 = 公共部分的layout属性，作用 = 指定需引入、包含的布局文件</span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">&quot;@layout/layout_c.xml&quot;</span> /&gt;</span></span><br><span class="line">   </span><br><span class="line">  <span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line"> * 公共部分的布局C：layout_c.xml</span><br><span class="line"> */</span><br><span class="line">   <span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line">   </span><br><span class="line">      <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_height</span>=<span class="string">&quot;@dimen/dp_10&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:id</span>=<span class="string">&quot;@+id/textview&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_height</span>=<span class="string">&quot;@dimen/dp_10&quot;</span>/&gt;</span></span><br><span class="line">   </span><br><span class="line">  <span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li><p><strong><a href="">减少测量&amp;绘制的时间</a></strong></p>
<blockquote>
<p>使用 布局标签<code>&lt;ViewStub&gt;</code> &amp; 尽可能少用布局属性 <code>wrap_content</code></p>
</blockquote>
<p><strong>作用</strong>：按需加载 外部引入的布局，属 轻量级View、不占用显示 &amp; 位置<br>应用场景：引入 只在特殊情况下才显示的布局（即 默认不显示），如：进度显示布局、信息出错出现的提示布局等<br><strong>使用说明</strong></p>
<ol>
<li>先设置好预显示的布局</li>
<li>在其他布局通过标签引入外部布局（类似）；注：此时该布局还未被加载显示</li>
<li>只有当ViewStub被设置为可见 / 调用了ViewStub.inflate()时，ViewStub所指向的布局文件才会被inflate 、实例化，最终 显示指向的布局</li>
</ol>
<p><strong>具体使用</strong>：在布局A中引入布局B，只有在特定时刻C中才显示</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// 步骤1：先设置好预显示的布局B = layout_b.xml</span><br><span class="line"> <span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;@dimen/dp_10&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/textview&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;@dimen/dp_10&quot;</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 步骤2：在布局A通过<span class="tag">&lt;<span class="name">ViewStub</span>&gt;</span>标签引入布局B（类似<span class="tag">&lt;<span class="name">include</span>&gt;</span>）；注：此时该布局还未被加载显示</span><br><span class="line">// 布局A：layout_a.xml</span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/Button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;@dimen/dp_10&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ViewStub</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/Blayout&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout</span>=<span class="string">&quot;@layout/layout_b&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 步骤3：只有当ViewStub被设置为可见 / 调用了ViewStub.inflate()时，ViewStub所指向的布局文件才会被inflate 、实例化，最终 显示<span class="tag">&lt;<span class="name">ViewStub</span>&gt;</span>指向的布局</span><br><span class="line">ViewStub stub = (ViewStub) findViewById(R.id.Blayout);   </span><br><span class="line">stub.inflate();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>ViewStub中的layout布局不能使用merge标签，否则会报错</li>
<li>ViewStub的inflate只能执行一次，显示了之后，就不能再使用ViewStub控制它了</li>
<li>与View.setVisible(View.Gone)的区别：View 的可见性设置为 gone 后，在inflate 时，该View 及其子View依然会被解析；而使用ViewStub就能避免解析其中指定的布局文件，从而节省布局文件的解析时间 &amp; 内存的占用</li>
</ol>
<p>布局属性<code>wrap_content</code> 会增加布局测量时计算成本，应尽可能少用；特别是在已知宽高为固定值时，不使用<code>wrap_content</code>。</p>
</blockquote>
</li>
<li><p>布局调优工具</p>
<ul>
<li><p>Lint</p>
<p><a href="https://blog.csdn.net/u011240877/article/details/54141714">使用教程</a></p>
</li>
<li><p>Systrace</p>
<p>简介: Android 4.1以上版本提供的性能数据采样 &amp; 分析工具<br>作用:检测 Android系统各个组件随着时间的运行状态 &amp; 提供解决方案</p>
<blockquote>
<ol>
<li>收集 等运行信息，从而帮助开发者更直观地分析系统瓶颈，改进性能<br>检测范围包括：Android 关键子系统（如WindowManagerService 等 Framework 部分关键模块）、服务、View系统</li>
<li>功能包括：跟踪系统的I/O 操作、内核工作队列、CPU 负载等，在 UI 显示性能分析上提供很好的数据，特别是在动画播放不流畅、渲染卡等问题上</li>
</ol>
</blockquote>
<p><a href="http://gityuan.com/2016/01/17/systrace/">使用教程</a></p>
</li>
</ul>
</li>
</ul>
<h5 id="3、Android性能优化：内存泄露"><a href="#3、Android性能优化：内存泄露" class="headerlink" title="3、Android性能优化：内存泄露"></a><a href="">3、Android性能优化：内存泄露</a></h5><ul>
<li><p><strong><code>1、简介：</code></strong></p>
<ul>
<li>ML(Memory  Leak)</li>
<li>程序在申请内存后，当该内存不需要再使用<strong>但却无法被释放&amp;归还给程序</strong> 的现象</li>
</ul>
</li>
<li><p><strong><code>2、对应用程序的影响</code></strong></p>
<p>容易使得应用程序发生内存溢出，即<code>OOM</code></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220828001331700.png" alt="image-20220828001331700"></p>
</li>
<li><p><strong><code>3、发生内存泄漏的本质原因</code></strong></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220828001421068.png" alt="image-20220828001421068"></p>
<p>注意：</p>
</li>
<li><p><strong><code>4、Android内存管理机制</code></strong></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220828081537409.png" alt="image-20220828081537409"></p>
<p><strong><code>1、针对进程的内存策略</code></strong></p>
<p><strong>内存分配策略：</strong></p>
<p>由ActivityManagerService集中分配所有进程的内存分配</p>
<p>内存回收策略：</p>
<ol>
<li>Application FrameWork决定回收的进程类型</li>
</ol>
</li>
</ul>
<pre><code> ![进程优先级](https://www.processon.com/view/link/630ab73e63768906ff6909b6)

 ![image-20220828083228966](https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220828083228966.png)
</code></pre>
<ol start="2">
<li>Linux内核真正回收具体进程</li>
</ol>
<p><strong><code>2、针对对象、变量 的内存策略</code></strong></p>
<p><strong>内存分配策略</strong><br>对象 / 变量的内存分配 由程序自动 负责，共有3种：静态分配、栈式分配、 &amp; 堆式分配，分别面向静态变量、局部变量 &amp; 对象实例</p>
<table>
<thead>
<tr>
<th>内存分配策略</th>
<th>使用的内存空间</th>
<th>存储的数据</th>
<th>分配策略描述</th>
</tr>
</thead>
<tbody><tr>
<td>静态分配</td>
<td>方法区<br><code>（静态存储区）</code></td>
<td>存储已被虚拟机加载的类信息、常量、静态变量</td>
<td>在程序编译时就已分配好&amp;存在于程序整个运行期间<br><code>（不需回收）</code></td>
</tr>
<tr>
<td>栈式分配区</td>
<td>栈区<code>（Stack）</code></td>
<td>存储方法执行时的局部变量（含教据类型、对象的引用）<br><code>以桢栈形式</code></td>
<td>方法执行时，定义局部变量则由程序自动在栈中分配内存<br>方法执行结来/超出变量境时，则由栈自动释放该部分内存<br>效率高<br>（<code>因栈内存分配运算内置于处理器的指令集中</code>）<br>但分配的内存容量有限</td>
</tr>
<tr>
<td>堆式分配<br>(动态内存分配)</td>
<td>堆区<br>（Heap）</td>
<td>存储Java对象的实例&amp;实例内成员变量<br><code>即采用关键字new出来的对象</code><br><code>实例的成员变量=基本数据类型、引用&amp;引用的对象实体</code></td>
<td>创建对象实例时，有程序分配<br>（<code>由Java垃级回收管理器自动管理；不使用时则回收</code>）<br>访问方式<br>.1在堆中创建1个对象/数组&amp;在栈中定义一个特殊的变量(引用变量)=数组/对象在堆内存中的首地址<br>2.通过引用变量来访问堆内存中的对象/数组</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>基本数据类型、局部变量、</strong>对象的引用变量<strong>都是存放在栈内存中的，用完就消失</strong></p>
<p><strong>new创建的实例化对象及数组，是存放在堆内存中的，用完之后靠垃圾回收机制不定期自动消除</strong></p>
</blockquote>
<p><strong>内存释放</strong>：垃圾回收算法</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220828091450126.png" alt="image-20220828091450126"></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p><strong><code>5、内存泄漏原因&amp;解决方案</code></strong></p>
<ol>
<li><strong>集合类</strong></li>
</ol>
<p><a href="">原因</a>：集合类添加元素后，仍引用着集合元素对象，导致该集合元素对象不可被回收，从而 导致内存泄漏。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 循环申请Object 对象 &amp; 将申请的对象逐个放入到集合List</span></span><br><span class="line">List&lt;Object&gt; objectList = <span class="keyword">new</span> ArrayList&lt;&gt;();        </span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Object o = <span class="keyword">new</span> Object();</span><br><span class="line">            objectList.add(o);</span><br><span class="line">            o = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 虽释放了集合元素引用的本身：o=null）</span></span><br><span class="line"><span class="comment">// 但集合List 仍然引用该对象，故垃圾回收器GC 依然不可回收该对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="null">解决方案</a>:集合类 添加集合元素对象 后，在使用后必须从集合中删除</p>
<blockquote>
<p>由于1个集合中有许多元素，故最简单的方法 = 清空集合对象 &amp; 设置为<code>null</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放objectList</span></span><br><span class="line">       objectList.clear();</span><br><span class="line">       objectList=<span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong><code>Static</code>关键字修饰的成员变量</strong></p>
<blockquote>
<p>被 Static 关键字修饰的成员变量的生命周期 = 应用程序的生命周期</p>
</blockquote>
<p><a href="">原因</a>:使被 Static 关键字修饰的成员变量 引用耗费资源过多的实例（如Context），则容易出现该成员变量的生命周期 &gt; 引用实例生命周期的情况，当引用实例需结束生命周期销毁时，会因静态变量的持有而无法被回收，从而出现内存泄露.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 定义1个静态变量</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Context mContext;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line"><span class="comment">// 引用的是Activity的context</span></span><br><span class="line"> mContext = context; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 当Activity需销毁时，由于mContext = 静态 &amp; 生命周期 = 应用程序的生命周期，故 Activity无法被回收，从而出现内存泄露</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="null">解决方案</a>:</p>
<p>1、尽量避免 Static 成员变量引用资源耗费过多的实例。若需引用 Context，则尽量使用Applicaiton的Context。</p>
<p>2、使用 弱引用<code>（WeakReference）</code> 代替 强引用 持有实例。</p>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建单例时，需传入一个Context</span></span><br><span class="line"><span class="comment">// 若传入的是Activity的Context，此时单例 则持有该Activity的引用</span></span><br><span class="line"><span class="comment">// 由于单例一直持有该Activity的引用（直到整个应用生命周期结束），即使该Activity退出，该Activity的内存也不会被回收</span></span><br><span class="line"><span class="comment">// 特别是一些庞大的Activity，此处非常容易导致OOM</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstanceClass</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleInstanceClass instance;    </span><br><span class="line">    <span class="keyword">private</span> Context mContext;    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleInstanceClass</span><span class="params">(Context context)</span> </span>&#123;        </span><br><span class="line">        <span class="comment">//this.mContext = context; // 传递的是Activity的context</span></span><br><span class="line">        <span class="comment">//解决方式</span></span><br><span class="line">        <span class="keyword">this</span>.mContext = context.getApplicationContext();</span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> SingleInstanceClass <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingleInstanceClass(context);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>非静态内部类 / 匿名类</strong></p>
<blockquote>
<p>非静态内部类 / 匿名类 默认持有 外部类的引用；而静态内部类则不会</p>
<p>3种情况非静态内部类的实例 = 静态、多线程、消息传递机制（Handler）</p>
</blockquote>
<ul>
<li><p><code>非静态内部类的实例 = 静态</code></p>
<p><a href="">原因：</a>若非静态内部类所创建的实例 = 静态（其生命周期 = 应用的生命周期），会因<strong>非静态内部类默认持有外部类的引用</strong> 而导致外部类无法释放，最终造成内存泄露。(即外部类中持有非静态内部类的静态对象)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 背景：</span></span><br><span class="line">   <span class="comment">/*a. 在启动频繁的Activity中，为了避免重复创建相同的数据资源，会在Activity内部创建一个非静态内部类的单例</span></span><br><span class="line"><span class="comment">   b. 每次启动Activity时都会使用该单例的数据*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 非静态内部类的实例的引用</span></span><br><span class="line">    <span class="comment">// 注：设置为静态  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> InnerClass innerClass = <span class="keyword">null</span>; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);   </span><br><span class="line">        <span class="comment">// 保证非静态内部类的实例只有1个</span></span><br><span class="line">        <span class="keyword">if</span> (innerClass == <span class="keyword">null</span>)</span><br><span class="line">            innerClass = <span class="keyword">new</span> InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非静态内部类的定义    </span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;        </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 造成内存泄露的原因：</span></span><br><span class="line">    <span class="comment">// a. 当TestActivity销毁时，因非静态内部类单例的引用（innerClass）的生命周期 = 应用App的生命周期、持有外部类TestActivity的引用</span></span><br><span class="line">    <span class="comment">// b. 故 TestActivity无法被GC回收，从而导致内存泄漏</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="null">解决方案</a>:</p>
<ol>
<li>将非静态内部类设置为：静态内部类（静态内部类默认不持有外部类的引用）</li>
<li>该内部类抽取出来封装成一个单例</li>
<li>尽量 避免 非静态内部类所创建的实例 = 静态</li>
</ol>
</li>
<li><p><code>非静态内部类的实例 = 多线程</code></p>
<blockquote>
<p>多线程的使用方法 = 非静态内部类 / 匿名类；即 线程类 属于 非静态内部类 / 匿名类。</p>
<p>多线程主要使用的是：AsyncTask、实现Runnable接口 &amp; 继承Thread类</p>
</blockquote>
<p><a href="">原因：</a>:</p>
<p>当 工作线程正在处理任务 &amp; 外部类需销毁时， <strong>由于 工作线程实例 持有外部类引用</strong>，将使得外部类无法被垃圾回收器（GC）回收，从而造成 内存泄露.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 方式1：新建Thread子类（内部类）</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;carson：&quot;</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">            setContentView(R.layout.activity_main);</span><br><span class="line">            <span class="comment">// 通过创建的内部类 实现多线程</span></span><br><span class="line">            <span class="keyword">new</span> MyThread().start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自定义的Thread子类</span></span><br><span class="line">        <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;执行了多线程&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 方式2：匿名Thread内部类</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">     <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;carson：&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过匿名内部类 实现多线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;执行了多线程&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 分析：内存泄露原因</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">  <span class="comment">// 工作线程Thread类属于非静态内部类 / 匿名内部类，运行时默认持有外部类的引用</span></span><br><span class="line">  <span class="comment">// 当工作线程运行时，若外部类MainActivity需销毁</span></span><br><span class="line">  <span class="comment">// 由于此时工作线程类实例持有外部类的引用，将使得外部类无法被垃圾回收器（GC）回收，从而造成 内存泄露</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="null">解决方案</a>:</p>
<ol>
<li><p>存在 ”工作线程实例 持有外部类引用“ 的引用关系</p>
</li>
<li><p>工作线程实例的生命周期 &gt; 外部类的生命周期，即工作线程仍在运行 而 外部类需销毁。</p>
<p>思路：上述条件任意1个不成立。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 共有2个解决方案：静态内部类 &amp; 当外部类结束生命周期时，强制结束线程</span></span><br><span class="line"><span class="comment">// 具体描述如下</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 解决方式1：静态内部类</span></span><br><span class="line"><span class="comment">     * 原理：静态内部类不默认持有外部类的引用，从而使得 “工作线程实例持有外部类引用” 的引用关系不复存在</span></span><br><span class="line"><span class="comment">     * 具体实现：将Thread的子类设置成 静态内部类</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;carson：&quot;</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">            setContentView(R.layout.activity_main);</span><br><span class="line">            <span class="comment">// 通过创建的内部类 实现多线程</span></span><br><span class="line">            <span class="keyword">new</span> MyThread().start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分析1：自定义Thread子类</span></span><br><span class="line">        <span class="comment">// 设置为：静态内部类</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;执行了多线程&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 解决方案2：当外部类结束生命周期时，强制结束线程</span></span><br><span class="line"><span class="comment">     * 原理：使得 工作线程实例的生命周期 与 外部类的生命周期 同步</span></span><br><span class="line"><span class="comment">     * 具体实现：当 外部类（此处以Activity为例） 结束生命周期时（此时系统会调用onDestroy（）），强制结束线程（调用stop（））</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        Thread.stop();</span><br><span class="line">        <span class="comment">// 外部类Activity生命周期结束时，强制结束线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ul>
<ul>
<li><p><code>非静态内部类的实例 = 消息传递机制（Handler）</code></p>
<p><a href="">案例</a>:</p>
<pre><code> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 方式1：新建Handler子类（内部类）</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;carson：&quot;</span>;</span><br><span class="line">            <span class="keyword">private</span> Handler showhandler;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 主线程创建时便自动创建Looper &amp; 对应的MessageQueue</span></span><br><span class="line">            <span class="comment">// 之后执行Loop()进入消息循环</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">                setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//1. 实例化自定义的Handler类对象-&gt;&gt;分析1</span></span><br><span class="line">                <span class="comment">//注：此处并无指定Looper，故自动绑定当前线程(主线程)的Looper、MessageQueue</span></span><br><span class="line">                showhandler = <span class="keyword">new</span> FHandler();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 启动子线程1</span></span><br><span class="line">                <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// a. 定义要发送的消息</span></span><br><span class="line">                        Message msg = Message.obtain();</span><br><span class="line">                        msg.what = <span class="number">1</span>;<span class="comment">// 消息标识</span></span><br><span class="line">                        msg.obj = <span class="string">&quot;AA&quot;</span>;<span class="comment">// 消息存放</span></span><br><span class="line">                        <span class="comment">// b. 传入主线程的Handler &amp; 向其MessageQueue发送消息</span></span><br><span class="line">                        showhandler.sendMessage(msg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.start();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3. 启动子线程2</span></span><br><span class="line">                <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// a. 定义要发送的消息</span></span><br><span class="line">                        Message msg = Message.obtain();</span><br><span class="line">                        msg.what = <span class="number">2</span>;<span class="comment">// 消息标识</span></span><br><span class="line">                        msg.obj = <span class="string">&quot;BB&quot;</span>;<span class="comment">// 消息存放</span></span><br><span class="line">                        <span class="comment">// b. 传入主线程的Handler &amp; 向其MessageQueue发送消息</span></span><br><span class="line">                        showhandler.sendMessage(msg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.start();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 分析1：自定义Handler子类</span></span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">FHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 通过复写handlerMessage() 从而确定更新UI的操作</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                            Log.d(TAG, <span class="string">&quot;收到线程1的消息&quot;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                            Log.d(TAG, <span class="string">&quot; 收到线程2的消息&quot;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 方式2：匿名Handler内部类</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">     <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;carson：&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> Handler showhandler;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程创建时便自动创建Looper &amp; 对应的MessageQueue</span></span><br><span class="line">        <span class="comment">// 之后执行Loop()进入消息循环</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">            setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//1. 通过匿名内部类实例化的Handler类对象</span></span><br><span class="line">            <span class="comment">//注：此处并无指定Looper，故自动绑定当前线程(主线程)的Looper、MessageQueue</span></span><br><span class="line">            showhandler = <span class="keyword">new</span>  Handler()&#123;</span><br><span class="line">                <span class="comment">// 通过复写handlerMessage()从而确定更新UI的操作</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                                Log.d(TAG, <span class="string">&quot;收到线程1的消息&quot;</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                                Log.d(TAG, <span class="string">&quot; 收到线程2的消息&quot;</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 启动子线程1</span></span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// a. 定义要发送的消息</span></span><br><span class="line">                    Message msg = Message.obtain();</span><br><span class="line">                    msg.what = <span class="number">1</span>;<span class="comment">// 消息标识</span></span><br><span class="line">                    msg.obj = <span class="string">&quot;AA&quot;</span>;<span class="comment">// 消息存放</span></span><br><span class="line">                    <span class="comment">// b. 传入主线程的Handler &amp; 向其MessageQueue发送消息</span></span><br><span class="line">                    showhandler.sendMessage(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 启动子线程2</span></span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// a. 定义要发送的消息</span></span><br><span class="line">                    Message msg = Message.obtain();</span><br><span class="line">                    msg.what = <span class="number">2</span>;<span class="comment">// 消息标识</span></span><br><span class="line">                    msg.obj = <span class="string">&quot;BB&quot;</span>;<span class="comment">// 消息存放</span></span><br><span class="line">                    <span class="comment">// b. 传入主线程的Handler &amp; 向其MessageQueue发送消息</span></span><br><span class="line">                    showhandler.sendMessage(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<blockquote>
<ul>
<li>主线程的<code>Looper</code>对象的生命周期 = 该应用程序的生命周期</li>
<li>在<code>Java</code>中，<strong>非静态内部类</strong> &amp; <strong>匿名内部类</strong>都默认持有 外部类的引用</li>
</ul>
</blockquote>
<p><a href="https://www.jianshu.com/p/ed9e15eff47a">参考</a></p>
<p><a href="">原因</a>:</p>
<p>由于Handler = 非静态内部类 / 匿名内部类（2种使用方式），故又默认持有外部类的引用（即MainActivity实例）。</p>
<p>由于<code>Handler</code> = 非静态内部类 / 匿名内部类（2种使用方式），故又默认持有外部类的引用（即<code>MainActivity</code>实例）</p>
<p><a href="">解决方案</a></p>
<p><strong>原理</strong>：静态内部类不默认持有外部类的引用，从而使得 “未被处理 / 正处理的消息 -&gt; Handler实例 -&gt; 外部类” 的引用关系 不存在。</p>
<p><strong>具体方案</strong>：**将Handler的子类设置成静态内部类。此外，还可使用WeakReference弱引用持有外部类，保证外部类能被回收。因为：弱引用的对象拥有短暂的生命周期，在垃圾回收器线程扫描时，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p>
<pre><code> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;carson：&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Handler showhandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">// 实例化自定义的Handler类对象-&gt;&gt;分析1</span></span><br><span class="line">        <span class="comment">// 注：</span></span><br><span class="line">            <span class="comment">// a. 此处并无指定Looper，故自动绑定当前线程(主线程)的Looper、MessageQueue；</span></span><br><span class="line">            <span class="comment">// b. 定义时需传入持有的Activity实例（弱引用）</span></span><br><span class="line">        showhandler = <span class="keyword">new</span> FHandler(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// a. 定义要发送的消息</span></span><br><span class="line">                Message msg = Message.obtain();</span><br><span class="line">                msg.what = <span class="number">1</span>;<span class="comment">// 消息标识</span></span><br><span class="line">                msg.obj = <span class="string">&quot;AA&quot;</span>;<span class="comment">// 消息存放</span></span><br><span class="line">                showhandler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置为：静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义 弱引用实例</span></span><br><span class="line">        <span class="keyword">private</span> WeakReference&lt;Activity&gt; reference;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在构造方法中传入需持有的Activity实例</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">FHandler</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 使用WeakReference弱引用持有Activity实例</span></span><br><span class="line">            reference = <span class="keyword">new</span> WeakReference&lt;Activity&gt;(activity); &#125;</span><br><span class="line">        <span class="comment">// 通过复写handlerMessage() 从而确定更新UI的操作</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;收到线程1的消息&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot; 收到线程2的消息&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<ol start="4">
<li><p><strong>资源对象使用后未关闭</strong></p>
<p><a href="">原因</a>:</p>
<p>对于资源的使用（如 广播<code>BraodcastReceiver</code>、文件流<code>File</code>、数据库游标<code>Cursor</code>、图片资源<code>Bitmap</code>等），若在<code>Activity</code>销毁时无及时关闭 / 注销这些资源，则这些资源将不会被回收，从而造成内存泄漏</p>
<p><a href="">解决方案</a>:</p>
<p>在Activity销毁时 及时关闭 / 注销资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于 广播BraodcastReceiver：注销注册</span></span><br><span class="line">unregisterReceiver()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 文件流File：关闭流</span></span><br><span class="line">InputStream / OutputStream.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于数据库游标cursor：使用后关闭游标</span></span><br><span class="line">cursor.close（）</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 图片资源Bitmap：Android分配给图片的内存只有8M，若1个Bitmap对象占内存较多，当它不再被使用时，应调用recycle()回收此对象的像素所占用的内存；最后再赋为null </span></span><br><span class="line">Bitmap.recycle()；</span><br><span class="line">Bitmap = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于动画（属性动画）</span></span><br><span class="line"><span class="comment">// 将动画设置成无限循环播放repeatCount = “infinite”后</span></span><br><span class="line"><span class="comment">// 在Activity退出时记得停止动画</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><strong>其他情况</strong></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220828161813990.png" alt="image-20220828161813990"></p>
</li>
</ol>
<ol start="6">
<li><p>总结：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e70c23ea7510da25a14138fc25a9a3ba.png" alt="总结"></p>
</li>
</ol>
<ul>
<li><p><strong><code>6、辅助分析内存泄露的工具</code></strong></p>
<p><a href="https://developer.android.google.cn/studio/profile/android-profiler">Android Profiler  | Android 开发者  | Android Developers (google.cn)</a></p>
<p><a href="https://www.jianshu.com/p/a16c87ecdf6f">Android优化工具Systrace - 简书 (jianshu.com)</a></p>
<p>[dumpsys:](<a href="https://developer.android.com/studio/command-line/dumpsys?hl=en">dumpsys  | Android Developers</a>) Android内核系统服务相关的计数器。<br>[heapprofd：](<a href="https://perfetto.dev/docs/design-docs/heapprofd-design">heapprofd: Android Heap Profiler - Perfetto Tracing Docs</a>)Android进程本地内存分析工具。</p>
</li>
<li><p><strong><code>7、总结</code></strong></p>
</li>
</ul>
<h5 id="4、Android性能优化：内存优化"><a href="#4、Android性能优化：内存优化" class="headerlink" title="4、Android性能优化：内存优化"></a><a href="">4、Android性能优化：内存优化</a></h5><ol>
<li><p>内存泄露:见上分析</p>
</li>
<li><p>内存抖动</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/c2a5b5b215996caf83385e6d6b370437.png" alt="img"></p>
<p><strong>尽量避免频繁创建大量、临时的小对象</strong></p>
</li>
<li><p>图片<code>Bitmap</code>相关</p>
<p>参考：<a href="https://blog.csdn.net/carson_ho/article/details/79549382">Android性能优化：那些关于Bitmap图片资源优化的小事_Carson带你学Android的博客-CSDN博客</a></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220829072715524.png" alt="image-20220829072715524"></p>
</li>
<li><p>代码质量 &amp; 数量</p>
<ul>
<li>优化原因<br>代码本身的质量（如 数据结构、数据类型等） &amp; 数量（代码量的大小）可能会导致大量的内存问题，如占用内存大、内存利用率低等</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/40ecb5de67f58041c808f1a4476698ed.png" alt="img"></p>
</li>
<li><p>日常不正确使用</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/e193ab51467c5de82501b787a8357d57.png" alt="img"></p>
</li>
<li><p>小技巧</p>
<p><strong>技巧1：获取当前可使用的内存大小</strong><br>调用 ActivityManager.getMemoryClass（）方法可获取当前应用可用的内存大小（单位 = 兆）</p>
<p><strong>技巧2：获取当前的内存使用情况</strong><br>在应用生命周期的任何阶段，调用 onTrimMemory()获取应用程序 当前内存使用情况（以内存级别进行识别），可根据该方法返回的内存紧张级别参数 来释放内存</p>
<p><strong>技巧3：当视图变为隐藏状态时，则释放内存</strong><br>当用户跳转到不同的应用 &amp; 视图不再显示时, 应释放应用视图所占的资源</p>
<blockquote>
<ol>
<li>注：此时释放所占用的资源能显著的提高系统的缓存处理容量</li>
<li>具体操作：实现当前<code>Activity</code>类的<code>onTrimMemory()</code>后，当用户离开视图时会得到通知；若得到返回的参数 = <code>TRIM_MEMORY_UI_HIDDEN</code> 即代表视图变为隐藏状态，则可释放视图所占用的资源</li>
</ol>
</blockquote>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/dd35b51f50f4ad2e2583707dbec694c8.png" alt="img"></p>
<h5 id="5、Android性能优化：Bitmap图片资源优化"><a href="#5、Android性能优化：Bitmap图片资源优化" class="headerlink" title="5、Android性能优化：Bitmap图片资源优化"></a><a href="">5、Android性能优化：Bitmap图片资源优化</a></h5><p><a href="https://carsonho.blog.csdn.net/article/details/79549382">Android性能优化：那些关于Bitmap图片资源优化的小事</a></p>
<h5 id="6、Android性能优化：绘制优化"><a href="#6、Android性能优化：绘制优化" class="headerlink" title="6、Android性能优化：绘制优化"></a><a href="">6、Android性能优化：绘制优化</a></h5><p><a href="https://carsonho.blog.csdn.net/article/details/79674623">Android性能优化：绘制优化</a></p>
<h4 id="6、常用开源框架"><a href="#6、常用开源框架" class="headerlink" title="6、常用开源框架"></a>6、常用开源框架</h4><h5 id="Android实现网络请求的主流方法"><a href="#Android实现网络请求的主流方法" class="headerlink" title="Android实现网络请求的主流方法"></a>Android实现网络请求的主流方法</h5><p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/51f7ecf5b9a606c499ac87c5b4d54d4c.png" alt="img"></p>
<h5 id="网络请求库-与-Android网络请求方法的关系"><a href="#网络请求库-与-Android网络请求方法的关系" class="headerlink" title="网络请求库 与 Android网络请求方法的关系"></a>网络请求库 与 Android网络请求方法的关系</h5><ul>
<li>网络请求库的本质 = 封装了 <strong>网络请求 + 异步 + 数据处理</strong>功能的库</li>
<li>其中，网络请求功能则是采用<code>Android</code>网络请求的原生方法（<code>HttpClient</code>或<code>HttpURLConnection</code>）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/156b09c922bd3e3cda37a4bce78c9c4b.png" alt="img"></p>
<h5 id="主流的网络请求库"><a href="#主流的网络请求库" class="headerlink" title="主流的网络请求库"></a>主流的网络请求库</h5><p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/5307f5ae81079a75369fa10cd6b3908d.png" alt="img"></p>
<h4 id="7、新技术"><a href="#7、新技术" class="headerlink" title="7、新技术"></a>7、新技术</h4><p><a href="https://carsonho.blog.csdn.net/article/details/100070713">MVC、MVP &amp; MVVM模式（含实例讲解</a></p>
<p><a href="https://carsonho.blog.csdn.net/article/details/73250163">JNI 与 NDK到底是什么？（含实例教学）</a></p>
<p><a href="https://carsonho.blog.csdn.net/article/details/88012315">热修复学习指南</a></p>
<p>插件化</p>
<p><img src="https://camo.githubusercontent.com/25fd33fb30eab376400c46bff4a8ccf5ebf704b739078654f4b926bafc4c2401/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f3934343336352d363966353830386438306330353839382e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="插件化"></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>4、自定义View</title>
    <url>/2022/09/13/Android/4%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89View/</url>
    <content><![CDATA[<h1 id="4、-自定义View"><a href="#4、-自定义View" class="headerlink" title="4、 自定义View"></a>4、 自定义View</h1><h2 id="1、自定义View基础"><a href="#1、自定义View基础" class="headerlink" title="1、自定义View基础"></a>1、自定义View基础</h2><h3 id="1、视图定义"><a href="#1、视图定义" class="headerlink" title="1、视图定义"></a>1、视图定义</h3><p>显示在屏幕上的各种视图控件</p>
<h3 id="2、视图分类"><a href="#2、视图分类" class="headerlink" title="2、视图分类"></a>2、视图分类</h3><p>视图View主要分为两类：</p>
<ul>
<li>单一视图：即一个View、不包含子View，如TextView</li>
<li>视图组，即多个View组成的ViewGroup、包含子View，如LinearLayout</li>
</ul>
<p>Android中的UI组件都由View、ViewGroup共同组成。</p>
<h3 id="3、视图类简介"><a href="#3、视图类简介" class="headerlink" title="3、视图类简介"></a>3、视图类简介</h3><ul>
<li><p>视图的核心类是：View类</p>
</li>
<li><p>View类是Android中各种组件的基类，如View是ViewGroup基类</p>
</li>
<li><p>View的构造函数：共有4个，自定义View必须重写至少一个构造函数。具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数1</span></span><br><span class="line"><span class="comment">// 调用场景：View是在Java代码里面new的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CarsonView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数2</span></span><br><span class="line"><span class="comment">// 调用场景：View是在.xml里声明的</span></span><br><span class="line"><span class="comment">// 自定义属性是从AttributeSet参数传进来的</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="title">CarsonView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数3</span></span><br><span class="line"><span class="comment">// 应用场景：View有style属性时</span></span><br><span class="line"><span class="comment">// 一般是在第二个构造函数里主动调用；不会自动调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="title">CarsonView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数4</span></span><br><span class="line"><span class="comment">// 应用场景：View有style属性时、API21之后才使用</span></span><br><span class="line"><span class="comment">// 一般是在第二个构造函数里主动调用；不会自动调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="title">CarsonView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr, <span class="keyword">int</span> defStyleRes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs, defStyleAttr, defStyleRes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0806/4575.html">深入理解View的构造函数</a>和<a href="http://www.cnblogs.com/angeldevil/p/3479431.html#three">理解View的构造函数</a></p>
</li>
</ul>
<h3 id="4、视图结构"><a href="#4、视图结构" class="headerlink" title="4、视图结构"></a>4、视图结构</h3><ul>
<li><p>对于包含子View的视图组（ViewGroup），<strong>结构是树形结构</strong></p>
</li>
<li><p>ViewGroup下可能有多个ViewGroup或View，如下图：</p>
<p><img src="C:/Users/xkadpz/AppData/Roaming/Typora/typora-user-images/image-20220914224106649.png" alt="image-20220914224106649"></p>
<blockquote>
<p>在View的绘制过程中，<strong>永远都是从View树结构的根节点开始(即从树的顶端开始)，一层一层、一个个分支地自上而下遍历进行（即树形递归）</strong>，最终计算整个View树中各个View，从而最终确定整个View树的相关属性。</p>
</blockquote>
</li>
</ul>
<h3 id="5-Android坐标系"><a href="#5-Android坐标系" class="headerlink" title="5. Android坐标系"></a>5. Android坐标系</h3><p>Android的坐标系定义为：</p>
<ul>
<li>屏幕的左上角为坐标原点</li>
<li>向右为x轴增大方向</li>
<li>向下为y轴增大方向</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220914224144848.png" alt="image-20220914224144848"></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220914224201409.png" alt="image-20220914224201409"></p>
<h3 id="6、View位置（坐标）描述"><a href="#6、View位置（坐标）描述" class="headerlink" title="6、View位置（坐标）描述"></a>6、View位置（坐标）描述</h3><p>视图的位置由四个顶点决定，ABCD</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220914224217782.png" alt="image-20220914224217782"></p>
<p>视图的位置是相对于父控件而言的，四个顶点的位置描述分别由四个与父控件相关的值决定：</p>
<ul>
<li>顶部(Top)：视图上边界到父控件上边界的距离；</li>
<li>左边(Left)：视图左边界到父控件左边界的距离；</li>
<li>右边(Right)：视图右边界到父控件左边界的距离；</li>
<li>底部(Bottom)：视图下边界到父控件上边界的距离。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220914224237638.png" alt="image-20220914224237638"></p>
<h3 id="7-位置获取方式"><a href="#7-位置获取方式" class="headerlink" title="7. 位置获取方式"></a>7. 位置获取方式</h3><p>视图的位置获取是通过<code>View.getXXX()</code>方法进行获取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">获取顶部距离(Top)：getTop()</span><br><span class="line">获取左边距离(Left)：getLeft()</span><br><span class="line">获取右边距离(Right)：getRight()</span><br><span class="line">获取底部距离(Bottom)：getBottom()</span><br></pre></td></tr></table></figure>

<p>MotionEvent中 <code>get()</code>和<code>getRaw()</code>的区别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//get() ：触摸点相对于其所在组件坐标系的坐标</span></span><br><span class="line"> event.getX();       </span><br><span class="line"> event.getY();</span><br><span class="line"></span><br><span class="line"><span class="comment">//getRaw() ：触摸点相对于屏幕默认坐标系的坐标</span></span><br><span class="line"> event.getRawX();    </span><br><span class="line"> event.getRawY();</span><br></pre></td></tr></table></figure>

<h3 id="度（radian"><a href="#度（radian" class="headerlink" title="度（radian)"></a><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220914224303841.png" alt="image-20220914224303841">度（radian)</h3><h3 id="8、-角度（angle）-amp-弧度（radian）"><a href="#8、-角度（angle）-amp-弧度（radian）" class="headerlink" title="8、 角度（angle）&amp; 弧度（radian）"></a>8、 角度（angle）&amp; 弧度（radian）</h3><p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220914224616501.png" alt="image-20220914224616501"></p>
<h3 id="9、-颜色相关"><a href="#9、-颜色相关" class="headerlink" title="9、 颜色相关"></a>9、 颜色相关</h3><p><strong>颜色模式</strong></p>
<ul>
<li>ARGB8888：四通道高精度(32位)</li>
<li>ARGB4444：四通道低精度(16位)</li>
<li>RGB565：Android屏幕默认模式(16位)</li>
<li>Alpha8：仅有透明通道(8位)</li>
</ul>
<blockquote>
<p>字母：表示通道类型；</p>
<p>数值：表示该类型用多少位二进制来描述；</p>
<p>示例说明：ARGB8888，表示有四个通道(ARGB)；每个对应的通道均用8位来描述。</p>
<p>以ARGB8888为例介绍颜色定义:</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/f3032fb32cc755ffc1bc5220482bfa13.png" alt="img"></p>
</blockquote>
<p><strong>颜色的定义</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 定义方式1：xml</span></span><br><span class="line"><span class="comment">  * 在/res/values/color.xml文件中定义</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  &lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">  &lt;resources&gt;</span><br><span class="line">    <span class="comment">//定义了红色（没有alpha（透明）通道）</span></span><br><span class="line">    &lt;color name=<span class="string">&quot;red&quot;</span>&gt;#ff0000&lt;/color&gt;</span><br><span class="line">    <span class="comment">//定义了蓝色（没有alpha（透明）通道）</span></span><br><span class="line">    &lt;color name=<span class="string">&quot;green&quot;</span>&gt;#00ff00&lt;/color&gt;</span><br><span class="line">  &lt;/resources&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在xml文件中以”#“开头定义颜色，后面跟十六进制的值，有如下几种定义方式：</span></span><br><span class="line">  #f00  <span class="comment">//低精度 - 不带透明通道红色      </span></span><br><span class="line">  #af00 <span class="comment">//低精度 - 带透明通道红色        </span></span><br><span class="line">  #ff0000 <span class="comment">//高精度 - 不带透明通道红色          </span></span><br><span class="line">  #aaff0000 <span class="comment">//高精度 - 带透明通道红色       </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 定义方式2：Java</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// 使用Color类定义颜色</span></span><br><span class="line">  <span class="keyword">int</span> color = Color.GRAY; <span class="comment">//灰色</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Color类使用ARGB值表示</span></span><br><span class="line">  <span class="keyword">int</span> color = Color.argb(<span class="number">127</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//半透明红色   </span></span><br><span class="line">  <span class="keyword">int</span> color = <span class="number">0xaaff0000</span>; <span class="comment">//带有透明度的红色                                    </span></span><br></pre></td></tr></table></figure>

<p><strong>颜色的引用</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 引用方式1：xml</span><br><span class="line">  */</span><br><span class="line">  // 1. 在style文件中引用</span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;AppTheme&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Theme.AppCompat.Light.DarkActionBar&quot;</span>&gt;</span><span class="xml"></span></span><br><span class="line"><span class="xml">       <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorPrimary&quot;</span>&gt;</span>@color/red<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  // 2. 在layout文件中引用</span><br><span class="line">  android:background=&quot;@color/red&quot;     </span><br><span class="line">  // 3. 在layout文件中创建并使用颜色</span><br><span class="line">  android:background=&quot;#ff0000&quot;       </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * 引用方式2：Java</span><br><span class="line">  */</span><br><span class="line">  //方法1</span><br><span class="line">  int color = getResources().getColor(R.color.mycolor);</span><br><span class="line"></span><br><span class="line">  //方法2（API 23及以上）</span><br><span class="line">  int color = getColor(R.color.myColor);      </span><br></pre></td></tr></table></figure>



<h2 id="2、自定义View流程及特点-Measure过程、Layout过程、Draw过程"><a href="#2、自定义View流程及特点-Measure过程、Layout过程、Draw过程" class="headerlink" title="2、自定义View流程及特点:Measure过程、Layout过程、Draw过程"></a>2、自定义View流程及特点:Measure过程、Layout过程、Draw过程</h2><h3 id="1、基础"><a href="#1、基础" class="headerlink" title="1、基础"></a>1、基础</h3><h4 id="ViewRoot"><a href="#ViewRoot" class="headerlink" title="ViewRoot"></a>ViewRoot</h4><p>定义：连接器，对应于<code>ViewRootImpl</code>类</p>
<p>作用：连接<code>WindowManager</code>和<code>DecorView</code>，完成View的三大流程：<code>measure</code>、<code>layout</code>、<code>draw</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在主线程中，Activity对象被创建后：</span></span><br><span class="line"><span class="comment">// 1. 自动将DecorView添加到Window中 &amp; 创建ViewRootImpll对象</span></span><br><span class="line">root = <span class="keyword">new</span> ViewRootImpl(view.getContent(),display);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 将ViewRootImpll对象与DecorView建立关联</span></span><br><span class="line">root.setView(view,wparams,panelParentView)</span><br></pre></td></tr></table></figure>

<h4 id="DecorView"><a href="#DecorView" class="headerlink" title="DecorView"></a>DecorView</h4><p>定义：顶层View，即Android视图树根节点，同时也是FrameLayout的子类</p>
<p>作用：显示 &amp; 加载布局。</p>
<blockquote>
<p>View<code>层的事件都先经过</code>DecorView<code>，再传递到</code>View；</p>
<p>内含1个竖直方向的<code>LinearLayout</code>，分为2部分：上 = 标题栏<code>（titlebar）</code>、下 = 内容栏<code>（content）</code></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220914224757857.png" alt="image-20220914224757857"></p>
<p>在<code>Activity</code>中通过 <code>setContentView（）</code>所设置的布局文件其实是被加到内容栏之中的，成为其唯一子View = id为content的<code>FrameLayout</code>中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在代码中可通过content得到对应加载的布局</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 得到content</span></span><br><span class="line">ViewGroup content = (ViewGroup)findViewById(android.R.id.content);</span><br><span class="line"><span class="comment">// 2. 得到设置的View</span></span><br><span class="line">ViewGroup rootView = (ViewGroup) content.getChildAt(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>


</blockquote>
<h4 id="Window、Activity、DecorView-与-ViewRoot的关系"><a href="#Window、Activity、DecorView-与-ViewRoot的关系" class="headerlink" title="Window、Activity、DecorView 与 ViewRoot的关系"></a>Window、Activity、DecorView 与 ViewRoot的关系</h4><table>
<thead>
<tr>
<th>类型</th>
<th>作用</th>
<th>具体描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Activity</td>
<td>控制生命周期&amp;处理事件<br>(<code>类似控制器</code>)</td>
<td>- 统筹视图的添加&amp;显示<br>- 通过其他回调方法与Window、View交互</td>
<td>- 不负责视图控制<br>- 真正控制试图的是Window，是真正代表1个窗口<br>- 1个Activity包含1个window</td>
</tr>
<tr>
<td>window</td>
<td>视图的承载器</td>
<td>- Window类=抽象类、实现类=PhoneWindow类<br>- PhonwWindow类中有个内部类DecorView=View 的根布局<br>- 通过创建DevorView来加载Activity中设置的布局</td>
<td>1、Window类通过WindowManager将DecorView加载其中<br>2、将DecorView交给ViewRoot，进行视图的控制&amp;其他交互</td>
</tr>
<tr>
<td>decorView</td>
<td>顶层View<br>- Android视图树的根节点<br>- 是FrameLayout的子类</td>
<td>- 内含1个竖直方向的LinearLayout，分为两部分，上=标题栏，下=内容栏</td>
<td></td>
</tr>
<tr>
<td>ViewRoot</td>
<td>连接器<br>对应viewRootImpl类</td>
<td>- 连接WindowManagerService和DecorView：<br>- 1.与WMS交互通信，调整窗口的大小和布局<br>- 2.完成View的绘制：measure、layout、draw</td>
<td></td>
</tr>
</tbody></table>
<h3 id="2、绘制步骤："><a href="#2、绘制步骤：" class="headerlink" title="2、绘制步骤："></a>2、绘制步骤：</h3><p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220914224919441.png" alt="image-20220914224919441"></p>
<h4 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h4><p>View 的绘制流程开始于：ViewRootImpl对象的performTraversals()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 源码分析：ViewRootImpl.performTraversals()</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  		<span class="comment">// 1. 执行measure流程</span></span><br><span class="line">        <span class="comment">// 内部会调用performMeasure()</span></span><br><span class="line">        measureHierarchy(host, lp, res,desiredWindowWidth, desiredWindowHeight);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 执行layout流程</span></span><br><span class="line">        performLayout(lp, mWidth, mHeight);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 执行draw流程</span></span><br><span class="line">        performDraw();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>View</code>的绘制流程从顶级<code>View（DecorView）</code>的<code>ViewGroup</code>开始，一层一层从<code>ViewGroup</code>至子<code>View</code>遍历测绘</strong>。即：自上而下遍历、由父视图到子视图、每一个 <code>ViewGroup</code> 负责测绘它所有的子视图，而最底层的 View 会负责测绘自身</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220914224951127.png" alt="image-20220914224951127"></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220914225015532.png" alt="image-20220914225015532"></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220914225037452.png" alt="image-20220914225037452"></p>
<h3 id="3、详细介绍"><a href="#3、详细介绍" class="headerlink" title="3、详细介绍"></a>3、详细介绍</h3><ul>
<li><p>Measure过程</p>
<p>作用：测量<code>View</code>的宽 / 高</p>
<blockquote>
<ol>
<li>在某些情况下，需要多次测量<code>（measure）</code>才能确定<code>View</code>最终的宽/高；</li>
<li>该情况下，<code>measure</code>过程后得到的宽 / 高可能不准确；</li>
<li>此处建议：在<code>layout</code>过程中<code>onLayout()</code>去获取最终的宽 / 高</li>
</ol>
</blockquote>
<table>
<thead>
<tr>
<th>View类型</th>
<th>measure过程</th>
</tr>
</thead>
<tbody><tr>
<td>单一View</td>
<td>只测量自身一个View</td>
</tr>
<tr>
<td>ViewGroup</td>
<td>1.遍历测量所有子View的尺寸<br/>2.合并将所有子View的尺寸进行，最终得到ViewGroup父视图的测量值<br>（<code>即遍历调用所有子元素的measure（）&amp;各子元素再递归去执行该流程</code>）</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220914225313347.png" alt="image-20220914225313347"></p>
<p><img src="C:/Users/xkadpz/AppData/Roaming/Typora/typora-user-images/image-20220914225240518.png" alt="image-20220914225240518"></p>
<p><a href="https://blog.csdn.net/carson_ho/article/details/56011064">自定义View Measure过程</a></p>
</li>
<li><p>Layout过程</p>
<p>作用：计算视图<code>（View）</code>的位置</p>
<table>
<thead>
<tr>
<th>View类型</th>
<th>layout过程</th>
</tr>
</thead>
<tbody><tr>
<td>单一View</td>
<td>仅计算本身View的位置<br>（<code>onLayout（）layout（）.selrame（）</code>）</td>
</tr>
<tr>
<td>ViewGroup</td>
<td>1.计算自身的位置：layout（）<br>2.遍历子View、计算子View的位置&amp;设置<br>（<code>（复写）ViewGroup.onLayout（）、子View.layout（）、子View.onLayout（）</code>）<br>3.如此不断循环，最终确定所有子View在父容器的位置，即layout过程完毕</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220914225344433.png" alt="image-20220914225344433"></p>
<p><a href="https://blog.csdn.net/carson_ho/article/details/56011112">自定义View Layout过程</a></p>
</li>
<li><p>Draw过程</p>
<p>作用：绘制<code>View</code>视图</p>
<table>
<thead>
<tr>
<th>View类型</th>
<th>draw过程</th>
</tr>
</thead>
<tbody><tr>
<td>单一View</td>
<td>只需要绘制自身（含背景、内容）和装饰即可</td>
</tr>
<tr>
<td>ViewGroup</td>
<td>1.ViewGroup绘制自身（含背景、内容）；<br>2.ViewGroup遍历子View&amp;绘制其所有子View；<br>（含子View）（类似于单一View的draw过程）<br>3.ViewGroup绘制装饰（滚动指示器、滚动条、和前景）</td>
</tr>
</tbody></table>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220914225444742.png" alt="image-20220914225444742"></p>
<p><a href="https://blog.csdn.net/carson_ho/article/details/56011153">自定义View Draw过程</a></p>
<h3 id="4、实例"><a href="#4、实例" class="headerlink" title="4、实例"></a>4、实例</h3><p><strong>使用场景</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>使用场景</th>
<th>实现方式</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>继承特定view<br><code>自定义单一View</code></td>
<td>拓展某种已有View的功能</td>
<td>在原有View的基础增加功能 <br>（较容易）</td>
<td>不需要自己支持wrap_content&amp;padding</td>
</tr>
<tr>
<td>继承Vew<br><code>自定义单一View</code></td>
<td>实现不规则的效果、自定义控件<br><code>（如不规则图形：圆）</code></td>
<td>通过绘制的方式实现 <br>即重写onDraw（）</td>
<td>需票自己支技持wrap_content&amp;pacding<br>（不需要支持margin，因为margin属性是由父容器决定的）</td>
</tr>
<tr>
<td>继承特定ViewGroup<br><code>自定义ViewGroup</code></td>
<td>拓展某种布局的布局方式<br> <code>（如：下雨效果）</code></td>
<td>在原有ViewGroup的基础组合<br>较容易</td>
<td>与自定义ViewGroup，更加简单，但自由度不高</td>
</tr>
<tr>
<td>继承ViewGroup<br><code>自定义ViewGroup</code></td>
<td>实现不规则效果、自定义布局<be>下雨效果</td>
<td>MewGroup&amp;子View的measure、layout过程<br>较复杂</td>
<td>·需要自己支持wrap_content&amp;padding&amp;margin；<br>更加接近View的底层</td>
</tr>
</tbody></table>
<p><strong>注意事项</strong></p>
<ol>
<li><p>支持特殊属性：wrap_content、padding、margin</p>
</li>
<li><p>支持wrap_content<br>如果不在<code>onMeasure（）</code>中对<code>wrap_content</code>作特殊处理，那么<code>wrap_content</code>属性将失效</p>
<p><a href="https://www.jianshu.com/p/ca118d704b5e">为什么你设置的wrap_content不起作用？</a></p>
</li>
<li><p>支持padding &amp; margin<br>如果不支持，那么<code>padding</code>和<code>margin</code>（ViewGroup情况）的属性将失效</p>
</li>
</ol>
<blockquote>
<ol>
<li>对于继承View的控件，padding是在draw()中处理</li>
<li>对于继承ViewGroup的控件，padding和margin会直接影响measure和layout过程</li>
</ol>
</blockquote>
<ol start="2">
<li><p>多线程直接使用post方式：避免使用Handler等其他方式</p>
<p>View的内部本身提供了post系列的方法，完全可以替代Handler的作用，使用起来更加方便、直接。</p>
</li>
<li><p>避免内存泄漏：线程、动画即时停止</p>
<p><strong>当View退出或不可见时，记得及时停止该View包含的线程和动画，否则会造成内存泄露问题</strong>。</p>
<blockquote>
<p>启动或停止线程/ 动画的方式：</p>
<ol>
<li>启动线程/ 动画：使用view.onAttachedToWindow（），因为该方法调用的时机是当包含View的Activity启动的时刻</li>
<li>停止线程/ 动画：使用view.onDetachedFromWindow（），因为该方法调用的时机是当包含View的Activity退出或当前View被remove的时刻</li>
</ol>
</blockquote>
</li>
<li><p>处理好滑动冲突，View带有滑动嵌套的情况</p>
<p>当View带有滑动嵌套情况时，必须要处理好滑动冲突，否则会严重影响View的显示效果。</p>
</li>
</ol>
<p><strong>具体步骤</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="comment">//画笔</span></span><br><span class="line">    Paint mPaint;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, <span class="meta">@Nullable</span> AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画笔初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建画笔</span></span><br><span class="line">        mPaint = <span class="keyword">new</span> Paint();</span><br><span class="line">        <span class="comment">//设置画笔颜色</span></span><br><span class="line">        mPaint.setColor(Color.BLUE);</span><br><span class="line">        <span class="comment">//设置画笔宽度 10px</span></span><br><span class="line">        mPaint.setStrokeWidth(<span class="number">5f</span>);</span><br><span class="line">        <span class="comment">//设置画笔模式：填充</span></span><br><span class="line">        mPaint.setStyle(Paint.Style.FILL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">        <span class="comment">//支持padding</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> paddingLeft = getPaddingLeft();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> paddingRight = getPaddingRight();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> paddingTop = getPaddingTop();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> paddingBottom = getPaddingBottom();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取控件的高度和宽度</span></span><br><span class="line">        <span class="keyword">int</span> width = getWidth() - paddingLeft-paddingRight;</span><br><span class="line">        <span class="keyword">int</span> height = getHeight() - paddingTop - paddingBottom;</span><br><span class="line">        <span class="comment">//设置圆的半径=宽，高最小值的1/2</span></span><br><span class="line">        <span class="keyword">int</span> r =Math.min(width,height)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//画出圆(蓝色)</span></span><br><span class="line">        <span class="comment">//圆心= 控件的中央，半径=r</span></span><br><span class="line"></span><br><span class="line">        canvas.drawCircle(paddingLeft+width/<span class="number">2</span>,paddingTop+height/<span class="number">2</span>,r,mPaint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;com.example.cutomview.CustomViewActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.example.cutomview.MyView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;@color/design_default_color_secondary&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;150dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:padding</span>=<span class="string">&quot;20dp&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>自定义属性</strong></p>
<ol>
<li><p>在values目录下创建自定义属性的xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--自定义属性集合:CircleView--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--在该集合下,设置不同的自定义属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">&quot;CircleView&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--在attr标签下设置需要的自定义属性--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--此处定义了一个设置图形的颜色:circle_color属性,格式是color,代表颜色--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--格式有很多种,如资源id(reference)等等--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;circle_color&quot;</span> <span class="attr">format</span>=<span class="string">&quot;color&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>自定义类型</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;-- 1. reference：使用某一资源ID --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">&quot;名称&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;background&quot;</span> <span class="attr">format</span>=<span class="string">&quot;reference&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line">// 使用格式</span><br><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;42dip&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;42dip&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;@drawable/图片ID&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;--  2. color：颜色值 --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">&quot;名称&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;textColor&quot;</span> <span class="attr">format</span>=<span class="string">&quot;color&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line">// 格式使用</span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;42dip&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;42dip&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:textColor</span>=<span class="string">&quot;#00FF00&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;-- 3. boolean：布尔值 --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">&quot;名称&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;focusable&quot;</span> <span class="attr">format</span>=<span class="string">&quot;boolean&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line">// 格式使用</span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;42dip&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;42dip&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:focusable</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;-- 4. dimension：尺寸值 --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">&quot;名称&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;layout_width&quot;</span> <span class="attr">format</span>=<span class="string">&quot;dimension&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line">// 格式使用：</span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;42dip&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;42dip&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;-- 5. float：浮点值 --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">&quot;AlphaAnimation&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;fromAlpha&quot;</span> <span class="attr">format</span>=<span class="string">&quot;float&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;toAlpha&quot;</span> <span class="attr">format</span>=<span class="string">&quot;float&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line">// 格式使用</span><br><span class="line"><span class="tag">&lt;<span class="name">alpha</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromAlpha</span>=<span class="string">&quot;1.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toAlpha</span>=<span class="string">&quot;0.7&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;-- 6. integer：整型值 --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">&quot;AnimatedRotateDrawable&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;frameDuration&quot;</span> <span class="attr">format</span>=<span class="string">&quot;integer&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;framesCount&quot;</span> <span class="attr">format</span>=<span class="string">&quot;integer&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line">// 格式使用</span><br><span class="line"><span class="tag">&lt;<span class="name">animated-rotate</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:frameDuration</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:framesCount</span>=<span class="string">&quot;12&quot;</span></span></span><br><span class="line"><span class="tag"> /&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;-- 7. string：字符串 --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">&quot;MapView&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;apiKey&quot;</span> <span class="attr">format</span>=<span class="string">&quot;string&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line">// 格式使用</span><br><span class="line"><span class="tag">&lt;<span class="name">com.google.android.maps.MapView</span></span></span><br><span class="line"><span class="tag"> <span class="attr">android:apiKey</span>=<span class="string">&quot;0jOkQ80oD1JL9C6HAja99uGXCRiS2CGjKO_bc_g&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;-- 8. fraction：百分数 --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">&quot;RotateDrawable&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;pivotX&quot;</span> <span class="attr">format</span>=<span class="string">&quot;fraction&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;pivotY&quot;</span> <span class="attr">format</span>=<span class="string">&quot;fraction&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line">// 格式使用</span><br><span class="line"><span class="tag">&lt;<span class="name">rotate</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotX</span>=<span class="string">&quot;200%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotY</span>=<span class="string">&quot;300%&quot;</span></span></span><br><span class="line"><span class="tag"> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;-- 9. enum：枚举值 --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">&quot;名称&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;orientation&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enum</span> <span class="attr">name</span>=<span class="string">&quot;horizontal&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enum</span> <span class="attr">name</span>=<span class="string">&quot;vertical&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">attr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line">// 格式使用</span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;fill_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;fill_parent&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;-- 10. flag：位或运算 --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">&quot;名称&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;windowSoftInputMode&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">flag</span> <span class="attr">name</span>=<span class="string">&quot;stateUnspecified&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">flag</span> <span class="attr">name</span>=<span class="string">&quot;stateUnchanged&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">flag</span> <span class="attr">name</span>=<span class="string">&quot;stateHidden&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">flag</span> <span class="attr">name</span>=<span class="string">&quot;stateAlwaysHidden&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">flag</span> <span class="attr">name</span>=<span class="string">&quot;stateVisible&quot;</span> <span class="attr">value</span>=<span class="string">&quot;4&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">flag</span> <span class="attr">name</span>=<span class="string">&quot;stateAlwaysVisible&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">flag</span> <span class="attr">name</span>=<span class="string">&quot;adjustUnspecified&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0x00&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">flag</span> <span class="attr">name</span>=<span class="string">&quot;adjustResize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0x10&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">flag</span> <span class="attr">name</span>=<span class="string">&quot;adjustPan&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0x20&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">flag</span> <span class="attr">name</span>=<span class="string">&quot;adjustNothing&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0x30&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">attr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span>、</span><br><span class="line">// 使用</span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.StyleAndThemeActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:windowSoftInputMode</span>=<span class="string">&quot;stateUnspecified | stateUnchanged　|　stateHidden&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;-- 特别注意：属性定义时可以指定多种类型值 --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">&quot;名称&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;background&quot;</span> <span class="attr">format</span>=<span class="string">&quot;reference|color&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br><span class="line">// 使用</span><br><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;42dip&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;42dip&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">&quot;@drawable/图片ID|#00FF00&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="2">
<li><p>在自定义View的构造方法中解析自定义属性的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该构造函数需要重写</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CircleView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>(context, attrs,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 原来是：super(context,attrs);</span></span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CircleView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载自定义属性集合CircleView</span></span><br><span class="line">        TypedArray a = context.obtainStyledAttributes(attrs,R.styleable.CircleView);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析集合中的属性circle_color属性</span></span><br><span class="line">        <span class="comment">// 该属性的id为:R.styleable.CircleView_circle_color</span></span><br><span class="line">        <span class="comment">// 将解析的属性传入到画圆的画笔颜色变量当中（本质上是自定义画圆画笔的颜色）</span></span><br><span class="line">        <span class="comment">// 第二个参数是默认设置颜色（即无指定circle_color情况下使用）</span></span><br><span class="line">        mColor = a.getColor(R.styleable.CircleView_circle_color,Color.RED);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析后释放资源</span></span><br><span class="line">        a.recycle();</span><br><span class="line"></span><br><span class="line">        init();</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="3">
<li><p>在布局文件中使用自定义属性</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">  &lt;!<span class="attr">--</span>必须添加<span class="attr">schemas</span>声明才能使用自定义属性<span class="attr">--</span>&gt;</span></span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    tools:context=&quot;scut.carson_ho.diy_view.MainActivity&quot;</span><br><span class="line">    &gt;</span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!-- 注意添加自定义View组件的标签名：包名 + 自定义View类名--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  控件背景设置为黑色--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scut.carson_ho.diy_view.CircleView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">&quot;#000000&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:padding</span>=<span class="string">&quot;30dp&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    &lt;!<span class="attr">--</span>设置自定义颜色<span class="attr">--</span>&gt;</span></span><br><span class="line">        app:circle_color=&quot;#FF4081&quot;</span><br><span class="line">         /&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="5、canvas类"><a href="#5、canvas类" class="headerlink" title="5、canvas类"></a>5、canvas类</h3><p>定义：画布，一种绘制时的规则。（Android平台2D图形绘制基础）</p>
<p>作用：规定绘制内容时的规则&amp;内容</p>
<p>本质：</p>
<ul>
<li>绘制内容是根据<strong>画布（Canvas）的规定</strong>绘制在<strong>屏幕</strong>上的</li>
<li>画布（Canvas）只是绘制时的规则，但内容实际上是绘制在屏幕上的</li>
</ul>
<p>案例：先画一个矩形（蓝色）；然后移动画布；再画一个矩形（红色）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 画一个矩形(蓝色)</span></span><br><span class="line">canvas.drawRect(<span class="number">100</span>, <span class="number">100</span>, <span class="number">150</span>, <span class="number">150</span>, mPaint1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将画布的原点移动到(400,500)</span></span><br><span class="line">canvas.translate(<span class="number">400</span>,<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再画一个矩形(红色)</span></span><br><span class="line">canvas.drawRect(<span class="number">100</span>, <span class="number">100</span>, <span class="number">150</span>, <span class="number">150</span>, mPaint2);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220914225549360.png" alt="image-20220914225549360"></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220914225642316.png" alt="image-20220914225642316"></p>
<h4 id="1、基础-1"><a href="#1、基础-1" class="headerlink" title="1、基础"></a>1、基础</h4><h5 id="Paint类"><a href="#Paint类" class="headerlink" title="Paint类"></a>Paint类</h5><p>定义：画笔</p>
<p>作用：确定绘制内容的具体效果(颜色、大小)</p>
<blockquote>
<p>绘制内容时需要使用画笔</p>
</blockquote>
<p>用法：</p>
<ol>
<li>创建画笔对象</li>
<li>画笔设置，即设置绘制内容 的具体效果(颜色、大小)</li>
<li>初始化画笔(尽量选择在View的构建函数)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤1：创建一个画笔</span></span><br><span class="line"><span class="keyword">private</span> Paint mPaint = <span class="keyword">new</span> Paint();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：初始化画笔</span></span><br><span class="line"><span class="comment">// 根据需求设置画笔的各种属性，具体如下：</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPaint</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置最基本的属性</span></span><br><span class="line">        <span class="comment">// 设置画笔颜色</span></span><br><span class="line">        <span class="comment">// 可直接引入Color类，如Color.red等</span></span><br><span class="line">        mPaint.setColor(<span class="keyword">int</span> color); </span><br><span class="line">        <span class="comment">// 设置画笔模式</span></span><br><span class="line">         mPaint.setStyle(Style style); </span><br><span class="line">        <span class="comment">// Style有3种类型：</span></span><br><span class="line">        <span class="comment">// 类型1：Paint.Style.FILLANDSTROKE（描边+填充）</span></span><br><span class="line">        <span class="comment">// 类型2：Paint.Style.FILL（只填充不描边）</span></span><br><span class="line">        <span class="comment">// 类型3：Paint.Style.STROKE（只描边不填充）</span></span><br><span class="line">        <span class="comment">// 具体差别请看下图：</span></span><br><span class="line">        <span class="comment">// 特别注意：前两种就相差一条边</span></span><br><span class="line">        <span class="comment">// 若边细是看不出分别的；边粗就相当于加粗       </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置画笔的粗细</span></span><br><span class="line">        mPaint.setStrokeWidth(<span class="keyword">float</span> width)       </span><br><span class="line">        <span class="comment">// 如设置画笔宽度为10px</span></span><br><span class="line">        mPaint.setStrokeWidth(<span class="number">10f</span>);    </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不常设置的属性</span></span><br><span class="line">        <span class="comment">// 得到画笔的颜色     </span></span><br><span class="line">        mPaint.getColor()      </span><br><span class="line">        <span class="comment">// 设置Shader</span></span><br><span class="line">        <span class="comment">// 即着色器，定义了图形的着色、外观</span></span><br><span class="line">        <span class="comment">// 可以绘制出多彩的图形</span></span><br><span class="line">        <span class="comment">// 具体请参考文章：http://blog.csdn.net/iispring/article/details/50500106</span></span><br><span class="line">        Paint.setShader(Shader shader)  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置画笔的a,r,p,g值</span></span><br><span class="line">       mPaint.setARGB(<span class="keyword">int</span> a, <span class="keyword">int</span> r, <span class="keyword">int</span> g, <span class="keyword">int</span> b)      </span><br><span class="line">         <span class="comment">//设置透明度</span></span><br><span class="line">        mPaint.setAlpha(<span class="keyword">int</span> a)   </span><br><span class="line">       <span class="comment">//得到画笔的Alpha值</span></span><br><span class="line">        mPaint.getAlpha()        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对字体进行设置（大小、颜色）</span></span><br><span class="line">        <span class="comment">//设置字体大小</span></span><br><span class="line">          mPaint.setTextSize(<span class="keyword">float</span> textSize)       </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 文字Style三种模式：</span></span><br><span class="line">          mPaint.setStyle(Style style); </span><br><span class="line">        <span class="comment">// 类型1：Paint.Style.FILLANDSTROKE（描边+填充）</span></span><br><span class="line">        <span class="comment">// 类型2：Paint.Style.FILL（只填充不描边）</span></span><br><span class="line">        <span class="comment">// 类型3：Paint.Style.STROKE（只描边不填充） </span></span><br><span class="line">        </span><br><span class="line">      <span class="comment">// 设置对齐方式   </span></span><br><span class="line">      setTextAlign（）</span><br><span class="line">      <span class="comment">// LEFT：左对齐</span></span><br><span class="line">      <span class="comment">// CENTER：居中对齐</span></span><br><span class="line">      <span class="comment">// RIGHT：右对齐</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置文本的下划线</span></span><br><span class="line">          setUnderlineText(<span class="keyword">boolean</span> underlineText)      </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置文本的删除线</span></span><br><span class="line">        setStrikeThruText(<span class="keyword">boolean</span> strikeThruText)    </span><br><span class="line"></span><br><span class="line">         <span class="comment">//设置文本粗体</span></span><br><span class="line">        setFakeBoldText(<span class="keyword">boolean</span> fakeBoldText)  </span><br><span class="line">        </span><br><span class="line">           <span class="comment">// 设置斜体</span></span><br><span class="line">        Paint.setTextSkewX(-<span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置文字阴影</span></span><br><span class="line">        Paint.setShadowLayer(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,Color.YELLOW);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤3：在构造函数中初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CarsonView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        initPaint();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>Style模式效果</strong>如下：</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220914225703874.png" alt="image-20220914225703874"></p>
<h5 id="2、Path类"><a href="#2、Path类" class="headerlink" title="2、Path类"></a>2、Path类</h5><p>定义：路径，即无数个点连起来的线</p>
<p>作用：设置绘制的顺序 &amp; 区域</p>
<blockquote>
<p>Path只用于描述顺序 &amp; 区域，单使用Path无法产生效果</p>
</blockquote>
<p>场景：应用场景：绘制复杂图形（如心形、五角星等等）</p>
<blockquote>
<p>Path类封装了由直线和曲线（2、3次贝塞尔曲线）构成的几何路径。</p>
</blockquote>
<p><strong>如何判断点在图形内还是图形外</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>判定条件</th>
</tr>
</thead>
<tbody><tr>
<td>奇偶规则</td>
<td>从任意位置p作一条射线，根据与图形的边相交的点数进行判断：<br/><br/>a.若相交的点数为奇数，则认为p为图形内部点；<br/><br/>b.若为偶，则认为为图形外部点。</td>
</tr>
<tr>
<td>非零环绕数规则</td>
<td>从任意位置p作一条射线，当p点沿射线方向移动时，对在每个方向上穿过射线的边计数<br>1.每当图形的边从右到左穿过射线时，环绕数加1；从左到右时，环绕数减1。<br>b.若环绕数为非零，则p为内部点；否则，为外部点。</td>
</tr>
</tbody></table>
<p><strong>具体用法</strong></p>
<ul>
<li><p>对象创建</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用Path首先要new一个Path对象</span></span><br><span class="line"><span class="comment">// Path的起点默认为坐标为(0,0)</span></span><br><span class="line">Path path = <span class="keyword">new</span> <span class="built_in">Path</span>();</span><br><span class="line"><span class="comment">// 特别注意：建全局Path对象，在onDraw()按需修改；尽量不要在onDraw()方法里new对象</span></span><br><span class="line"><span class="comment">// 原因：若View频繁刷新，就会频繁创建对象，拖慢刷新速度。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><a href="https://www.jianshu.com/p/2c19abde958c">自定义View Path类全面解析)</a></p>
<h4 id="2、Canvas的使用"><a href="#2、Canvas的使用" class="headerlink" title="2、Canvas的使用"></a>2、Canvas的使用</h4><h5 id="1、对象的创建-amp-获取"><a href="#1、对象的创建-amp-获取" class="headerlink" title="1、对象的创建&amp;获取"></a>1、对象的创建&amp;获取</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="comment">// 利用空构造方法直接创建对象</span></span><br><span class="line">Canvas canvas = <span class="keyword">new</span> Canvas()；</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="comment">// 通过传入装载画布Bitmap对象创建Canvas对象</span></span><br><span class="line"><span class="comment">// CBitmap上存储所有绘制在Canvas的信息</span></span><br><span class="line">Canvas canvas = <span class="keyword">new</span> Canvas(bitmap)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3</span></span><br><span class="line"><span class="comment">// 通过重写View.onDraw（）创建Canvas对象</span></span><br><span class="line"><span class="comment">// 在该方法里可以获得这个View对应的Canvas对象</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">        <span class="comment">//在这里获取Canvas对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法4:官方推荐</span></span><br><span class="line"><span class="comment">// 在SurfaceView里画图时创建Canvas对象</span></span><br><span class="line"></span><br><span class="line">        SurfaceView surfaceView = <span class="keyword">new</span> SurfaceView(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 从SurfaceView的surfaceHolder里锁定获取Canvas</span></span><br><span class="line">        SurfaceHolder surfaceHolder = surfaceView.getHolder();</span><br><span class="line">        <span class="comment">//获取Canvas</span></span><br><span class="line">        Canvas c = surfaceHolder.lockCanvas();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...（进行Canvas操作）</span></span><br><span class="line">        <span class="comment">// Canvas操作结束之后解锁并执行Canvas</span></span><br><span class="line">        surfaceHolder.unlockCanvasAndPost(c);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>SurfaceView里有一条线程是专门用于画图，所以方法4的<strong>画图性能最好，并适用于高质量的、刷新频率高的图形</strong></li>
<li>而方法3刷新频率低于方法3，<strong>但系统花销小，节省资源</strong></li>
</ul>
</blockquote>
<h5 id="2、绘制方法使用"><a href="#2、绘制方法使用" class="headerlink" title="2、绘制方法使用"></a>2、绘制方法使用</h5><h6 id="绘制颜色"><a href="#绘制颜色" class="headerlink" title="绘制颜色"></a>绘制颜色</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 传入一个Color类的常量参数来设置画布颜色</span></span><br><span class="line"> <span class="comment">// 绘制蓝色</span></span><br><span class="line">canvas.drawColor(Color.BLUE); </span><br></pre></td></tr></table></figure>



<h6 id="绘制基本图形"><a href="#绘制基本图形" class="headerlink" title="绘制基本图形"></a>绘制基本图形</h6><ul>
<li><p>点</p>
<p>在某个坐标处绘制点(可画一个点或一组点)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 特别注意：需要用到画笔Paint</span></span><br><span class="line"><span class="comment">// 所以之前记得创建画笔</span></span><br><span class="line"><span class="comment">// 为了区分，这里使用了两个不同颜色的画笔</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 描绘一个点</span></span><br><span class="line"><span class="comment">// 在坐标(200,200)处</span></span><br><span class="line">canvas.drawPoint(<span class="number">300</span>, <span class="number">300</span>, mPaint1);    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制一组点，坐标位置由float数组指定</span></span><br><span class="line"><span class="comment">// 此处画了3个点，位置分别是：（600,500）、（600,600）、（600,700）</span></span><br><span class="line">canvas.drawPoints(<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;         </span><br><span class="line">                <span class="number">600</span>,<span class="number">500</span>,</span><br><span class="line">                <span class="number">600</span>,<span class="number">600</span>,</span><br><span class="line">                <span class="number">600</span>,<span class="number">700</span></span><br><span class="line">        &#125;,mPaint2);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/bdcb5473fd279748984e51430d7af1da.png" alt="效果图"></p>
</li>
<li><p>直线</p>
<p>原理：两点（初始点 &amp; 结束点）确定一条直线</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 画一条直线</span></span><br><span class="line"><span class="comment">// 在坐标(100,200)，(700,200)之间绘制一条直线</span></span><br><span class="line">   canvas.drawLine(<span class="number">100</span>,<span class="number">200</span>,<span class="number">700</span>,<span class="number">200</span>,mPaint1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制一组线</span></span><br><span class="line"><span class="comment">// 在坐标(400,500)，(500,500)之间绘制直线1</span></span><br><span class="line"><span class="comment">// 在坐标(400,600)，(500,600)之间绘制直线2</span></span><br><span class="line">        canvas.drawLines(<span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</span><br><span class="line">                <span class="number">400</span>,<span class="number">500</span>,<span class="number">500</span>,<span class="number">500</span>,</span><br><span class="line">                <span class="number">400</span>,<span class="number">600</span>,<span class="number">500</span>,<span class="number">600</span></span><br><span class="line">        &#125;,mPaint2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/506dbc83a1709ca22107650c422f73a7.png" alt="效果图"><br>hexo </p>
</li>
<li><p>矩形</p>
<p>原理：矩形的对角线顶点确定一个矩形(一般是采用左上角和右下角的两个点的坐标。)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关于绘制矩形，Canvas提供了三种重载方法</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 方法1：直接传入两个顶点的坐标</span></span><br><span class="line">       <span class="comment">// 两个顶点坐标分别是：（100,100），（800,400）</span></span><br><span class="line">        canvas.drawRect(<span class="number">100</span>,<span class="number">100</span>,<span class="number">800</span>,<span class="number">400</span>,mPaint);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法2：将两个顶点坐标封装为Rect</span></span><br><span class="line">        Rect rect = <span class="keyword">new</span> Rect(<span class="number">100</span>,<span class="number">100</span>,<span class="number">800</span>,<span class="number">400</span>);</span><br><span class="line">        canvas.drawRect(rect,mPaint);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法3：将两个顶点坐标封装为RectF</span></span><br><span class="line">        RectF rectF = <span class="keyword">new</span> RectF(<span class="number">100</span>,<span class="number">100</span>,<span class="number">800</span>,<span class="number">400</span>);</span><br><span class="line">        canvas.drawRect(rectF,mPaint);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 特别注意：Rect类和RectF类的区别</span></span><br><span class="line">        <span class="comment">// 精度不同：Rect = int &amp; RectF = float</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 三种方法画出来的效果是一样的。</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/f6e1ad1a89694ec844cc256a848840e4.png" alt="img"></p>
</li>
</ul>
<ul>
<li><p>圆角矩形</p>
<p>原理：矩形的对角线顶点确定一个矩形</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1：直接传入两个顶点的坐标</span></span><br><span class="line"><span class="comment">// API21时才可使用</span></span><br><span class="line"><span class="comment">// 第5、6个参数：rx、ry是圆角的参数，下面会详细描述</span></span><br><span class="line">canvas.drawRoundRect(<span class="number">100</span>,<span class="number">100</span>,<span class="number">800</span>,<span class="number">400</span>,<span class="number">30</span>,<span class="number">30</span>,mPaint);</span><br><span class="line">        </span><br><span class="line"> <span class="comment">// 方法2：使用RectF类</span></span><br><span class="line"> RectF rectF = <span class="keyword">new</span> RectF(<span class="number">100</span>,<span class="number">100</span>,<span class="number">800</span>,<span class="number">400</span>);</span><br><span class="line"> canvas.drawRoundRect(rectF,<span class="number">30</span>,<span class="number">30</span>,mPaint);</span><br><span class="line">       </span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/ac09b634d8f6aa9ee2d3864125883915.png" alt="img"></p>
<p>圆角矩形的角是椭圆的圆弧，rx 和 ry实际上是椭圆的两个半径</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/e05ccb863e03a7cfcbfd1839c953d98b.png" alt="img"></p>
<blockquote>
<p>实际上，在rx为宽度的一半，ry为高度的一半时，刚好是一个椭圆；但由于当rx大于宽度一半，ry大于高度一半时，无法计算出圆弧，所以drawRoundRect对大于该数值的参数进行了修正，<strong>凡是大于一半的参数均按照一半来处理</strong></p>
</blockquote>
</li>
<li><p>绘制椭圆</p>
<p>原理：矩形的对角线顶点确定矩形，根据传入矩形的长宽作为长轴和短轴画椭圆</p>
<blockquote>
<ol>
<li>椭圆传入的参数和矩形是一样的；</li>
<li>绘制椭圆实际上是绘制一个矩形的内切图形。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1：使用RectF类</span></span><br><span class="line">RectF rectF = <span class="keyword">new</span> RectF(<span class="number">100</span>,<span class="number">100</span>,<span class="number">800</span>,<span class="number">400</span>);</span><br><span class="line">canvas.drawOval(rectF,mPaint);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 方法2：直接传入与矩形相关的参数</span></span><br><span class="line">canvas.drawOval(<span class="number">100</span>,<span class="number">100</span>,<span class="number">800</span>,<span class="number">400</span>,mPaint);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 为了方便表示，画一个和椭圆一样参数的矩形</span></span><br><span class="line"> canvas.drawRect(<span class="number">100</span>,<span class="number">100</span>,<span class="number">800</span>,<span class="number">400</span>,mPaint);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/698dd2b5eacf248dcec544401c8ff106.png" alt="img"></p>
</li>
</ul>
<ul>
<li><p>绘制圆</p>
<p>原理：圆心坐标+半径决定圆</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数说明：</span></span><br><span class="line"><span class="comment">// 1、2：圆心坐标</span></span><br><span class="line"><span class="comment">// 3：半径</span></span><br><span class="line"><span class="comment">// 4：画笔</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制一个圆心坐标在(500,500)，半径为400 的圆。</span></span><br><span class="line">    canvas.drawCircle(<span class="number">500</span>,<span class="number">500</span>,<span class="number">400</span>,mPaint);  </span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/4e37a12f397880862ef25465504b1f85.png" alt="img"></p>
</li>
<li><p>绘制圆弧</p>
<p>原理：通过圆弧角度的起始位置和扫过的角度确定圆弧</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绘制圆弧共有两个方法</span></span><br><span class="line"><span class="comment">// 相比于绘制椭圆，绘制圆弧多了三个参数：</span></span><br><span class="line">startAngle  <span class="comment">// 确定角度的起始位置</span></span><br><span class="line">sweepAngle <span class="comment">// 确定扫过的角度</span></span><br><span class="line">useCenter   <span class="comment">// 是否使用中心（下面会详细说明）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawArc</span><span class="params">(<span class="meta">@NonNull</span> RectF oval, <span class="keyword">float</span> startAngle, <span class="keyword">float</span> sweepAngle, <span class="keyword">boolean</span> useCenter, <span class="meta">@NonNull</span> Paint paint)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawArc</span><span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> startAngle,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">float</span> sweepAngle, <span class="keyword">boolean</span> useCenter, <span class="meta">@NonNull</span> Paint paint)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下示例：绘制两个起始角度为0度、扫过90度的圆弧</span></span><br><span class="line"><span class="comment">// 两者的唯一区别就是是否使用了中心点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制圆弧1(无使用中心)</span></span><br><span class="line">        RectF rectF = <span class="keyword">new</span> RectF(<span class="number">100</span>, <span class="number">100</span>, <span class="number">800</span>,<span class="number">400</span>);</span><br><span class="line">        <span class="comment">// 绘制背景矩形</span></span><br><span class="line">        canvas.drawRect(rectF, mPaint1);</span><br><span class="line">        <span class="comment">// 绘制圆弧</span></span><br><span class="line">        canvas.drawArc(rectF, <span class="number">0</span>, <span class="number">90</span>, <span class="keyword">false</span>, mPaint2);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 绘制圆弧2(使用中心)</span></span><br><span class="line">        RectF rectF2 = <span class="keyword">new</span> RectF(<span class="number">100</span>,<span class="number">600</span>,<span class="number">800</span>,<span class="number">900</span>);</span><br><span class="line">        <span class="comment">// 绘制背景矩形</span></span><br><span class="line">        canvas.drawRect(rectF2, mPaint1);</span><br><span class="line">        <span class="comment">// 绘制圆弧</span></span><br><span class="line">        canvas.drawArc(rectF2,<span class="number">0</span>,<span class="number">90</span>,<span class="keyword">true</span>,mPaint2);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/e12953090d7c113f0251d384fd5aeb83.png" alt="img"></p>
<blockquote>
<ul>
<li>不使用中心点：圆弧的形状 = （起、止点连线+圆弧）构成的面积</li>
<li>使用中心店：圆弧面积 = （起点、圆心连线 + 止点、圆心连线+圆弧）构成的面积</li>
</ul>
</blockquote>
</li>
</ul>
<h6 id="绘制文字"><a href="#绘制文字" class="headerlink" title="绘制文字"></a>绘制文字</h6><ul>
<li><p>指定文本开始的位置</p>
<blockquote>
<p>即指定文本基线位置<br>基线x默认在字符串左侧，基线y默认在字符串下方</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数text：要绘制的文本</span></span><br><span class="line"><span class="comment">// 参数x，y：指定文本开始的位置（坐标）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数paint：设置的画笔属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawText</span> <span class="params">(String text, <span class="keyword">float</span> x, <span class="keyword">float</span> y, Paint paint)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 实例</span></span></span><br><span class="line"><span class="function">canvas.<span class="title">drawText</span><span class="params">(<span class="string">&quot;abcdefg&quot;</span>,<span class="number">300</span>,<span class="number">400</span>,mPaint1)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅绘制文本的一部分</span></span><br><span class="line"><span class="comment">// 参数start，end：指定绘制文本的位置</span></span><br><span class="line"><span class="comment">// 位置以下标标识，由0开始</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawText</span> <span class="params">(String text, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">float</span> x, <span class="keyword">float</span> y, Paint paint)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawText</span> <span class="params">(CharSequence text, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">float</span> x, <span class="keyword">float</span> y, Paint paint)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 对于字符数组char[]</span></span></span><br><span class="line"><span class="function"><span class="comment">// 截取文本使用起始位置(index)和长度(count)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawText</span> <span class="params">(<span class="keyword">char</span>[] text, <span class="keyword">int</span> index, <span class="keyword">int</span> count, <span class="keyword">float</span> x, <span class="keyword">float</span> y, Paint paint)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 实例：绘制从位置1-3的文本</span></span></span><br><span class="line"><span class="function">canvas.<span class="title">drawText</span><span class="params">(<span class="string">&quot;abcdefg&quot;</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">300</span>,<span class="number">400</span>,mPaint1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符数组情况</span></span><br><span class="line"><span class="comment">// 字符数组(要绘制的内容)</span></span><br><span class="line"><span class="keyword">char</span>[] chars = <span class="string">&quot;abcdefg&quot;</span>.toCharArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数为 (字符数组 起始坐标 截取长度 基线x 基线y 画笔)</span></span><br><span class="line">canvas.drawText(chars,<span class="number">1</span>,<span class="number">3</span>,<span class="number">200</span>,<span class="number">500</span>,textPaint);</span><br><span class="line"><span class="comment">// 效果同上</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/bd65ccd48f3dbfce7fd5c6778eb8fce8.png" alt="效果图"></p>
</li>
<li><p>指定每个文字的位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数text：绘制的文本</span></span><br><span class="line"><span class="comment">// 参数pos：数组类型，存放每个字符的位置（坐标）</span></span><br><span class="line"><span class="comment">// 注意：必须指定所有字符位置</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawPosText</span> <span class="params">(String text, <span class="keyword">float</span>[] pos, Paint paint)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 对于字符数组char[],可以截取部分文本进行绘制</span></span></span><br><span class="line"><span class="function"><span class="comment">// 截取文本使用起始位置(index)和长度(count)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawPosText</span> <span class="params">(<span class="keyword">char</span>[] text, <span class="keyword">int</span> index, <span class="keyword">int</span> count, <span class="keyword">float</span>[] pos, Paint paint)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 特别注意：</span></span></span><br><span class="line"><span class="function"><span class="comment">// 1. 在字符数量较多时，使用会导致卡顿</span></span></span><br><span class="line"><span class="function"><span class="comment">// 2. 不支持emoji等特殊字符，不支持字形组合与分解</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="comment">// 实例</span></span></span><br><span class="line"><span class="function">  canvas.<span class="title">drawPosText</span><span class="params">(<span class="string">&quot;abcde&quot;</span>, new <span class="keyword">float</span>[]&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="number">100</span>, <span class="number">100</span>,    // 第一个字符位置</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="number">200</span>, <span class="number">200</span>,    // 第二个字符位置</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="number">300</span>, <span class="number">300</span>,    // ...</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="number">400</span>, <span class="number">400</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="number">500</span>, <span class="number">500</span></span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;, mPaint1)</span>；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 数组情况（绘制部分文本）</span></span></span><br><span class="line"><span class="function">       <span class="keyword">char</span>[] chars </span>= <span class="string">&quot;abcdefg&quot;</span>.toCharArray();</span><br><span class="line"></span><br><span class="line">        canvas.drawPosText(chars, <span class="number">1</span>, <span class="number">3</span>, <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</span><br><span class="line">                <span class="number">300</span>, <span class="number">300</span>,    <span class="comment">// 指定的第一个字符位置</span></span><br><span class="line">                <span class="number">400</span>, <span class="number">400</span>,    <span class="comment">// 指定的第二个字符位置</span></span><br><span class="line">                <span class="number">500</span>, <span class="number">500</span>,    <span class="comment">// 指定的第三个字符位置</span></span><br><span class="line"></span><br><span class="line">        &#125;, mPaint1);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/6789a826988f93cc292b351ae583af83.png" alt="效果图"></p>
</li>
<li><p>指定路径，并根据路径绘制文字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      </span><br><span class="line"><span class="comment">// 在路径(540,750,640,450,840,600)写上&quot;在Path上写的字:Carson_Ho&quot;字样</span></span><br><span class="line">       <span class="comment">// 1.创建路径对象</span></span><br><span class="line">       Path path = <span class="keyword">new</span> Path();</span><br><span class="line">       <span class="comment">// 2. 设置路径轨迹</span></span><br><span class="line">       path.cubicTo(<span class="number">540</span>, <span class="number">750</span>, <span class="number">640</span>, <span class="number">450</span>, <span class="number">840</span>, <span class="number">600</span>);</span><br><span class="line">        <span class="comment">// 3. 画路径</span></span><br><span class="line">       canvas.drawPath(path,mPaint2);</span><br><span class="line">       <span class="comment">// 4. 画出在路径上的字</span></span><br><span class="line">       canvas.drawTextOnPath(<span class="string">&quot;在Path上写的字:Carson_Ho&quot;</span>, path, <span class="number">50</span>, <span class="number">0</span>, mPaint2);</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/27dbaad8f5a73a5b4cfdad09a73e29c4.png" alt="效果图"></p>
</li>
</ul>
<h6 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h6><h6 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h6><p><a href="https://carsonho.blog.csdn.net/article/details/60598775">自定义View Canvas类使用教程</a></p>
<h2 id="3、事件分发机制流程及原理"><a href="#3、事件分发机制流程及原理" class="headerlink" title="3、事件分发机制流程及原理"></a>3、事件分发机制流程及原理</h2><h2 id="4、动画类型"><a href="#4、动画类型" class="headerlink" title="4、动画类型"></a>4、动画类型</h2><h3 id="1、类型"><a href="#1、类型" class="headerlink" title="1、类型"></a>1、类型</h3><h4 id="1-1、视图动画-补间动画、卓帧动画"><a href="#1-1、视图动画-补间动画、卓帧动画" class="headerlink" title="1.1、视图动画(补间动画、卓帧动画)"></a>1.1、视图动画(补间动画、卓帧动画)</h4><h2 id="4、动画类型-1"><a href="#4、动画类型-1" class="headerlink" title="4、动画类型"></a>4、动画类型</h2><h3 id="1、类型-1"><a href="#1、类型-1" class="headerlink" title="1、类型"></a>1、类型</h3><ol>
<li>视图动画：补间动画、逐帧动画</li>
<li>属性动画</li>
</ol>
<h3 id="2、视图动画-补间动画、卓帧动画"><a href="#2、视图动画-补间动画、卓帧动画" class="headerlink" title="2、视图动画(补间动画、卓帧动画)"></a>2、视图动画(补间动画、卓帧动画)</h3><p>作用对象：视图(View)</p>
<p>具体分类：补间动画&amp;逐帧动画</p>
<h4 id="1、补间动画"><a href="#1、补间动画" class="headerlink" title="1、补间动画"></a>1、补间动画</h4><p><strong>核心类：</strong></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>原理</th>
<th>对应Animation的子类</th>
</tr>
</thead>
<tbody><tr>
<td>平移动画（Translate）</td>
<td>移动视图的位置</td>
<td>TranslateAnimation类</td>
</tr>
<tr>
<td>缩放动画（Scale）</td>
<td>放大/缩小视图的大小</td>
<td>ScaleAnimation类</td>
</tr>
<tr>
<td>旋转动画（Rotate）</td>
<td>旋转视图的角度</td>
<td>RotateAnimation类</td>
</tr>
<tr>
<td>透明度动画（Alpha）</td>
<td>改变视图的透明度</td>
<td>AlphaAnimation类</td>
</tr>
</tbody></table>
<p><strong>应用场景：</strong></p>
<ul>
<li>标准动画效果<ul>
<li>补间动画常用于视图View的一些标准动画效果：平移、旋转、缩放 &amp; 透明度；</li>
<li>除了常规的动画使用，补间动画还有一些特殊的应用场景。</li>
</ul>
</li>
<li>特殊应用场景<ul>
<li><code>Activity</code> 的切换效果（淡入淡出、左右滑动等）</li>
<li><code>Fragement</code> 的切换效果（淡入淡出、左右滑动等）</li>
<li>视图组（<code>ViewGroup</code>）中子元素的出场效果（淡入淡出、左右滑动等）</li>
</ul>
</li>
</ul>
<p><strong>使用方法：</strong></p>
<ul>
<li>xml：动画描述的可读性好</li>
<li>java：动画效果可动态创建</li>
</ul>
<p><strong>具体用法：</strong></p>
<ul>
<li><p>平移动画</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设置方式1：xml</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// 步骤1：在 res/anim的文件夹里创建动画效果.xml文件</span></span><br><span class="line"> <span class="comment">// 此处路径为res/anim/view_animation.xml</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 步骤2：根据不同动画效果的语法设置不同动画参数-view_animation.xml</span></span><br><span class="line">   &lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">   </span><br><span class="line">   &lt;translate xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">      <span class="comment">// 采用&lt;translate /&gt; 标签表示平移动画</span></span><br><span class="line">      <span class="comment">// 以下参数是4种动画效果的公共属性,即都有的属性</span></span><br><span class="line">      android:duration=<span class="string">&quot;3000&quot;</span> <span class="comment">// 动画持续时间（ms），必须设置，动画才有效果</span></span><br><span class="line">      android:startOffset =<span class="string">&quot;1000&quot;</span> <span class="comment">// 动画延迟开始时间（ms）</span></span><br><span class="line">      android:fillBefore = “<span class="keyword">true</span>” <span class="comment">// 动画播放完后，视图是否会停留在动画开始的状态，默认为true</span></span><br><span class="line">      android:fillAfter = “<span class="keyword">false</span>” <span class="comment">// 动画播放完后，视图是否会停留在动画结束的状态，优先于fillBefore值，默认为false</span></span><br><span class="line">      android:fillEnabled= “<span class="keyword">true</span>” <span class="comment">// 是否应用fillBefore值，对fillAfter值无影响，默认为true</span></span><br><span class="line">      android:repeatMode= “restart” <span class="comment">// 选择重复播放动画模式，restart代表正序重放，reverse代表倒序回放，默认为restart|</span></span><br><span class="line">      android:repeatCount = “<span class="number">0</span>” <span class="comment">// 重放次数（所以动画的播放次数=重放次数+1），为infinite时无限重复</span></span><br><span class="line">      android:interpolator = @[<span class="keyword">package</span>:]anim/interpolator_resource <span class="comment">// 插值器，即影响动画的播放速度,下面会详细讲</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 以下参数是平移动画特有的属性</span></span><br><span class="line">      android:fromXDelta=<span class="string">&quot;0&quot;</span> <span class="comment">// 视图在水平方向x 移动的起始值</span></span><br><span class="line">      android:toXDelta=<span class="string">&quot;500&quot;</span> <span class="comment">// 视图在水平方向x 移动的结束值</span></span><br><span class="line">      android:fromYDelta=<span class="string">&quot;0&quot;</span> <span class="comment">// 视图在竖直方向y 移动的起始值</span></span><br><span class="line">      android:toYDelta=<span class="string">&quot;500&quot;</span> <span class="comment">// 视图在竖直方向y 移动的结束值</span></span><br><span class="line">      /&gt; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 步骤3：在Java代码中创建Animation对象并播放动画</span></span><br><span class="line">  <span class="comment">// 1. 创建需要设置动画的 视图View</span></span><br><span class="line">  Button mButton = (Button) findViewById(R.id.Button); </span><br><span class="line">  <span class="comment">// 2. 创建动画对象并传入设置的动画效果xml文件</span></span><br><span class="line">  Animation translateAnimation = AnimationUtils.loadAnimation(<span class="keyword">this</span>, R.anim.view_animation);</span><br><span class="line">  <span class="comment">// 3. 播放动画</span></span><br><span class="line">  mButton.startAnimation(translateAnimation);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设置方式2：Java</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// 步骤1:创建需要设置动画的视图View</span></span><br><span class="line"> Button mButton = (Button) findViewById(R.id.Button);</span><br><span class="line"> <span class="comment">// 步骤2：创建平移动画的对象</span></span><br><span class="line"> <span class="comment">// 平移动画对应的Animation子类为TranslateAnimation</span></span><br><span class="line"> Animation translateAnimation = <span class="keyword">new</span> TranslateAnimation(<span class="number">0</span>，<span class="number">500</span>，<span class="number">0</span>，<span class="number">500</span>);</span><br><span class="line"> <span class="comment">// 参数说明</span></span><br><span class="line"> <span class="comment">// fromXDelta ：视图在水平方向x 移动的起始值</span></span><br><span class="line"> <span class="comment">// toXDelta ：视图在水平方向x 移动的结束值</span></span><br><span class="line"> <span class="comment">// fromYDelta ：视图在竖直方向y 移动的起始值</span></span><br><span class="line"> <span class="comment">// toYDelta：视图在竖直方向y 移动的结束值</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 步骤3：属性设置：方法名是在其属性前加“set”，如设置时长setDuration()</span></span><br><span class="line"> translateAnimation.setDuration(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 步骤4：播放动画</span></span><br><span class="line"> mButton.startAnimation(translateAnimation);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/d24de453c2049fe99c6069e89df55b8f.gif" alt="效果图"></p>
</li>
<li><p>缩放动画</p>
<p>轴心：</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/bd3768da11a87ffe69a976886cf97d14.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设置方式1：xml</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// 步骤1：在 res/anim的文件夹里创建动画效果.xml文件</span></span><br><span class="line"> <span class="comment">// 此处路径为res/anim/view_animation.xml</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 步骤2：根据不同动画效果的语法设置不同动画参数-view_animation.xml</span></span><br><span class="line">    &lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">    <span class="comment">// 采用&lt;scale/&gt; 标签表示是缩放动画</span></span><br><span class="line">    &lt;scale xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下参数是4种动画效果的公共属性,即都有的属性</span></span><br><span class="line">    android:duration=<span class="string">&quot;3000&quot;</span> <span class="comment">// 动画持续时间（ms），必须设置，动画才有效果</span></span><br><span class="line">    android:startOffset =<span class="string">&quot;1000&quot;</span> <span class="comment">// 动画延迟开始时间（ms）</span></span><br><span class="line">    android:fillBefore = “<span class="keyword">true</span>” <span class="comment">// 动画播放完后，视图是否会停留在动画开始的状态，默认为true</span></span><br><span class="line">    android:fillAfter = “<span class="keyword">false</span>” <span class="comment">// 动画播放完后，视图是否会停留在动画结束的状态，优先于fillBefore值，默认为false</span></span><br><span class="line">    android:fillEnabled= “<span class="keyword">true</span>” <span class="comment">// 是否应用fillBefore值，对fillAfter值无影响，默认为true</span></span><br><span class="line">    android:repeatMode= “restart” <span class="comment">// 选择重复播放动画模式，restart代表正序重放，reverse代表倒序回放，默认为restart|</span></span><br><span class="line">    android:repeatCount = “<span class="number">0</span>” <span class="comment">// 重放次数（所以动画的播放次数=重放次数+1），为infinite时无限重复</span></span><br><span class="line">    android:interpolator = @[<span class="keyword">package</span>:]anim/interpolator_resource <span class="comment">// 插值器，即影响动画的播放速度,下面会详细讲</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以下参数是缩放动画特有的属性</span></span><br><span class="line">    android:fromXScale=<span class="string">&quot;0.0&quot;</span> </span><br><span class="line">    <span class="comment">// 动画在水平方向X的起始缩放倍数</span></span><br><span class="line">    <span class="comment">// 0.0表示收缩到没有；1.0表示正常无伸缩</span></span><br><span class="line">    <span class="comment">// 值小于1.0表示收缩；值大于1.0表示放大</span></span><br><span class="line"></span><br><span class="line">    android:toXScale=<span class="string">&quot;2&quot;</span>  <span class="comment">//动画在水平方向X的结束缩放倍数</span></span><br><span class="line"></span><br><span class="line">    android:fromYScale=<span class="string">&quot;0.0&quot;</span> <span class="comment">//动画开始前在竖直方向Y的起始缩放倍数</span></span><br><span class="line">    android:toYScale=<span class="string">&quot;2&quot;</span> <span class="comment">//动画在竖直方向Y的结束缩放倍数</span></span><br><span class="line"></span><br><span class="line">    android:pivotX=<span class="string">&quot;50%&quot;</span> <span class="comment">// 缩放轴点的x坐标</span></span><br><span class="line">    android:pivotY=<span class="string">&quot;50%&quot;</span> <span class="comment">// 缩放轴点的y坐标</span></span><br><span class="line">    <span class="comment">// 轴点 = 视图缩放的中心点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// pivotX pivotY,可取值为数字，百分比，或者百分比p</span></span><br><span class="line">    <span class="comment">// 设置为数字时（如50），轴点为View的左上角的原点在x方向和y方向加上50px的点。在Java代码里面设置这个参数的对应参数是Animation.ABSOLUTE。</span></span><br><span class="line">    <span class="comment">// 设置为百分比时（如50%），轴点为View的左上角的原点在x方向加上自身宽度50%和y方向自身高度50%的点。在Java代码里面设置这个参数的对应参数是Animation.RELATIVE_TO_SELF。</span></span><br><span class="line">    <span class="comment">// 设置为百分比p时（如50%p），轴点为View的左上角的原点在x方向加上父控件宽度50%和y方向父控件高度50%的点。在Java代码里面设置这个参数的对应参数是Animation.RELATIVE_TO_PARENT</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个50%表示动画从自身中间开始，具体如下图</span></span><br><span class="line">    /&gt; </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 步骤3：在Java代码中创建Animation对象并播放动画</span></span><br><span class="line">  <span class="comment">// 1. 创建需要设置动画的 视图View</span></span><br><span class="line">  Button mButton = (Button) findViewById(R.id.Button); </span><br><span class="line">  <span class="comment">// 2. 创建动画对象并传入设置的动画效果xml文件</span></span><br><span class="line">  Animation scaleAnimation = AnimationUtils.loadAnimation(<span class="keyword">this</span>, R.anim.view_animation);</span><br><span class="line">  <span class="comment">// 3. 播放动画</span></span><br><span class="line">  mButton.startAnimation(scaleAnimation);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设置方式2：Java</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 步骤1：创建 需要设置动画的 视图View</span></span><br><span class="line"> Button mButton = (Button) findViewById(R.id.Button);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 步骤2：创建缩放动画的对象 &amp; 设置动画效果</span></span><br><span class="line"> <span class="comment">// 缩放动画对应的Animation子类为RotateAnimation</span></span><br><span class="line"> Animation scaleAnimation = <span class="keyword">new</span> ScaleAnimation(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,Animation.RELATIVE_TO_SELF,<span class="number">0.5f</span>,Animation.RELATIVE_TO_SELF,<span class="number">0.5f</span>);</span><br><span class="line"> <span class="comment">// 参数说明:</span></span><br><span class="line"> <span class="comment">// 1. fromX ：动画在水平方向X的结束缩放倍数</span></span><br><span class="line"> <span class="comment">// 2. toX ：动画在水平方向X的结束缩放倍数</span></span><br><span class="line"> <span class="comment">// 3. fromY ：动画开始前在竖直方向Y的起始缩放倍数</span></span><br><span class="line"> <span class="comment">// 4. toY：动画在竖直方向Y的结束缩放倍数</span></span><br><span class="line"> <span class="comment">// 5. pivotXType:缩放轴点的x坐标的模式</span></span><br><span class="line"> <span class="comment">// 6. pivotXValue:缩放轴点x坐标的相对值</span></span><br><span class="line"> <span class="comment">// 7. pivotYType:缩放轴点的y坐标的模式</span></span><br><span class="line"> <span class="comment">// 8. pivotYValue:缩放轴点y坐标的相对值</span></span><br><span class="line"> <span class="comment">// pivotXType = Animation.ABSOLUTE:缩放轴点的x坐标 =  View左上角的原点 在x方向 加上 pivotXValue数值的点(y方向同理)</span></span><br><span class="line"> <span class="comment">// pivotXType = Animation.RELATIVE_TO_SELF:缩放轴点的x坐标 = View左上角的原点 在x方向 加上 自身宽度乘上pivotXValue数值的值(y方向同理)</span></span><br><span class="line"> <span class="comment">// pivotXType = Animation.RELATIVE_TO_PARENT:缩放轴点的x坐标 = View左上角的原点 在x方向 加上 父控件宽度乘上pivotXValue数值的值 (y方向同理)</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 步骤3：属性设置：方法名是在其属性前加“set”，如设置时长setDuration() </span></span><br><span class="line">  scaleAnimation.setDuration(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 步骤4：播放动画</span></span><br><span class="line">  mButton.startAnimation(scaleAnimation);</span><br></pre></td></tr></table></figure>

<p>轴心（50%、50%）</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/99036c787b3126a21f25d823ce37346e.gif" alt="轴点为（50%,50%）"></p>
<p>轴心（20%、30%）</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/bee679d2bb1839d64a6bb61c68ffca40.gif" alt="轴点为（20%,30%）"></p>
</li>
<li><p>旋转动画</p>
<p>旋转轴心：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/bd3768da11a87ffe69a976886cf97d14.png" alt="image.png"></p>
<p>旋转轴心(50%、50%)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设置方式1：xml</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// 步骤1：在 res/anim的文件夹里创建动画效果.xml文件</span></span><br><span class="line"> <span class="comment">// 此处路径为res/anim/view_animation.xml</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 步骤2：根据不同动画效果的语法设置不同动画参数-view_animation.xml</span></span><br><span class="line"> <span class="comment">// 采用&lt;rotate/&gt; 标签表示是旋转动画</span></span><br><span class="line">    &lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">    &lt;rotate xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下参数是4种动画效果的公共属性,即都有的属性</span></span><br><span class="line">    android:duration=<span class="string">&quot;3000&quot;</span> <span class="comment">// 动画持续时间（ms），必须设置，动画才有效果</span></span><br><span class="line">    android:startOffset =<span class="string">&quot;1000&quot;</span> <span class="comment">// 动画延迟开始时间（ms）</span></span><br><span class="line">    android:fillBefore = “<span class="keyword">true</span>” <span class="comment">// 动画播放完后，视图是否会停留在动画开始的状态，默认为true</span></span><br><span class="line">    android:fillAfter = “<span class="keyword">false</span>” <span class="comment">// 动画播放完后，视图是否会停留在动画结束的状态，优先于fillBefore值，默认为false</span></span><br><span class="line">    android:fillEnabled= “<span class="keyword">true</span>” <span class="comment">// 是否应用fillBefore值，对fillAfter值无影响，默认为true</span></span><br><span class="line">    android:repeatMode= “restart” <span class="comment">// 选择重复播放动画模式，restart代表正序重放，reverse代表倒序回放，默认为restart|</span></span><br><span class="line">    android:repeatCount = “<span class="number">0</span>” <span class="comment">// 重放次数（所以动画的播放次数=重放次数+1），为infinite时无限重复</span></span><br><span class="line">    android:interpolator = @[<span class="keyword">package</span>:]anim/interpolator_resource <span class="comment">// 插值器，即影响动画的播放速度,下面会详细讲</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以下参数是旋转动画特有的属性</span></span><br><span class="line">    android:duration=<span class="string">&quot;1000&quot;</span></span><br><span class="line">    android:fromDegrees=<span class="string">&quot;0&quot;</span> <span class="comment">// 动画开始时 视图的旋转角度(正数 = 顺时针，负数 = 逆时针)</span></span><br><span class="line">    android:toDegrees=<span class="string">&quot;270&quot;</span> <span class="comment">// 动画结束时 视图的旋转角度(正数 = 顺时针，负数 = 逆时针)</span></span><br><span class="line">    android:pivotX=<span class="string">&quot;50%&quot;</span> <span class="comment">// 旋转轴点的x坐标</span></span><br><span class="line">    android:pivotY=<span class="string">&quot;0&quot;</span> <span class="comment">// 旋转轴点的y坐标</span></span><br><span class="line">    <span class="comment">// 轴点 = 视图缩放的中心点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// pivotX pivotY,可取值为数字，百分比，或者百分比p</span></span><br><span class="line">    <span class="comment">// 设置为数字时（如50），轴点为View的左上角的原点在x方向和y方向加上50px的点。在Java代码里面设置这个参数的对应参数是Animation.ABSOLUTE。</span></span><br><span class="line">    <span class="comment">// 设置为百分比时（如50%），轴点为View的左上角的原点在x方向加上自身宽度50%和y方向自身高度50%的点。在Java代码里面设置这个参数的对应参数是Animation.RELATIVE_TO_SELF。</span></span><br><span class="line">    <span class="comment">// 设置为百分比p时（如50%p），轴点为View的左上角的原点在x方向加上父控件宽度50%和y方向父控件高度50%的点。在Java代码里面设置这个参数的对应参数是Animation.RELATIVE_TO_PARENT</span></span><br><span class="line">    <span class="comment">// 两个50%表示动画从自身中间开始，具体如下图</span></span><br><span class="line"></span><br><span class="line">    /&gt; </span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 步骤3：在Java代码中创建Animation对象并播放动画</span></span><br><span class="line">  <span class="comment">// 1. 创建需要设置动画的 视图View</span></span><br><span class="line">  Button mButton = (Button) findViewById(R.id.Button); </span><br><span class="line">  <span class="comment">// 2. 创建动画对象并传入设置的动画效果xml文件</span></span><br><span class="line">  Animation rotateAnimation = AnimationUtils.loadAnimation(<span class="keyword">this</span>, R.anim.view_animation);</span><br><span class="line">  <span class="comment">// 3. 播放动画</span></span><br><span class="line">  mButton.startAnimation(rotateAnimation);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设置方式2：Java</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// 步骤1：创建需要设置动画的视图View</span></span><br><span class="line"> Button mButton = (Button) findViewById(R.id.Button);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 步骤2：创建旋转动画的对象 &amp; 设置动画效果</span></span><br><span class="line"> <span class="comment">// 旋转动画对应的Animation子类为RotateAnimation</span></span><br><span class="line"> Animation rotateAnimation = <span class="keyword">new</span> RotateAnimation(<span class="number">0</span>,<span class="number">270</span>,Animation.RELATIVE_TO_SELF,<span class="number">0.5f</span>,Animation.RELATIVE_TO_SELF,<span class="number">0.5f</span>);</span><br><span class="line"> <span class="comment">// 参数说明:</span></span><br><span class="line"> <span class="comment">// 1. fromX ：动画在水平方向X的结束缩放倍数</span></span><br><span class="line"> <span class="comment">// 2. toX ：动画在水平方向X的结束缩放倍数</span></span><br><span class="line"> <span class="comment">// 3. fromY ：动画开始前在竖直方向Y的起始缩放倍数</span></span><br><span class="line"> <span class="comment">// 4. toY：动画在竖直方向Y的结束缩放倍数</span></span><br><span class="line"> <span class="comment">// 5. pivotXType:缩放轴点的x坐标的模式</span></span><br><span class="line"> <span class="comment">// 6. pivotXValue:缩放轴点x坐标的相对值</span></span><br><span class="line"> <span class="comment">// 7. pivotYType:缩放轴点的y坐标的模式</span></span><br><span class="line"> <span class="comment">// 8. pivotYValue:缩放轴点y坐标的相对值</span></span><br><span class="line"> <span class="comment">// pivotXType = Animation.ABSOLUTE:缩放轴点的x坐标 =  View左上角的原点 在x方向 加上 pivotXValue数值的点(y方向同理)</span></span><br><span class="line"> <span class="comment">// pivotXType = Animation.RELATIVE_TO_SELF:缩放轴点的x坐标 = View左上角的原点 在x方向 加上 自身宽度乘上pivotXValue数值的值(y方向同理)</span></span><br><span class="line"> <span class="comment">// pivotXType = Animation.RELATIVE_TO_PARENT:缩放轴点的x坐标 = View左上角的原点 在x方向 加上 父控件宽度乘上pivotXValue数值的值 (y方向同理)</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 步骤3：属性设置：方法名是在其属性前加“set”，如设置时长setDuration() </span></span><br><span class="line">  rotateAnimation.setDuration(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 步骤4：播放动画</span></span><br><span class="line">  mButton.startAnimation(rotateAnimation);</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>透明度动画</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设置方式1：xml</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="comment">// 步骤1：在 res/anim的文件夹里创建动画效果.xml文件</span></span><br><span class="line">   <span class="comment">// 此处路径为res/anim/view_animation.xml</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 步骤2：根据不同动画效果的语法设置不同动画参数-view_animation.xml</span></span><br><span class="line">   <span class="comment">// 采用&lt;alpha/&gt; 标签表示是透明度动画</span></span><br><span class="line">   &lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">   &lt;alpha xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下参数是4种动画效果的公共属性,即都有的属性</span></span><br><span class="line">    android:duration=<span class="string">&quot;3000&quot;</span> <span class="comment">// 动画持续时间（ms），必须设置，动画才有效果</span></span><br><span class="line">    android:startOffset =<span class="string">&quot;1000&quot;</span> <span class="comment">// 动画延迟开始时间（ms）</span></span><br><span class="line">    android:fillBefore = “<span class="keyword">true</span>” <span class="comment">// 动画播放完后，视图是否会停留在动画开始的状态，默认为true</span></span><br><span class="line">    android:fillAfter = “<span class="keyword">false</span>” <span class="comment">// 动画播放完后，视图是否会停留在动画结束的状态，优先于fillBefore值，默认为false</span></span><br><span class="line">    android:fillEnabled= “<span class="keyword">true</span>” <span class="comment">// 是否应用fillBefore值，对fillAfter值无影响，默认为true</span></span><br><span class="line">    android:repeatMode= “restart” <span class="comment">// 选择重复播放动画模式，restart代表正序重放，reverse代表倒序回放，默认为restart|</span></span><br><span class="line">    android:repeatCount = “<span class="number">0</span>” <span class="comment">// 重放次数（所以动画的播放次数=重放次数+1），为infinite时无限重复</span></span><br><span class="line">    android:interpolator = @[<span class="keyword">package</span>:]anim/interpolator_resource <span class="comment">// 插值器，即影响动画的播放速度,下面会详细讲</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以下参数是透明度动画特有的属性</span></span><br><span class="line">    android:fromAlpha=<span class="string">&quot;1.0&quot;</span> <span class="comment">// 动画开始时视图的透明度(取值范围: -1 ~ 1)</span></span><br><span class="line">    android:toAlpha=<span class="string">&quot;0.0&quot;</span><span class="comment">// 动画结束时视图的透明度(取值范围: -1 ~ 1)</span></span><br><span class="line"></span><br><span class="line">    /&gt; </span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 步骤3：在Java代码中创建Animation对象并播放动画</span></span><br><span class="line">  <span class="comment">// 1. 创建需要设置动画的 视图View</span></span><br><span class="line">  Button mButton = (Button) findViewById(R.id.Button); </span><br><span class="line">  <span class="comment">// 2. 创建动画对象并传入设置的动画效果xml文件</span></span><br><span class="line">  Animation alphaAnimation = AnimationUtils.loadAnimation(<span class="keyword">this</span>, R.anim.view_animation);</span><br><span class="line">  <span class="comment">// 3. 播放动画</span></span><br><span class="line">  mButton.startAnimation(alphaAnimation);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设置方式2：Java</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">   <span class="comment">// 步骤1：创建需要设置动画的视图View</span></span><br><span class="line">   Button mButton = (Button) findViewById(R.id.Button);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 步骤2：创建透明度动画的对象 &amp; 设置动画效果</span></span><br><span class="line">   <span class="comment">// 透明度动画对应的Animation子类为AlphaAnimation</span></span><br><span class="line">   Animation alphaAnimation = <span class="keyword">new</span> AlphaAnimation(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">   <span class="comment">// 参数说明:</span></span><br><span class="line">   <span class="comment">// 1. fromX ：动画在水平方向X的结束缩放倍数</span></span><br><span class="line">   <span class="comment">// 2. toX ：动画在水平方向X的结束缩放倍数</span></span><br><span class="line">   <span class="comment">// 3. fromY ：动画开始前在竖直方向Y的起始缩放倍数</span></span><br><span class="line">   <span class="comment">// 4. toY：动画在竖直方向Y的结束缩放倍数</span></span><br><span class="line">   <span class="comment">// 5. pivotXType:缩放轴点的x坐标的模式</span></span><br><span class="line">   <span class="comment">// 6. pivotXValue:缩放轴点x坐标的相对值</span></span><br><span class="line">   <span class="comment">// 7. pivotYType:缩放轴点的y坐标的模式</span></span><br><span class="line">   <span class="comment">// 8. pivotYValue:缩放轴点y坐标的相对值</span></span><br><span class="line">   <span class="comment">// pivotXType = Animation.ABSOLUTE:缩放轴点的x坐标 =  View左上角的原点 在x方向 加上 pivotXValue数值的点(y方向同理)</span></span><br><span class="line">   <span class="comment">// pivotXType = Animation.RELATIVE_TO_SELF:缩放轴点的x坐标 = View左上角的原点 在x方向 加上 自身宽度乘上pivotXValue数值的值(y方向同理)</span></span><br><span class="line">   <span class="comment">// pivotXType = Animation.RELATIVE_TO_PARENT:缩放轴点的x坐标 = View左上角的原点 在x方向 加上 父控件宽度乘上pivotXValue数值的值 (y方向同理)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 步骤3：属性设置：方法名是在其属性前加“set”，如设置时长setDuration() </span></span><br><span class="line">    AlphaAnimation.setDuration(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤4：播放动画</span></span><br><span class="line">    mButton.startAnimation(AlphaAnimation);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/4018a3f37bb84ac6050fc98fd349b66a.gif" alt="img"></p>
</li>
</ul>
<p><strong>Activity 的切换效果</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 系统已经封装好的动画效果</span></span><br><span class="line">  <span class="comment">// 淡入淡出：android.R.anim.fade_in、android.R.anim.fade_out</span></span><br><span class="line">  <span class="comment">// 由左向右滑入：android.R.anim.slide_in_left、android.R.anim.slide_out_right</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心方法：overridePendingTransition（int enterAnim, int exitAnim）</span></span><br><span class="line">  <span class="comment">// 调用时机：Activity的onCreate() 或 finish()</span></span><br><span class="line">  <span class="comment">// 参数说明</span></span><br><span class="line">  <span class="comment">// 对于在onCreate()设置：</span></span><br><span class="line">     <span class="comment">// enterAnim：进入该Activity时的动画效果资源ID</span></span><br><span class="line">     <span class="comment">// exitAnim：进入该Activity时上一个Activity离开时的动画效果资源ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于在finish()设置：</span></span><br><span class="line">     <span class="comment">// enterAnim：进入其他Activity时 进入Activity的动画效果资源ID</span></span><br><span class="line">     <span class="comment">// exitAnim：进入其他Activity时 该Activity离开时的动画效果资源ID</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体使用</span></span><br><span class="line">  <span class="comment">// 方式1：在onCreate()设置</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">          overridePendingTransition(R.anim.fade_in, R.anim.fade_out);</span><br><span class="line">          <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方式2：在finish()设置</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">super</span>.finish();</span><br><span class="line">          overridePendingTransition(R.anim.fade_in, R.anim.fade_out);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果进入退出页面：一个需要动画、另外一个不需要动画，但也必须设置时间相同的、没有任何变化的动画，否则会出现黑屏。</p>
</blockquote>
<p>自定义淡入淡出的效果：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// 淡入：fade_in.xml</span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">alpha</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span> &gt;</span>   </span><br><span class="line">        android:duration=&quot;1500&quot;  </span><br><span class="line">        android:fromAlpha=&quot;0.0&quot;  </span><br><span class="line">        android:toAlpha=&quot;1.0&quot; &gt;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">alpha</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 淡出：fade_out.xml</span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">alpha</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span> &gt;</span>   </span><br><span class="line">        android:duration=&quot;1500&quot;  </span><br><span class="line">        android:fromAlpha=&quot;1.0&quot;  </span><br><span class="line">        android:toAlpha=&quot;0.0&quot; &gt;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">alpha</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/ebe2783aea2db65cc779752405673ffd.gif" alt="自定义滑动.gif"></p>
<p>原理：平移动画（Translate）</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/72bb454c3a6ea9c5382e794645e029ef.png" alt="img"></p>
<ul>
<li>以屏幕底边为X轴，屏幕左边为Y轴；</li>
<li>当Activity在X轴 = -100%p时，刚好完全超出屏幕到左边（位置1）</li>
<li>当Activity在X轴 = 0%p时，刚好完全在屏幕内(位置2）</li>
<li>当Activity在X轴 = 100%p时，刚好完全超出屏幕到右边（位置3）</li>
</ul>
<p>从右滑到左：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// 从中间滑到左边，即从位置2 -&gt; 位置1：out_to_left.xml</span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">translate</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span> &gt;</span>   </span><br><span class="line">        android:duration=&quot;500&quot;</span><br><span class="line">        android:fromXDelta=&quot;0%p&quot;</span><br><span class="line">        android:toXDelta=&quot;-100%p&quot; &gt;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">translate</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 从右边滑到中间，即从位置3 -&gt; 位置2：in_from_right.xml</span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">translate</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span> &gt;</span>   </span><br><span class="line">        android:duration=&quot;500&quot;</span><br><span class="line">        android:fromXDelta=&quot;100%p&quot;</span><br><span class="line">        android:toXDelta=&quot;0%p&quot; &gt;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">translate</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>**Fragment动画切换效果 **</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1：系统预设</span></span><br><span class="line">  <span class="comment">// 通过setTransition(int transit)进行设置</span></span><br><span class="line">  <span class="comment">// transit参数说明</span></span><br><span class="line">  <span class="comment">// 1. FragmentTransaction.TRANSIT_NONE：无动画</span></span><br><span class="line">  <span class="comment">// 2. FragmentTransaction.TRANSIT_FRAGMENT_OPEN：标准的打开动画效果</span></span><br><span class="line">  <span class="comment">// 3. FragmentTransaction.TRANSIT_FRAGMENT_CLOSE：标准的关闭动画效果</span></span><br><span class="line">  <span class="comment">// 标准动画设置好后，在Fragment添加和移除的时候都会有。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 具体使用</span></span><br><span class="line">  FragmentTransaction fragmentTransaction = mFragmentManager.beginTransaction();</span><br><span class="line">  fragmentTransaction.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_OPEN)；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：自定义动画效果</span></span><br><span class="line">  <span class="comment">// 通过FragmentTransavtion.setCustomAnimations()设置</span></span><br><span class="line">  <span class="comment">// 此处的自定义动画效果同Activity，此处不再过多描述</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 具体使用</span></span><br><span class="line">  FragmentTransaction fragmentTransaction = mFragmentManager.beginTransaction();</span><br><span class="line">  fragmentTransaction.setCustomAnimations(R.anim.in_from_right,R.anim.out_to_left);</span><br></pre></td></tr></table></figure>

<p><strong>视图组（ViewGroup）中子元素的出场效果</strong></p>
<blockquote>
<p>视图组（<code>ViewGroup</code>）中子元素可以具备出场时的补间动画效果。常用需求场景：为<code>ListView</code>的 <code>item</code> 设置出场动画</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/528328545d89060a01c5e08b3d746a55.gif" alt="ListView出场动画效果图"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤1：设置子元素的出场动画</span></span><br><span class="line"><span class="comment">// res/anim/view_animation.xml</span></span><br><span class="line"></span><br><span class="line">  &lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">  <span class="comment">// 此处采用了组合动画</span></span><br><span class="line">  &lt;set xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span> &gt;</span><br><span class="line">      android:duration=<span class="string">&quot;3000&quot;</span></span><br><span class="line"></span><br><span class="line">      &lt;alpha</span><br><span class="line">          android:duration=<span class="string">&quot;1500&quot;</span></span><br><span class="line">          android:fromAlpha=<span class="string">&quot;1.0&quot;</span></span><br><span class="line">          android:toAlpha=<span class="string">&quot;0.0&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">      &lt;translate</span><br><span class="line">          android:fromXDelta=<span class="string">&quot;500&quot;</span></span><br><span class="line">          android:toXDelta=<span class="string">&quot;0&quot;</span></span><br><span class="line">           /&gt;</span><br><span class="line">  &lt;/set&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：设置 视图组（ViewGroup）的动画文件</span></span><br><span class="line"><span class="comment">// res/anim/anim_layout.xml</span></span><br><span class="line">  &lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">  <span class="comment">// 采用LayoutAnimation标签</span></span><br><span class="line">  &lt;layoutAnimation xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">      android:delay=<span class="string">&quot;0.5&quot;</span></span><br><span class="line">      <span class="comment">// 子元素开始动画的时间延迟</span></span><br><span class="line">      <span class="comment">// 如子元素入场动画的时间总长设置为300ms</span></span><br><span class="line">      <span class="comment">// 那么 delay = &quot;0.5&quot; 表示每个子元素都会延迟150ms才会播放动画效果</span></span><br><span class="line">      <span class="comment">// 第一个子元素延迟150ms播放入场效果；第二个延迟300ms，以此类推</span></span><br><span class="line"></span><br><span class="line">      android:animationOrder=<span class="string">&quot;normal&quot;</span></span><br><span class="line">      <span class="comment">// 表示子元素动画的顺序</span></span><br><span class="line">      <span class="comment">// 可设置属性为：</span></span><br><span class="line">      <span class="comment">// 1. normal ：顺序显示，即排在前面的子元素先播放入场动画</span></span><br><span class="line">      <span class="comment">// 2. reverse：倒序显示，即排在后面的子元素先播放入场动画</span></span><br><span class="line">      <span class="comment">// 3. random：随机播放入场动画</span></span><br><span class="line"></span><br><span class="line">      android:animation=<span class="string">&quot;@anim/view_animation&quot;</span></span><br><span class="line">      <span class="comment">// 设置入场的具体动画效果</span></span><br><span class="line">      <span class="comment">// 将步骤1的子元素出场动画设置到这里</span></span><br><span class="line">      /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤3：为视图组（ViewGroup）指定andorid:layoutAnimation属性</span></span><br><span class="line">   <span class="comment">// 指定的方式有两种： XML / Java代码</span></span><br><span class="line">   <span class="comment">// 方式1：XML</span></span><br><span class="line">   &lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">    &lt;LinearLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">        xmlns:tools=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:background=<span class="string">&quot;#FFFFFF&quot;</span></span><br><span class="line">        android:orientation=<span class="string">&quot;vertical&quot;</span> &gt;</span><br><span class="line">        &lt;ListView</span><br><span class="line">            android:id=<span class="string">&quot;@+id/listView1&quot;</span></span><br><span class="line">            android:layoutAnimation=<span class="string">&quot;@anim/anim_layout&quot;</span></span><br><span class="line">            <span class="comment">// 指定layoutAnimation属性用以指定子元素的入场动画</span></span><br><span class="line">            android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;match_parent&quot;</span> /&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式2：Java</span></span><br><span class="line">    <span class="comment">// 注：不需额外设置res/ anim /anim_layout.xml该xml文件了</span></span><br><span class="line">    ListView lv = (ListView) findViewById(R.id.listView1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载子元素的出场动画</span></span><br><span class="line">    Animation animation = AnimationUtils.loadAnimation(<span class="keyword">this</span>,R.anim.anim_item);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置LayoutAnimation的属性</span></span><br><span class="line">    LayoutAnimationController controller = <span class="keyword">new</span> LayoutAnimationController(animation);</span><br><span class="line">    controller.setDelay(<span class="number">0.5f</span>);</span><br><span class="line">    controller.setOrder(LayoutAnimationController.ORDER_NORMAL);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为ListView设置LayoutAnimation的属性</span></span><br><span class="line">    lv.setLayoutAnimation(controller);</span><br></pre></td></tr></table></figure>

<p><strong>高级用法</strong></p>
<ul>
<li><p>组合动画</p>
<p>使用平移、缩放、旋转 &amp; 透明度4种动画，即组合动画</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式：xml跟java代码设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式1：xml</span></span><br><span class="line"> <span class="comment">// 步骤1：在路径 res/anim 的文件夹里创建动画效果 .xml文件 - view_animation.xml</span></span><br><span class="line"> <span class="comment">// 步骤2：设置组合动画（同单个动画设置）</span></span><br><span class="line">  &lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">	<span class="comment">// 采用&lt; Set/&gt;标签</span></span><br><span class="line">	&lt;set xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 组合动画同样具备公共属性</span></span><br><span class="line">	    android:duration=<span class="string">&quot;3000&quot;</span> <span class="comment">// 动画持续时间（ms），必须设置，动画才有效果</span></span><br><span class="line">	    android:startOffset =<span class="string">&quot;1000&quot;</span> <span class="comment">// 动画延迟开始时间（ms）</span></span><br><span class="line">	    android:fillBefore = “<span class="keyword">true</span>” <span class="comment">// 动画播放完后，视图是否会停留在动画开始的状态，默认为true</span></span><br><span class="line">	    android:fillAfter = “<span class="keyword">false</span>” <span class="comment">// 动画播放完后，视图是否会停留在动画结束的状态，优先于fillBefore值，默认为false</span></span><br><span class="line">	    android:fillEnabled= “<span class="keyword">true</span>” <span class="comment">// 是否应用fillBefore值，对fillAfter值无影响，默认为true</span></span><br><span class="line">	    android:repeatMode= “restart” <span class="comment">// 选择重复播放动画模式，restart代表正序重放，reverse代表倒序回放，默认为restart|</span></span><br><span class="line">	    android:repeatCount = “<span class="number">0</span>” <span class="comment">// 重放次数（所以动画的播放次数=重放次数+1），为infinite时无限重复</span></span><br><span class="line">	    android:interpolator = @[<span class="keyword">package</span>:]anim/interpolator_resource <span class="comment">// 插值器，即影响动画的播放速度,下面会详细讲</span></span><br><span class="line">	    </span><br><span class="line">	<span class="comment">// 组合动画独特的属性</span></span><br><span class="line">	    android:shareinterpolator = “<span class="keyword">true</span>”</span><br><span class="line">	    <span class="comment">// 表示组合动画中的动画是否和集合共享同一个差值器</span></span><br><span class="line">	    <span class="comment">// 如果集合不指定插值器，那么子动画需要单独设置</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 组合动画播放时是全部动画同时开始</span></span><br><span class="line">	<span class="comment">// 如果想不同动画不同时间开始就要使用android:startOffset属性来延迟单个动画播放时间</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置旋转动画，语法同单个动画</span></span><br><span class="line">	    &lt;rotate</span><br><span class="line">	        android:duration=<span class="string">&quot;1000&quot;</span></span><br><span class="line">	        android:fromDegrees=<span class="string">&quot;0&quot;</span></span><br><span class="line">	        android:toDegrees=<span class="string">&quot;360&quot;</span></span><br><span class="line">	        android:pivotX=<span class="string">&quot;50%&quot;</span></span><br><span class="line">	        android:pivotY=<span class="string">&quot;50%&quot;</span></span><br><span class="line">	        android:repeatMode=<span class="string">&quot;restart&quot;</span></span><br><span class="line">	        android:repeatCount=<span class="string">&quot;infinite&quot;</span></span><br><span class="line">	        /&gt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置平移动画，语法同单个动画</span></span><br><span class="line">	    &lt;translate</span><br><span class="line">	        android:duration=<span class="string">&quot;10000&quot;</span></span><br><span class="line">	        android:startOffset = “<span class="number">1000</span>”<span class="comment">// 延迟该动画播放时间</span></span><br><span class="line">	        android:fromXDelta=<span class="string">&quot;-50%p&quot;</span></span><br><span class="line">	        android:fromYDelta=<span class="string">&quot;0&quot;</span></span><br><span class="line">	        android:toXDelta=<span class="string">&quot;50%p&quot;</span></span><br><span class="line">	        android:toYDelta=<span class="string">&quot;0&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置透明度动画，语法同单个动画</span></span><br><span class="line">	    &lt;alpha</span><br><span class="line">	        android:startOffset=<span class="string">&quot;7000&quot;</span></span><br><span class="line">	        android:duration=<span class="string">&quot;3000&quot;</span></span><br><span class="line">	        android:fromAlpha=<span class="string">&quot;1.0&quot;</span></span><br><span class="line">	        android:toAlpha=<span class="string">&quot;0.0&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置缩放动画，语法同单个动画</span></span><br><span class="line">	    &lt;scale</span><br><span class="line">	        android:startOffset=<span class="string">&quot;4000&quot;</span></span><br><span class="line">	        android:duration=<span class="string">&quot;1000&quot;</span></span><br><span class="line">	        android:fromXScale=<span class="string">&quot;1.0&quot;</span></span><br><span class="line">	        android:fromYScale=<span class="string">&quot;1.0&quot;</span></span><br><span class="line">	        android:pivotX=<span class="string">&quot;50%&quot;</span></span><br><span class="line">	        android:pivotY=<span class="string">&quot;50%&quot;</span></span><br><span class="line">	        android:toXScale=<span class="string">&quot;0.5&quot;</span></span><br><span class="line">	        android:toYScale=<span class="string">&quot;0.5&quot;</span> /&gt;</span><br><span class="line">	<span class="comment">// 特别注意：</span></span><br><span class="line">	<span class="comment">// 1. 在组合动画里scale缩放动画设置的repeatCount（重复播放）和fillBefore（播放完后，视图是否会停留在动画开始的状态）是无效的。</span></span><br><span class="line">	<span class="comment">// 2. 所以如果需要重复播放或者回到原位的话需要在set标签里设置</span></span><br><span class="line">	<span class="comment">// 3. 但是由于此处rotate旋转动画里已设置repeatCount为infinite，所以动画不会结束，也就看不到重播和回复原位</span></span><br><span class="line"></span><br><span class="line">	&lt;/set&gt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 步骤3：播放动画</span></span><br><span class="line">	    <span class="comment">// 创建 需要设置动画的 视图View</span></span><br><span class="line">		Button mButton = (Button) findViewById(R.id.Button);</span><br><span class="line">		<span class="comment">// 创建 动画对象 并传入设置的动画效果xml文件</span></span><br><span class="line">		Animation setAnimation = AnimationUtils.loadAnimation(<span class="keyword">this</span>, R.anim.view_animation);</span><br><span class="line">		<span class="comment">// 播放动画</span></span><br><span class="line">		mButton.startAnimation(setAnimation);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：java代码设置</span></span><br><span class="line">    <span class="comment">// 创建 需要设置动画的 视图View</span></span><br><span class="line">	Button mButton = (Button) findViewById(R.id.Button);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 组合动画设置</span></span><br><span class="line">	AnimationSet setAnimation = <span class="keyword">new</span> AnimationSet(<span class="keyword">true</span>);</span><br><span class="line">	<span class="comment">// 步骤1:创建组合动画对象(设置为true)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 步骤2:设置组合动画的属性</span></span><br><span class="line">	<span class="comment">// 特别说明以下情况</span></span><br><span class="line">	<span class="comment">// 因为在下面的旋转动画设置了无限循环(RepeatCount = INFINITE)</span></span><br><span class="line">	<span class="comment">// 所以动画不会结束，而是无限循环</span></span><br><span class="line">	<span class="comment">// 所以组合动画的下面两行设置是无效的</span></span><br><span class="line">	setAnimation.setRepeatMode(Animation.RESTART);</span><br><span class="line">	setAnimation.setRepeatCount(<span class="number">1</span>);<span class="comment">// 设置了循环一次,但无效</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 步骤3:逐个创建子动画(方式同单个动画创建方式,此处不作过多描述)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 子动画1:旋转动画</span></span><br><span class="line">	Animation rotate = <span class="keyword">new</span> RotateAnimation(<span class="number">0</span>,<span class="number">360</span>,Animation.RELATIVE_TO_SELF,<span class="number">0.5f</span>,Animation.RELATIVE_TO_SELF,<span class="number">0.5f</span>);</span><br><span class="line">	rotate.setDuration(<span class="number">1000</span>);</span><br><span class="line">	rotate.setRepeatMode(Animation.RESTART);</span><br><span class="line">	rotate.setRepeatCount(Animation.INFINITE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 子动画2:平移动画</span></span><br><span class="line">	Animation translate = <span class="keyword">new</span> TranslateAnimation(TranslateAnimation.RELATIVE_TO_PARENT,-<span class="number">0.5f</span>,</span><br><span class="line">	TranslateAnimation.RELATIVE_TO_PARENT,<span class="number">0.5f</span>,</span><br><span class="line">	TranslateAnimation.RELATIVE_TO_SELF,<span class="number">0</span></span><br><span class="line">	,TranslateAnimation.RELATIVE_TO_SELF,<span class="number">0</span>);</span><br><span class="line">	translate.setDuration(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 子动画3:透明度动画</span></span><br><span class="line">	Animation alpha = <span class="keyword">new</span> AlphaAnimation(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	alpha.setDuration(<span class="number">3000</span>);</span><br><span class="line">	alpha.setStartOffset(<span class="number">7000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 子动画4:缩放动画</span></span><br><span class="line">	Animation scale1 = <span class="keyword">new</span> ScaleAnimation(<span class="number">1</span>,<span class="number">0.5f</span>,<span class="number">1</span>,<span class="number">0.5f</span>,Animation.RELATIVE_TO_SELF,<span class="number">0.5f</span>,Animation.RELATIVE_TO_SELF,<span class="number">0.5f</span>);</span><br><span class="line">	scale1.setDuration(<span class="number">1000</span>);</span><br><span class="line">	scale1.setStartOffset(<span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 步骤4:将创建的子动画添加到组合动画里</span></span><br><span class="line">	setAnimation.addAnimation(alpha);</span><br><span class="line">	setAnimation.addAnimation(rotate);</span><br><span class="line">	setAnimation.addAnimation(translate);</span><br><span class="line">	setAnimation.addAnimation(scale1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 步骤5:播放动画</span></span><br><span class="line">	mButton.startAnimation(setAnimation);</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/55457758681408a5aa9fb2c36d550fcd.gif" alt="组合动画"></p>
</li>
<li><p>监听动画</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主要通过setAnimationListener()设置</span></span><br><span class="line">Animation.setAnimationListener(<span class="keyword">new</span> Animation.AnimationListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 动画开始时回调</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 动画结束时回调</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationRepeat</span><span class="params">(Animation animation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//动画重复执行的时候回调</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>插值器</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/522294ab6363f9bd8d4bb448ae237d69.png" alt="img"></p>
<p>步骤2中的 插值器（Interpolator）和估值器（TypeEvaluator）是实现 复杂动画效果的关键。</p>
<p><code>定义：</code>一个接口</p>
<p><code>作用：</code>设置 属性值 从初始值过渡到结束值 的变化规律</p>
<blockquote>
<p>如匀速、加速 &amp; 减速 等等，即确定了 动画效果变化的模式，如匀速变化、加速变化 等等</p>
</blockquote>
<p><code>应用场景:</code>实现非线性运动的动画效果</p>
<blockquote>
<p>非线性运动：动画改变的速率不是一成不变的，如加速 &amp; 减速运动都属于非线性运动</p>
</blockquote>
<p><code>设置方式：</code></p>
<p>设置方法1：在 动画效果的XML代码中设置插值器属性<code>android:interpolator</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scale</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    <span class="attr">android:interpolator</span>=<span class="string">&quot;@android:anim/overshoot_interpolator&quot;</span></span></span><br><span class="line"><span class="tag">    // 通过资源<span class="attr">ID</span>设置插值器</span></span><br><span class="line"><span class="tag">    <span class="attr">android:duration</span>=<span class="string">&quot;3000&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromXScale</span>=<span class="string">&quot;0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:fromYScale</span>=<span class="string">&quot;0.0&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotX</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:pivotY</span>=<span class="string">&quot;50%&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toXScale</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:toYScale</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>设置方法2：在 Java 代码中设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Button mButton = (Button) findViewById(R.id.Button);</span><br><span class="line">        <span class="comment">// 步骤1:创建 需要设置动画的 视图View</span></span><br><span class="line"></span><br><span class="line">Animation alphaAnimation = <span class="keyword">new</span> AlphaAnimation(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 步骤2：创建透明度动画的对象 &amp; 设置动画效果</span></span><br><span class="line"></span><br><span class="line">        alphaAnimation.setDuration(<span class="number">3000</span>);</span><br><span class="line">        Interpolator overshootInterpolator = <span class="keyword">new</span> OvershootInterpolator();</span><br><span class="line">        <span class="comment">// 步骤3：创建对应的插值器类对象</span></span><br><span class="line"></span><br><span class="line">        alphaAnimation.setInterpolator(overshootInterpolator);</span><br><span class="line">        <span class="comment">// 步骤4：给动画设置插值器</span></span><br><span class="line"></span><br><span class="line">        mButton.startAnimation(alphaAnimation);</span><br><span class="line">        <span class="comment">// 步骤5：播放动画</span></span><br></pre></td></tr></table></figure>

<p><code>系统内置插值器类型</code></p>
<table>
<thead>
<tr>
<th>作用</th>
<th>资源ID</th>
<th>对应的Java类</th>
</tr>
</thead>
<tbody><tr>
<td>动画加速进行</td>
<td>@android:anim/accelerate_interpolator</td>
<td>AccelerateInterpolator</td>
</tr>
<tr>
<td>快速完成动画，超出再回到结束样式</td>
<td>@android:anim/overshoot_interpolator</td>
<td>OvershootInterpolator</td>
</tr>
<tr>
<td>先加速再减速</td>
<td>@android:anim/accelerate_decelerate_interpolator</td>
<td>AccelerateDecelerateInterpolator</td>
</tr>
<tr>
<td>先退后再加速前进</td>
<td>@android:anim/anticipate_interpolator</td>
<td>AnticipateInterpolator</td>
</tr>
<tr>
<td>先退后再加速前进，超出终点后再回终点</td>
<td>@android:anim/anticipate_overshoot_interpolator</td>
<td>AnticipateOvershootInterpolator</td>
</tr>
<tr>
<td>最后阶段弹球效果</td>
<td>@android:anim/bounce_interpolator</td>
<td>BounceInterpolator</td>
</tr>
<tr>
<td>周期运动</td>
<td>@android:anim/cycle_interpolator</td>
<td>CycleInterpolator</td>
</tr>
<tr>
<td>减速</td>
<td>@android:anim/decelerate_interpolator</td>
<td>DecelerateInterpolator</td>
</tr>
<tr>
<td>匀速</td>
<td>@android:anim/linear_interpolator</td>
<td>LinearInterpolator</td>
</tr>
</tbody></table>
<blockquote>
<p>当在XML文件设置插值器时，只需传入对应的插值器资源ID即可<br>当在Java代码设置插值器时，只需创建对应的插值器对象即可</p>
<p>系统默认的插值器是<code>AccelerateDecelerateInterpolator</code>，即先加速后减速</p>
</blockquote>
<p>系统内置插值器效果：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/31ca336802c70a115a0ad9ad719ae54a.gif" alt="效果图"></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/31ca336802c70a115a0ad9ad719ae54a.gif"></p>
<p><strong>自定义插值器</strong></p>
<p><code>本质：</code>根据动画的进度（0%-100%）计算出当前属性值改变的百分比<br><code>具体使用：</code>自定义插值器需要实现 <code>Interpolator/TimeInterpolator</code>接口 &amp; 复写<code>getInterpolation()</code></p>
<blockquote>
<ol>
<li>补间动画 实现 <code>Interpolator</code>接口；属性动画实现<code>TimeInterpolator</code>接口</li>
<li><code>TimeInterpolator</code>接口是属性动画中新增的，用于兼容<code>Interpolator</code>接口，这使得所有过去的<code>Interpolator</code>实现类都可以直接在属性动画使用</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Interpolator接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interpolator</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部只有一个方法</span></span><br><span class="line">     <span class="function"><span class="keyword">float</span> <span class="title">getInterpolation</span><span class="params">(<span class="keyword">float</span> input)</span> </span>&#123;  </span><br><span class="line">         <span class="comment">// 参数说明</span></span><br><span class="line">         <span class="comment">// input值值变化范围是0-1，且随着动画进度（0% - 100% ）均匀变化</span></span><br><span class="line">        <span class="comment">// 即动画开始时，input值 = 0；动画结束时input = 1</span></span><br><span class="line">        <span class="comment">// 而中间的值则是随着动画的进度（0% - 100%）在0到1之间均匀增加</span></span><br><span class="line">        </span><br><span class="line">      ...<span class="comment">// 插值器的计算逻辑</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> xxx；</span><br><span class="line">      <span class="comment">// 返回的值就是用于估值器继续计算的fraction值，下面会详细说明</span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// TimeInterpolator接口</span></span><br><span class="line"><span class="comment">// 同上</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TimeInterpolator</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getInterpolation</span><span class="params">(<span class="keyword">float</span> input)</span></span>;  </span><br><span class="line">   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>实验：先减速后加速</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Carson_Ho on 17/4/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecelerateAccelerateInterpolator</span> <span class="keyword">implements</span> <span class="title">TimeInterpolator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getInterpolation</span><span class="params">(<span class="keyword">float</span> input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> result;</span><br><span class="line">        <span class="keyword">if</span> (input &lt;= <span class="number">0.5</span>) &#123;</span><br><span class="line">            result = (<span class="keyword">float</span>) (Math.sin(Math.PI * input)) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 使用正弦函数来实现先减速后加速的功能，逻辑如下：</span></span><br><span class="line">            <span class="comment">// 因为正弦函数初始弧度变化值非常大，刚好和余弦函数是相反的</span></span><br><span class="line">            <span class="comment">// 随着弧度的增加，正弦函数的变化值也会逐渐变小，这样也就实现了减速的效果。</span></span><br><span class="line">            <span class="comment">// 当弧度大于π/2之后，整个过程相反了过来，现在正弦函数的弧度变化值非常小，渐渐随着弧度继续增加，变化值越来越大，弧度到π时结束，这样从0过度到π，也就实现了先减速后加速的效果</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = (<span class="keyword">float</span>) (<span class="number">2</span> - Math.sin(Math.PI * input)) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        <span class="comment">// 返回的result值 = 随着动画进度呈先减速后加速的变化趋势</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mButton = (Button) findViewById(R.id.Button);</span><br><span class="line">       <span class="comment">// 创建动画作用对象：此处以Button为例</span></span><br><span class="line">  </span><br><span class="line">       <span class="keyword">float</span> curTranslationX = mButton.getTranslationX();</span><br><span class="line">       <span class="comment">// 获得当前按钮的位置</span></span><br><span class="line">  </span><br><span class="line">       ObjectAnimator animator = ObjectAnimator.ofFloat(mButton, <span class="string">&quot;translationX&quot;</span>, curTranslationX, <span class="number">300</span>,curTranslationX);</span><br><span class="line">       <span class="comment">// 创建动画对象 &amp; 设置动画</span></span><br><span class="line">       <span class="comment">// 表示的是:</span></span><br><span class="line">       <span class="comment">// 动画作用对象是mButton</span></span><br><span class="line">       <span class="comment">// 动画作用的对象的属性是X轴平移</span></span><br><span class="line">       <span class="comment">// 动画效果是:从当前位置平移到 x=1500 再平移到初始位置</span></span><br><span class="line">       animator.setDuration(<span class="number">5000</span>);</span><br><span class="line">       animator.setInterpolator(<span class="keyword">new</span> DecelerateAccelerateInterpolator());</span><br><span class="line">       <span class="comment">// 设置插值器</span></span><br><span class="line">       animator.start();</span><br><span class="line">       <span class="comment">// 启动动画</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/07de0f1ec2d455231d8f53998946e49f.gif" alt="差值器.gif"></p>
</li>
<li><p><strong>估值器</strong></p>
<p><code>定义：</code>一个接口<br><code>作用：</code>设置 属性值 从初始值过渡到结束值 的变化具体数值</p>
<blockquote>
<ol>
<li>插值器（<code>Interpolator</code>）决定 值 的变化规律（匀速、加速blabla），即决定的是变化趋势；而接下来的具体变化数值则交给<br>而估值器</li>
<li>属性动画特有的属性</li>
</ol>
</blockquote>
<p><code>应用场景：</code>协助插值器 实现非线性运动的动画效果</p>
<p><code>具体用法：</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectAnimator anim = ObjectAnimator.ofObject(myView2, <span class="string">&quot;height&quot;</span>, <span class="keyword">new</span> Evaluator()，<span class="number">1</span>，<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 在第4个参数中传入对应估值器类的对象</span></span><br><span class="line"><span class="comment">// 系统内置的估值器有3个：</span></span><br><span class="line"><span class="comment">// IntEvaluator：以整型的形式从初始值 - 结束值 进行过渡</span></span><br><span class="line"><span class="comment">// FloatEvaluator：以浮点型的形式从初始值 - 结束值 进行过渡</span></span><br><span class="line"><span class="comment">// ArgbEvaluator：以Argb类型的形式从初始值 - 结束值 进行过渡</span></span><br></pre></td></tr></table></figure>

<p><strong>自定义估值器</strong></p>
<p><code>本质：</code>根据 插值器计算出当前属性值改变的百分比 &amp; 初始值 &amp; 结束值 来计算 当前属性具体的数值</p>
<blockquote>
<p>如：动画进行了50%（初始值=100，结束值=200 ），那么匀速插值器计算出了当前属性值改变的百分比是50%，那么估值器则负责计算当前属性值 = 100 + （200-100）x50% = 150.</p>
</blockquote>
<p>具体使用：自定义估值器需要实现 <code>TypeEvaluator接口</code> &amp; 复写<code>evaluate()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeEvaluator</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">evaluate</span><span class="params">(<span class="keyword">float</span> fraction, Object startValue, Object endValue)</span> </span>&#123;  </span><br><span class="line"><span class="comment">// 参数说明</span></span><br><span class="line"><span class="comment">// fraction：插值器getInterpolation（）的返回值</span></span><br><span class="line"><span class="comment">// startValue：动画的初始值</span></span><br><span class="line"><span class="comment">// endValue：动画的结束值</span></span><br><span class="line"></span><br><span class="line">        ....<span class="comment">// 估值器的计算逻辑</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> xxx；</span><br><span class="line">        <span class="comment">// 赋给动画属性的具体数值</span></span><br><span class="line">        <span class="comment">// 使用反射机制改变属性变化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特别注意</span></span><br><span class="line"><span class="comment">// 那么插值器的input值 和 估值器fraction有什么关系呢？</span></span><br><span class="line"><span class="comment">// 答：input的值决定了fraction的值：input值经过计算后传入到插值器的getInterpolation（），然后通过实现getInterpolation（）中的逻辑算法，根据input值来计算出一个返回值，而这个返回值就是fraction了</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>实验：一个圆从一个点 移动到 另外一个点</p>
<ol>
<li><p>定义对象类</p>
<p>因为ValueAnimator.ofObject（）是面向对象操作的，所以需要自定义对象类。<br>本例需要操作的对象是 圆的点坐标</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置两个变量用于记录坐标的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法用于设置坐标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get方法用于获取坐标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<ol start="2">
<li><p>根据需求实现TypeEvaluator接口</p>
<p>实现TypeEvaluator接口的目的是自定义如何 从初始点坐标 过渡 到结束点坐标；<br>本例实现的是一个从左上角到右下角的坐标过渡逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现TypeEvaluator接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PointEvaluator</span> <span class="keyword">implements</span> <span class="title">TypeEvaluator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复写evaluate（）</span></span><br><span class="line">    <span class="comment">// 在evaluate（）里写入对象动画过渡的逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">evaluate</span><span class="params">(<span class="keyword">float</span> fraction, Object startValue, Object endValue)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将动画初始值startValue 和 动画结束值endValue 强制类型转换成Point对象</span></span><br><span class="line">        Point startPoint = (Point) startValue;</span><br><span class="line">        Point endPoint = (Point) endValue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据fraction来计算当前动画的x和y的值</span></span><br><span class="line">        <span class="keyword">float</span> x = startPoint.getX() + fraction * (endPoint.getX() - startPoint.getX());</span><br><span class="line">        <span class="keyword">float</span> y = startPoint.getY() + fraction * (endPoint.getY() - startPoint.getY());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将计算后的坐标封装到一个新的Point对象中并返回</span></span><br><span class="line">        Point point = <span class="keyword">new</span> Point(x, y);</span><br><span class="line">        <span class="keyword">return</span> point;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="3">
<li><p>将属性动画作用到自定义View当中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Carson_Ho on 17/4/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置需要用到的变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> RADIUS = <span class="number">70f</span>;<span class="comment">// 圆的半径 = 70</span></span><br><span class="line">    <span class="keyword">private</span> Point currentPoint;<span class="comment">// 当前点坐标</span></span><br><span class="line">    <span class="keyword">private</span> Paint mPaint;<span class="comment">// 绘图画笔</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法(初始化画笔)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        <span class="comment">// 初始化画笔</span></span><br><span class="line">        mPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">        mPaint.setColor(Color.BLUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复写onDraw()从而实现绘制逻辑</span></span><br><span class="line">    <span class="comment">// 绘制逻辑:先在初始点画圆,通过监听当前坐标值(currentPoint)的变化,每次变化都调用onDraw()重新绘制圆,从而实现圆的平移动画效果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果当前点坐标为空(即第一次)</span></span><br><span class="line">        <span class="keyword">if</span> (currentPoint == <span class="keyword">null</span>) &#123;</span><br><span class="line">            currentPoint = <span class="keyword">new</span> Point(RADIUS, RADIUS);</span><br><span class="line">            <span class="comment">// 创建一个点对象(坐标是(70,70))</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在该点画一个圆:圆心 = (70,70),半径 = 70</span></span><br><span class="line">            <span class="keyword">float</span> x = currentPoint.getX();</span><br><span class="line">            <span class="keyword">float</span> y = currentPoint.getY();</span><br><span class="line">            canvas.drawCircle(x, y, RADIUS, mPaint);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">// (重点关注)将属性动画作用到View中</span></span><br><span class="line">            <span class="comment">// 步骤1:创建初始动画时的对象点  &amp; 结束动画时的对象点</span></span><br><span class="line">            Point startPoint = <span class="keyword">new</span> Point(RADIUS, RADIUS);<span class="comment">// 初始点为圆心(70,70)</span></span><br><span class="line">            Point endPoint = <span class="keyword">new</span> Point(<span class="number">700</span>, <span class="number">1000</span>);<span class="comment">// 结束点为(700,1000)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 步骤2:创建动画对象 &amp; 设置初始值 和 结束值</span></span><br><span class="line">            ValueAnimator anim = ValueAnimator.ofObject(<span class="keyword">new</span> PointEvaluator(), startPoint, endPoint);</span><br><span class="line">            <span class="comment">// 参数说明</span></span><br><span class="line">            <span class="comment">// 参数1：TypeEvaluator 类型参数 - 使用自定义的PointEvaluator(实现了TypeEvaluator接口)</span></span><br><span class="line">            <span class="comment">// 参数2：初始动画的对象点</span></span><br><span class="line">            <span class="comment">// 参数3：结束动画的对象点</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 步骤3：设置动画参数</span></span><br><span class="line">            anim.setDuration(<span class="number">5000</span>);</span><br><span class="line">            <span class="comment">// 设置动画时长</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤3：通过 值 的更新监听器，将改变的对象手动赋值给当前对象</span></span><br><span class="line"><span class="comment">// 此处是将 改变后的坐标值对象 赋给 当前的坐标值对象</span></span><br><span class="line">            <span class="comment">// 设置 值的更新监听器</span></span><br><span class="line">            <span class="comment">// 即每当坐标值（Point对象）更新一次,该方法就会被调用一次</span></span><br><span class="line">            anim.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">                    currentPoint = (Point) animation.getAnimatedValue();</span><br><span class="line">                    <span class="comment">// 将每次变化后的坐标值（估值器PointEvaluator中evaluate（）返回的Piont对象值）到当前坐标值对象（currentPoint）</span></span><br><span class="line">                    <span class="comment">// 从而更新当前坐标值（currentPoint）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤4：每次赋值后就重新绘制，从而实现动画效果</span></span><br><span class="line">                    invalidate();</span><br><span class="line">                    <span class="comment">// 调用invalidate()后,就会刷新View,即才能看到重新绘制的界面,即onDraw()会被重新调用一次</span></span><br><span class="line">                    <span class="comment">// 所以坐标值每改变一次,就会调用onDraw()一次</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            anim.start();</span><br><span class="line">            <span class="comment">// 启动动画</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果坐标值不为0,则画圆</span></span><br><span class="line">            <span class="comment">// 所以坐标值每改变一次,就会调用onDraw()一次,就会画一次圆,从而实现动画效果</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在该点画一个圆:圆心 = (30,30),半径 = 30</span></span><br><span class="line">            <span class="keyword">float</span> x = currentPoint.getX();</span><br><span class="line">            <span class="keyword">float</span> y = currentPoint.getY();</span><br><span class="line">            canvas.drawCircle(x, y, RADIUS, mPaint);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="4">
<li><p>在布局文件加入自定义View空间(activity_main)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingBottom</span>=<span class="string">&quot;@dimen/activity_vertical_margin&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingLeft</span>=<span class="string">&quot;@dimen/activity_horizontal_margin&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingRight</span>=<span class="string">&quot;@dimen/activity_horizontal_margin&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:paddingTop</span>=<span class="string">&quot;@dimen/activity_vertical_margin&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;scut.carson_ho.valueanimator_ofobject.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">scut.carson_ho.valueanimator_ofobject.MyView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">         /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="5">
<li><p>在主代码文件设置显示视图</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2、逐帧动画"><a href="#2、逐帧动画" class="headerlink" title="2、逐帧动画"></a>2、逐帧动画</h4><h5 id="1、作用对象"><a href="#1、作用对象" class="headerlink" title="1、作用对象"></a>1、作用对象</h5><p>视图控件(View)</p>
<blockquote>
<p>如Android的TextView、Button等等</p>
<p>不可作用于View组件的属性，如：颜色、背景、长度等等</p>
</blockquote>
<h5 id="2、原理"><a href="#2、原理" class="headerlink" title="2、原理"></a>2、原理</h5><p>将动画拆分为帧的形式，且定义每一帧等于每一张图片，最后按序播放一组预先定义好的图片</p>
<h5 id="3、用法"><a href="#3、用法" class="headerlink" title="3、用法"></a>3、用法</h5><p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/872cafab97daeb0470ba8e8876623ad9.gif" alt="效果图"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 步骤1：将动画资源（即每张图片资源）放到 drawable文件夹里</span></span><br><span class="line"><span class="comment">// 技巧：找到自己需要的gif动画，用 gif分解软件（如 GifSplitter）将 gif 分解成一张张图片即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：设置、启动动画</span></span><br><span class="line"><span class="comment">// 分两种方式：xml跟java</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 方式1：xml</span></span><br><span class="line">   <span class="comment">// 1. 在 res/drawable的文件夹里创建动画效果.xml文件 - knight_attack.xml</span></span><br><span class="line">   &lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">	&lt;animation-list</span><br><span class="line">	    xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">	    android:oneshot=<span class="string">&quot;true&quot;</span> <span class="comment">// 设置是否只播放一次，默认为false</span></span><br><span class="line">	    &gt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// item = 动画图片资源；duration = 设置一帧持续时间(ms)</span></span><br><span class="line">	    &lt;item android:drawable=<span class="string">&quot;@drawable/a0&quot;</span> android:duration=<span class="string">&quot;100&quot;</span>/&gt;</span><br><span class="line">	    &lt;item android:drawable=<span class="string">&quot;@drawable/a1&quot;</span> android:duration=<span class="string">&quot;100&quot;</span>/&gt;</span><br><span class="line">	    &lt;item android:drawable=<span class="string">&quot;@drawable/a2&quot;</span> android:duration=<span class="string">&quot;100&quot;</span>/&gt;</span><br><span class="line">	    &lt;item android:drawable=<span class="string">&quot;@drawable/a3&quot;</span> android:duration=<span class="string">&quot;100&quot;</span>/&gt;</span><br><span class="line">	    &lt;item android:drawable=<span class="string">&quot;@drawable/a4&quot;</span> android:duration=<span class="string">&quot;100&quot;</span>/&gt;</span><br><span class="line">	    &lt;item android:drawable=<span class="string">&quot;@drawable/a5&quot;</span> android:duration=<span class="string">&quot;100&quot;</span>/&gt;</span><br><span class="line">	    &lt;item android:drawable=<span class="string">&quot;@drawable/a6&quot;</span> android:duration=<span class="string">&quot;100&quot;</span>/&gt;</span><br><span class="line">	    &lt;item android:drawable=<span class="string">&quot;@drawable/a7&quot;</span> android:duration=<span class="string">&quot;100&quot;</span>/&gt;</span><br><span class="line">	    &lt;item android:drawable=<span class="string">&quot;@drawable/a8&quot;</span> android:duration=<span class="string">&quot;100&quot;</span>/&gt;</span><br><span class="line">	    &lt;item android:drawable=<span class="string">&quot;@drawable/a9&quot;</span> android:duration=<span class="string">&quot;100&quot;</span>/&gt;</span><br><span class="line">	    &lt;item android:drawable=<span class="string">&quot;@drawable/a10&quot;</span> android:duration=<span class="string">&quot;100&quot;</span>/&gt;</span><br><span class="line">	    &lt;item android:drawable=<span class="string">&quot;@drawable/a11&quot;</span> android:duration=<span class="string">&quot;100&quot;</span>/&gt;</span><br><span class="line">	    &lt;item android:drawable=<span class="string">&quot;@drawable/a12&quot;</span> android:duration=<span class="string">&quot;100&quot;</span>/&gt;</span><br><span class="line">	    &lt;item android:drawable=<span class="string">&quot;@drawable/a13&quot;</span> android:duration=<span class="string">&quot;100&quot;</span>/&gt;</span><br><span class="line">	    &lt;item android:drawable=<span class="string">&quot;@drawable/a14&quot;</span> android:duration=<span class="string">&quot;100&quot;</span>/&gt;</span><br><span class="line">	    &lt;item android:drawable=<span class="string">&quot;@drawable/a15&quot;</span> android:duration=<span class="string">&quot;100&quot;</span>/&gt;</span><br><span class="line">	    &lt;item android:drawable=<span class="string">&quot;@drawable/a16&quot;</span> android:duration=<span class="string">&quot;100&quot;</span>/&gt;</span><br><span class="line">	    &lt;item android:drawable=<span class="string">&quot;@drawable/a17&quot;</span> android:duration=<span class="string">&quot;100&quot;</span>/&gt;</span><br><span class="line">	    &lt;item android:drawable=<span class="string">&quot;@drawable/a18&quot;</span> android:duration=<span class="string">&quot;100&quot;</span>/&gt;</span><br><span class="line">	    &lt;item android:drawable=<span class="string">&quot;@drawable/a19&quot;</span> android:duration=<span class="string">&quot;100&quot;</span>/&gt;</span><br><span class="line">	    &lt;item android:drawable=<span class="string">&quot;@drawable/a20&quot;</span> android:duration=<span class="string">&quot;100&quot;</span>/&gt;</span><br><span class="line">	    &lt;item android:drawable=<span class="string">&quot;@drawable/a21&quot;</span> android:duration=<span class="string">&quot;100&quot;</span>/&gt;</span><br><span class="line">	    &lt;item android:drawable=<span class="string">&quot;@drawable/a22&quot;</span> android:duration=<span class="string">&quot;100&quot;</span>/&gt;</span><br><span class="line">	    &lt;item android:drawable=<span class="string">&quot;@drawable/a23&quot;</span> android:duration=<span class="string">&quot;100&quot;</span>/&gt;</span><br><span class="line">	    &lt;item android:drawable=<span class="string">&quot;@drawable/a24&quot;</span> android:duration=<span class="string">&quot;100&quot;</span>/&gt;</span><br><span class="line">	    &lt;item android:drawable=<span class="string">&quot;@drawable/a25&quot;</span> android:duration=<span class="string">&quot;100&quot;</span>/&gt;</span><br><span class="line">	&lt;/animation-list&gt;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 载入 &amp; 启动动画</span></span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">private</span> Button btn_startFrame,btn_stopFrame;</span><br><span class="line">	    <span class="keyword">private</span> ImageView iv;</span><br><span class="line">	    <span class="keyword">private</span> AnimationDrawable animationDrawable;</span><br><span class="line"></span><br><span class="line">	        iv = (ImageView) findViewById(R.id.iv);</span><br><span class="line">	        btn_startFrame = (Button) findViewById(R.id.btn_startFrame);</span><br><span class="line">	        btn_stopFrame = (Button) findViewById(R.id.btn_stopFrame);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	        <span class="comment">// 载入动画</span></span><br><span class="line">	        btn_startFrame.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">	            <span class="meta">@Override</span></span><br><span class="line">	            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	                <span class="comment">// 1. 设置动画</span></span><br><span class="line">	                iv.setImageResource(R.drawable.knight_attack);</span><br><span class="line">	                <span class="comment">// 2. 获取动画对象</span></span><br><span class="line">	                animationDrawable = (AnimationDrawable) iv.getDrawable();</span><br><span class="line">	                <span class="comment">// 3. 启动动画</span></span><br><span class="line">	                animationDrawable.start();</span><br><span class="line">	                </span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;);</span><br><span class="line"></span><br><span class="line">	        <span class="comment">// 停止动画</span></span><br><span class="line">	        btn_stopFrame.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">	            <span class="meta">@Override</span></span><br><span class="line">	            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">	                </span><br><span class="line">	                <span class="comment">// 1. 设置动画</span></span><br><span class="line">	                iv.setImageResource(R.drawable.knight_attack);</span><br><span class="line">	                <span class="comment">// 2. 获取动画对象</span></span><br><span class="line">	                animationDrawable = (AnimationDrawable) iv.getDrawable();</span><br><span class="line">	                <span class="comment">// 3. 暂停动画</span></span><br><span class="line">	                animationDrawable.stop();</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;);</span><br><span class="line"></span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="comment">// 方式2：java</span></span><br><span class="line">	    <span class="comment">// 直接从drawable文件夹获取动画资源（图片）</span></span><br><span class="line">        animationDrawable = <span class="keyword">new</span> AnimationDrawable();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">25</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = getResources().getIdentifier(<span class="string">&quot;a&quot;</span> + i, <span class="string">&quot;drawable&quot;</span>, getPackageName());</span><br><span class="line">            Drawable drawable = getResources().getDrawable(id);</span><br><span class="line">            animationDrawable.addFrame(drawable, <span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 载入动画</span></span><br><span class="line">        btn_startFrame.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 1. 获取资源对象</span></span><br><span class="line">                iv.setImageDrawable(animationDrawable);</span><br><span class="line">                <span class="comment">// 2. 停止动画</span></span><br><span class="line">                <span class="comment">// 特别注意：在动画start()之前要先stop()，不然在第一次动画之后会停在最后一帧，这样动画就只会触发一次</span></span><br><span class="line">                animationDrawable.stop();</span><br><span class="line">                <span class="comment">// 3. 启动动画</span></span><br><span class="line">                animationDrawable.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 停止动画</span></span><br><span class="line">        btn_stopFrame.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 1. 获取资源对象</span></span><br><span class="line">                iv.setImageDrawable(animationDrawable);</span><br><span class="line">                <span class="comment">// 2. 停止动画</span></span><br><span class="line">                animationDrawable.stop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h5 id="4、特点："><a href="#4、特点：" class="headerlink" title="4、特点："></a>4、特点：</h5><ul>
<li>优点：使用简单、方便</li>
<li>缺点：容易引起 <code>OOM</code>，因为会使用大量 &amp; 尺寸较大的图片资源</li>
</ul>
<blockquote>
<p>尽量避免使用尺寸较大的图片</p>
</blockquote>
<h5 id="5、应用场景"><a href="#5、应用场景" class="headerlink" title="5、应用场景"></a>5、应用场景</h5><p>较为复杂的个性化动画效果。（使用时一定要避免使用尺寸较大的图片，否则会引起OOM）</p>
<h3 id="3、属性动画"><a href="#3、属性动画" class="headerlink" title="3、属性动画"></a>3、属性动画</h3><p>视图动画出现的缺点：</p>
<table>
<thead>
<tr>
<th>问题</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>作用对象局限</td>
<td>只能够作用在视图Vew上<br>即只可以对一个Button、Textiew、甚至是Lineartayout、或者其他继承自VIew 的组件进行动画操作，但无法对非View的对象进行动画操作。有些情况下的动画效果只是视图的某个属性&amp;对象而不是整个视图</td>
<td>如，现需实现视图的颜色动态变化，那么就需要操作视图的颜色属性从而实现动画效果，而不是针对整个视图进行动画操作</td>
</tr>
<tr>
<td>仅改变了视觉效果</td>
<td>只是改变了View 的视觉效果，而不会真正去改变View的属性</td>
<td>如，将屏幕左上角的按钮通过补间动画移动到屏幕的右上角，点击当前的按钮位置是没有效果的，因为实际按钮还是停留在屏幕的左上角，补间动画只是将这个按钮绘制到屏幕的右小角，改变了视觉效果而已</td>
</tr>
<tr>
<td>动画效果单一</td>
<td>只能实现平移、旋转、缩放&amp;透明度这些简单的动画需要。一旦遇到相对复杂的动画效果，即超出了上述4种动画效果，那么补间动画则无法实现</td>
<td>即在功能&amp;可拓展有很大局限性</td>
</tr>
</tbody></table>
<h4 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h4><ul>
<li>作用对象：任意 <code>Java</code> 对象，即不再局限于 视图View对象</li>
<li>动画效果：可自定义各种动画效果，即不再局限于4种基本变换：平移、旋转、缩放 &amp; 透明度</li>
</ul>
<h4 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h4><ul>
<li>作用对象进行了扩展：不只是View对象，甚至没对象也可以</li>
<li>动画效果：不只是4种基本变换，还有其他动画效果</li>
<li>作用领域：API 11后引入的</li>
</ul>
<h4 id="3、工作原理"><a href="#3、工作原理" class="headerlink" title="3、工作原理"></a>3、工作原理</h4><p>在一定时间间隔内，通过不断对值进行改变、不断将该值赋给对象的属性(任意对象的任意属性)，从而实现该对象在该属性上的动画效果。整个工作原理的流程如下：</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/2d65cfdbda45a8dd8b3d32d50acee117.png" alt="img"></p>
<h4 id="4、具体用法"><a href="#4、具体用法" class="headerlink" title="4、具体用法"></a>4、具体用法</h4><ol>
<li>两个使用方法类：<code>ValueAnimator</code> 类 &amp; <code>ObjectAnimator</code> 类</li>
<li>两个辅助使用类：插值器 &amp; 估值器</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/5d97a025eb77dc24d1bbcc81de00e0da.png" alt="img"></p>
<h5 id="1、ValueAnimator"><a href="#1、ValueAnimator" class="headerlink" title="1、ValueAnimator"></a>1、ValueAnimator</h5><ul>
<li>定义：属性动画机制中 最核心的一个类</li>
<li>实现动画的原理：<strong>通过不断控制 值 的变化，再不断 手动 赋给对象的属性，从而实现动画效果</strong>。如图下：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5d97a025eb77dc24d1bbcc81de00e0da.png" alt="工作原理"></p>
<p>三个核心方法：</p>
<ol>
<li><code>ValueAnimator.ofInt（int values）</code></li>
<li><code>ValueAnimator.ofFloat（float values）</code></li>
<li><code>ValueAnimator.ofObject（int values）</code></li>
</ol>
<h4 id="1-2、属性动画"><a href="#1-2、属性动画" class="headerlink" title="1.2、属性动画"></a>1.2、属性动画</h4><h2 id="5、Window、Activity、DecorView和ViewRoo"><a href="#5、Window、Activity、DecorView和ViewRoo" class="headerlink" title="5、Window、Activity、DecorView和ViewRoo"></a>5、Window、Activity、DecorView和ViewRoo</h2><p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/944365-aeeb7d69afb2cd63" alt="img"></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
</search>
