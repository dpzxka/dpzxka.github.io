<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Android 学习记录 | 小白兔与小猪猪</title><meta name="keywords" content="android"><meta name="author" content="XKADPZ"><meta name="copyright" content="XKADPZ"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="技术知识汇总">
<meta property="og:type" content="article">
<meta property="og:title" content="Android 学习记录">
<meta property="og:url" content="https://dpzxka.github.io/2022/08/29/Android/Android%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="小白兔与小猪猪">
<meta property="og:description" content="技术知识汇总">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://dpzxka.github.io/img/author.jpeg">
<meta property="article:published_time" content="2022-08-28T16:00:00.000Z">
<meta property="article:modified_time" content="2022-08-29T00:00:42.026Z">
<meta property="article:author" content="XKADPZ">
<meta property="article:tag" content="android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dpzxka.github.io/img/author.jpeg"><link rel="shortcut icon" href="/img/favicon_new.jpeg"><link rel="canonical" href="https://dpzxka.github.io/2022/08/29/Android/Android%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"Z7A3XW4R2I","apiKey":"12db1ad54372045549ef465881c17e743","indexName":"https://dpzxka.github.io/","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":250},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: XKADPZ","link":"链接: ","source":"来源: 小白兔与小猪猪","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Android 学习记录',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-08-29 08:00:42'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/java/"><i class="fa-fw fa-brands fa-java"></i><span> Java</span></a></li><li><a class="site-page child" href="/android/"><i class="fa-fw fa-brands fa-android"></i><span> Android</span></a></li><li><a class="site-page child" href="/algorithm/"><i class="fa-fw fa-duotone fa-blanket"></i><span> algorithm</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/carbonEmission/"><i class="fa-fw fa-brands fa-cloudversify"></i><span> 碳排放</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/author.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小白兔与小猪猪</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/java/"><i class="fa-fw fa-brands fa-java"></i><span> Java</span></a></li><li><a class="site-page child" href="/android/"><i class="fa-fw fa-brands fa-android"></i><span> Android</span></a></li><li><a class="site-page child" href="/algorithm/"><i class="fa-fw fa-duotone fa-blanket"></i><span> algorithm</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/carbonEmission/"><i class="fa-fw fa-brands fa-cloudversify"></i><span> 碳排放</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Android 学习记录</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-28T16:00:00.000Z" title="发表于 2022-08-29 00:00:00">2022-08-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-29T00:00:42.026Z" title="更新于 2022-08-29 08:00:42">2022-08-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/android/">android</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Android 学习记录"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Android笔记记录"><a href="#Android笔记记录" class="headerlink" title="Android笔记记录"></a>Android笔记记录</h1><hr>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/carson_ho/article/details/125581447?spm=1001.2014.3001.5501">Android指南</a></p>
<p><a target="_blank" rel="noopener" href="https://carsonho.blog.csdn.net/article/details/122185559">Android语言篇</a></p>
<p><a target="_blank" rel="noopener" href="https://carsonho.blog.csdn.net/article/details/122297955">Java语言篇</a></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95.png" alt="面试记录"></p>
<h2 id="通用编程基础："><a href="#通用编程基础：" class="headerlink" title="通用编程基础："></a>通用编程基础：</h2><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><h4 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h4><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><h4 id="1、四大组件"><a href="#1、四大组件" class="headerlink" title="1、四大组件"></a>1、四大组件</h4><table>
<thead>
<tr>
<th>类型</th>
<th>定义</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Activity</td>
<td>即活动，展示型组件</td>
<td>显示界面、与用户进行交互</td>
<td>一个Activity通常是一个界面，是四大组件唯一能被用户感知的<br>·Activity之间通过Intent进行通信<br>·每个活动被实现为一个独立的类，&amp;从活动基类继承过来</td>
</tr>
<tr>
<td>serrvic</td>
<td>即照务，计算型组件</td>
<td>提供长期需要在后台运行的服务</td>
<td>长生命周期，没有用户界面，在后台运行</td>
</tr>
<tr>
<td>BroadcastReceiver</td>
<td>即广播接收器，消息型组件</td>
<td>监听事件&amp;做出响应</td>
<td>最常用场景：不同组件&amp;不同应用间传递消息</td>
</tr>
<tr>
<td>ContentProvider</td>
<td>即内容提供者，数据共享型组件</td>
<td>多个组件&amp;应用间数据共享</td>
<td>共享的数据存储在文件系统中/SQLite数据库</td>
</tr>
</tbody></table>
<h6 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h6><h4 id="2、常见使用"><a href="#2、常见使用" class="headerlink" title="2、常见使用"></a>2、常见使用</h4><h4 id="3、多线程"><a href="#3、多线程" class="headerlink" title="3、多线程"></a>3、多线程</h4><h4 id="4、自定义View"><a href="#4、自定义View" class="headerlink" title="4、自定义View"></a>4、自定义View</h4><h4 id="5、性能优化"><a href="#5、性能优化" class="headerlink" title="5、性能优化"></a>5、性能优化</h4><h5 id="1、如何全面进行性能优化"><a href="#1、如何全面进行性能优化" class="headerlink" title="1、如何全面进行性能优化"></a><a href="">1、如何全面进行性能优化</a></h5><ul>
<li><p>目的：让应用程序APP更快、更稳定&amp;更省</p>
<ul>
<li>更快：应用程序 运行得更加流畅、不卡顿，能快速响应用户操作</li>
<li>更稳定：应用程序 能 稳定运行 &amp; 解决用户需求，在用户使用过程中不出现应用程序崩溃<code>（Crash）</code> 和 无响应<code>（ANR）</code>的问题</li>
<li>更省：节省耗费的资源，包括 内存占有、电池量、网络资源等</li>
</ul>
</li>
<li><p>性能指标：<strong>流畅性、稳定性、资源节省性</strong></p>
</li>
<li><p>优化方向：</p>
<ul>
<li>| 优化目的 | 性能指标   | 优化方向                                              |<pre><code>| -------- | ---------- | ----------------------------------------------------- |
</code></pre>
| 更快     | 流畅性     | 启动速度<br>·页面显示速度<br>·响应速度                |<br>| 更稳定   | 稳定性     | 避免出现应用崩溃（Crash）<br>避免出现 应用无响应(ANR) |<br>| 更省     | 资源节省性 | 内存大小<br>·安装包大小<br>·耗电量<br>·网络流量       |</li>
</ul>
</li>
<li><p><strong><code>流畅性</code></strong></p>
<blockquote>
<ul>
<li>优化原因<br>利于 减少使用中的卡顿、响应时间久等问题，给与用户一个操作流畅的体验</li>
<li>优化方向<br>主要针对3个方面优化：启动速度、页面显示速度、响应速度</li>
</ul>
</blockquote>
<ul>
<li><p>启动速度</p>
<ul>
<li><p>采用 <strong>异步加载（多线程）、分步加载、延期加载</strong>的策略，减少启动应用时加载的任务，从而提高启动速度</p>
<p>| 措施                              | 启动慢的原因                                                 | 具体描述                                                     | 备注                                                         |</p>
<pre><code>  | --------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
</code></pre>
<p>| 1、减少OnCreate时间               | OnCreate作为启动Activity的第一个方法，若代码逻辑过多，则容易导致慢 | - 精简OnCreate<br/>- 将OnCreate的代码部分放在OnResume实现<br/>- 通过多线程细分页面显示View，尽可能减少OnCreate，onResume | -很多操作只需1次初始化，都放在OnResume里每次进入Activity会浪费初始化时间<br/>- 解决方案：<br><code>1.定义一个boolean变量</code><br><code>2.在OnCreate里标识为true</code><br><code>3.在OnResume里判断为true就进行初始化，初始化完成立刻置为false</code> |<br>| 2、优化布局文件                   | 若布局层次过多，那么用findViewById的时间就会边多，则容易导致启动慢 | - 优化布局的层次结构，使用include、merge、ViewStub等 <br/>使用观察布局工具Hierarchy Viewer <br>使用布局优化工具：Layoutopt |                                                              |<br>| 3、提高Adapter、AdapterView的效率 | 数据过多，绘制效率过低，从而导致慢                           | - 重用以生成过的Item View<br/> 添加ViewHolder<br>缓存Item的数据<br>分段显示 |                                                              |<br>| 4、减小主线程的阻塞时间           | 导致ANR的时间：<br> <code>1、用户无响应5s</code><br><code>2、网络、数据库阻塞10s</code><br/><code>3、广播接收者执行超过10s</code> | 将耗时过长的操作放入后台线程钟执行&amp;只在需要UI时通知主线程修改 |                                                              |</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>页面显示速度</p>
<blockquote>
<p>a. 页面需绘制的内容（布局 &amp; 控件）太多，从而导致页面测量时间过长<br>b. 绘制效率过低，从而导致绘制时间过长</p>
</blockquote>
<ul>
<li>绘制优化(<a target="_blank" rel="noopener" href="https://blog.csdn.net/carson_ho/article/details/79674623">https://blog.csdn.net/carson_ho/article/details/79674623</a>)</li>
<li>布局优化</li>
</ul>
</li>
<li><p>响应速度</p>
<blockquote>
<p>程序出现ANR情况，从而导致应用程序响应速度慢</p>
</blockquote>
</li>
</ul>
<pre><code>![简介](https://raw.githubusercontent.com/dpzxka/typora_pictures/master/简介.png)

优化方案：使用多线程，将大量&amp;耗时操作放在工作线程钟执行。

&gt; 1、多线程的方式 包括：AsyncTask、继承 Thread类、实现 Runnable接口、Handler消息机制、HandlerThread等
&gt;
&gt; 2、注：实际开发中，当一个进程发生了ANR后，系统会在 /data/anr目录下创建一个文件 traces.txt，通过分析该文件可定位出ANR的原因
</code></pre>
<ul>
<li><p>其他优化方案</p>
<ul>
<li><p>合理刷新机制</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220827145556240.png" alt="image-20220827145556240"></p>
</li>
<li><p>动画使用：</p>
<ol>
<li>根据不同场景选择 合适的动画框架</li>
<li>使用 硬件加速的方式 提高流畅度</li>
<li>使用动画后需停止动画</li>
</ol>
</li>
</ul>
</li>
<li><p>总结</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220827145733758.png" alt="image-20220827145733758"></p>
</li>
<li><p><strong><code>稳定性</code></strong></p>
<ul>
<li><p>应用崩溃<code>（Crash）</code></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220827162729079.png" alt="image-20220827162729079"></p>
<p>优化方案：<strong>使用多线程</strong>，将大量 &amp; 耗时操作放在工作线程中执行</p>
</li>
<li><p>应用无响应<code>（ANR）</code></p>
<p>应用崩溃<code>Crash</code>很多情况是因为 <strong>内存溢出</strong>，即<code>OOM</code>；故 需避免出现 <code>OOM</code>现象</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220827162819942.png" alt="image-20220827162819942"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/carson_ho/article/details/79549417"> 优化方案</a></p>
</li>
<li><p>总结：</p>
<p>| 优化方向 | 优化原因                                                     | 优化方案                                                     |</p>
<pre><code>| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
</code></pre>
<p>| ANR      | 程序出现ANR情况，从而导致应用程序响应速度慢                  | 使用多线程，将大量&amp;耗时操作放在工作线程执行                  |<br>| Crash    | - 应用崩溃Crash很多情况是因为内存溢出：OOM<br>故需要避免OOM现象 | 内存优化：<br>1、避免内存泄漏<br>2、避免内存抖动：避免频繁创建大量、临时，小的局部对象<br/>3、提高代码质量、减少代码数量<br/>4、日常不正常使用：ListView的缓存复用、尽量少用多进程、依赖注入框架。 |</p>
</li>
</ul>
</li>
<li><p><strong><code>资源节省性</code></strong></p>
<blockquote>
<ul>
<li>优化原因<br>由于移动设备的硬件性能有限，故减少应用程序的资源消耗显得十分重要</li>
<li>优化方向<br>内存大小、安装包大小、耗电量 &amp; 网络流量</li>
</ul>
</blockquote>
<ul>
<li><p>内存优化</p>
<blockquote>
<p>避免因不正确使用内存 &amp; 缺乏管理，从而出现 <strong>内存泄露<code>（ML）</code>、内存溢出<code>（OOM）</code>、内存空间占用过大</strong> 等问题，最终导致应用程序崩溃（<code>Crash</code>）</p>
</blockquote>
<p>优化方向：</p>
<ol>
<li>内存泄露</li>
<li>内存抖动</li>
<li>图片Bitmap相关</li>
<li>代码质量 &amp; 数量</li>
<li>日常不正确使用</li>
</ol>
</li>
<li><p>减少安装包大小</p>
<blockquote>
<ul>
<li>优化原因<br>应用程序的安装包大小虽对应用程序的使用无影响，但影响的是：</li>
</ul>
<ol>
<li>空间占有率：即 应用程序占有手机内存的大小</li>
<li>下载门槛：应用的安装包越大，用户下载的门槛越高</li>
</ol>
</blockquote>
<ul>
<li>优化原因<br>应用程序的安装包大小虽对应用程序的使用无影响，但影响的是：</li>
</ul>
<ol>
<li>空间占有率：即 应用程序占有手机内存的大小</li>
<li>下载门槛：应用的安装包越大，用户下载的门槛越高</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220827163920588.png" alt="image-20220827163920588"></p>
<p><strong>优化方案</strong>：</p>
<p>| 优化方案       | 原理                                                         | 具体手段                                                     |</p>
<pre><code>| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
</code></pre>
<p>| 资源优化       | 尽可能较少不必要的资源文件<br><code>(图片、xml文件)</code>              | 1.使用Android Lint删除冗余资源<br/>2.根据分辨率选择合适图片<br/>3、压缩处理图片、降低图片色彩位数<br/>使用内存占有小的图片格式，如Webp |<br>| 较少不必要的库 | 库本省的大小可能非常大，从而导致内存增大                     | 1、尽可能避免引入内存较大的库<br/>2、不引某个方法，而引入庞大的功能库 |<br>| 代码混淆       | 重命名代码中的类、方法、变量名等信息，把他们改成一些无意义的名字&amp;压缩、优化大小 | 1、使用代码混淆工具，如proGuard<br/>2、含压缩、优化、混淆功能 |<br>| 插件化         | 将功能独立成单独模块(APK)&amp;放在服务器上按需下载、按需加载     | 主应用APK仅保留基础、核心功能<br/>其余功能以模块化的形式存放在服务器上 |</p>
</li>
<li><p>减少网络流量</p>
<ul>
<li><p>优化原因<br>每次获取资源时 都通过流量 &amp; 网络加载的方式，将耗费大量网络流量</p>
</li>
<li><p>优化方案<br>主要通过 <strong>缓存</strong> 减少网络流量，采用三级缓存方案：即 内存缓存 - 硬盘缓存- 数据库- 文件 - 网络缓存</p>
<blockquote>
<p>具体描述：当加载资源时，先从内存缓存中寻找；若内存缓存中没有，则从文件缓存中寻找；若文件缓存中没有，最终再通过流量从网络中加载获取</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5e7075f4875f">WebView缓存机制及资源预加载方案</a></p>
</li>
</ul>
</li>
<li><p>减少应用的耗电量</p>
<blockquote>
<p>随着智能手机普及 &amp; 应用程序<code>App</code>的功能发展，人们的日常生活都离不开智能手机 &amp; 各式各样的应用程序<code>App</code>，故 应用程序的耗电量指标则显得十分重要</p>
</blockquote>
<p>| 优化方案                                  | 优化原理                                                     | 备注                                                         |</p>
<pre><code>| ----------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
</code></pre>
<p>| 正确使用WakeLock机制                      | ·WakeLock决定了Android 设备何时进入休眠状态<br/><code>a.应用只要申请了WakeLock，那么在释放WakeLock前，系统不会进入休眠</code><br/><code>b.即使在灭屏的状态下，应用要执行的任务依旧不会被系统打断</code><br/>只有正当使用WakeLock机制，避免过度使用从而使得应用能尽可能进入休眠状态，才能最大化减少耗电量 | ·简介：WakeLock是Android框架层提供的一套唤醒机制<br/>·作用：控制Android设备状态（<code>设备状态主要指屏幕的打开关闭、休眠、cpu的保持运行</code>）<br/>·主要应用场景：防止系统进入休眠状态，从而不断执行应用任务 |<br>| 尽量使用JobScheduler                      | JobScheduler API 允许按需控制任务的执行时机，使得减少因时机控制引起的电池消耗 | ·简介：Android5.0后引入的1个功能API接口·<br>作用：当预置的条件被满足时，JobSchedulerAPI为你的应用执行一个操作<br>主要应用场景：执行的任务存在前提条件（非时间条件而是具体条件） |<br>| 使用电量分析工具<br>（Battery Historian） | 通过电量分析工具，获取当前应用程序的耗电情况，从而优化耗电量温高的问题。 | ·简介：Battery Historian是一款图形化数据分析接口<br/>作用：分析Cndr0g 系维电量，可真观地属示出手机的电量消过程；通过输入电量分析文件显示消耗情况，最后提供电量优化的方案<br/>（<code>Battery Historian是Android5.0后引入的可获取设备上电量消耗信息的APl</code>） |</p>
</li>
<li><p>总结</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220827213040611.png" alt="image-20220827213040611"></p>
</li>
</ul>
</li>
<li><p>总结</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220827213201978.png" alt="image-20220827213201978"></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/5b2162850c630d99ee9392112ea5d5b5.png" alt="img"></p>
</li>
</ul>
<h5 id="2、Android性能优化：布局优化（含-lt-include-gt-、-lt-Viewstub-gt-、-lt-merge-gt-）"><a href="#2、Android性能优化：布局优化（含-lt-include-gt-、-lt-Viewstub-gt-、-lt-merge-gt-）" class="headerlink" title="2、Android性能优化：布局优化（含&lt; include &gt;、&lt; Viewstub &gt;、&lt; merge &gt;）"></a><a href="">2、Android性能优化：布局优化（含&lt; include &gt;、&lt; Viewstub &gt;、&lt; merge &gt;）</a></h5><p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/%E7%9B%AE%E5%BD%95.png" alt="目录"></p>
<ul>
<li><p>**<code>影响的性能</code>**：Android应用中页面显示速度</p>
</li>
<li><p><strong><code>如何影响性能</code><strong>：</strong>页面的测量&amp;绘制时间</strong></p>
<blockquote>
<p> 1个页面通过递归 完成测量 &amp; 绘制过程 = <code>measure</code>、<code>layout</code> 过程</p>
</blockquote>
</li>
<li><p><strong><code>优化思路</code></strong></p>
<ul>
<li>选择耗费性能少的布局</li>
<li>较少布局的层级(嵌套)</li>
<li>提高布局的复用性</li>
<li>减少测量&amp;绘制的时间</li>
</ul>
</li>
<li><p><strong><code>具体优化方案</code></strong></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220827221956160.png" alt="image-20220827221956160"></p>
<ul>
<li><p><strong><a href="">选择耗费性能少的布局</a></strong></p>
<ul>
<li>性能耗费低的布局 = 功能简单 = <code>FrameLayout</code>、<code>LinearLayout</code></li>
<li>性能耗费高的布局 = 功能复杂 = <code>RelativeLayout</code></li>
</ul>
<blockquote>
<p>即 布局过程需消耗更多性能（CPU资源 &amp; 时间）</p>
<p>注：</p>
<ol>
<li>嵌套所耗费的性能 &gt; 单个布局本身耗费的性能</li>
<li>即 完成需求时：宁选择 1个耗费性能高的布局，也不采用嵌套多个耗费性能低的布局</li>
</ol>
</blockquote>
</li>
<li><p><strong><a href="">较少布局的层级(嵌套)</a></strong></p>
<ul>
<li>原理：布局层级少 -&gt;&gt; 绘制的工作量少 -&gt;&gt; 绘制速度快 -&gt;&gt; 性能提高</li>
<li>优化方式：使用布局标签<code>&lt;merge&gt;</code> &amp; 合适选择布局类型</li>
</ul>
<p><code>使用布局标签</code>：减少布局层级</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// 使用说明：</span><br><span class="line">// 1. <span class="tag">&lt;<span class="name">merge</span>&gt;</span>作为被引用布局A的根标签</span><br><span class="line">// 2. 当其他布局通过<span class="tag">&lt;<span class="name">include</span>&gt;</span>标签引用布局A时，布局A中的<span class="tag">&lt;<span class="name">merge</span>&gt;</span>标签内容（根节点）会被去掉，在<span class="tag">&lt;<span class="name">include</span>&gt;</span>里存放的是布局A中的<span class="tag">&lt;<span class="name">merge</span>&gt;</span>标签内容（根节点）的子标签（即子节点），以此减少布局文件的层次</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line"> * 实例说明：在上述例子，在布局B中 通过<span class="tag">&lt;<span class="name">include</span>&gt;</span>标签引用布局C</span><br><span class="line"> * 此时：布局层级为 =  RelativeLayout -&gt;&gt; Button </span><br><span class="line"> *                                  —&gt;&gt; RelativeLayout -&gt;&gt; Button</span><br><span class="line"> *                                                     -&gt;&gt; TextView</span><br><span class="line"> * 现在使用<span class="tag">&lt;<span class="name">merge</span>&gt;</span>优化：将 被引用布局C根标签 的RelativeLayout 改为 <span class="tag">&lt;<span class="name">merge</span>&gt;</span></span><br><span class="line"> * 在引用布局C时，布局C中的<span class="tag">&lt;<span class="name">merge</span>&gt;</span>标签内容（根节点）会被去掉，在<span class="tag">&lt;<span class="name">include</span>&gt;</span>里存放的是布局C中的<span class="tag">&lt;<span class="name">merge</span>&gt;</span>标签内容（根节点）的子标签（即子节点）</span><br><span class="line"> * 即 <span class="tag">&lt;<span class="name">include</span>&gt;</span>里存放的是：<span class="tag">&lt;<span class="name">Button</span>&gt;</span>、<span class="tag">&lt;<span class="name">TextView</span>&gt;</span></span><br><span class="line"> * 此时布局层级为 =  RelativeLayout -&gt;&gt; Button </span><br><span class="line"> *                                -&gt;&gt; Button</span><br><span class="line"> *                                -&gt;&gt; TextView</span><br><span class="line"> * 即 已去掉之前无意义、多余的<span class="tag">&lt;<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"> */  </span><br><span class="line"></span><br><span class="line"> // 被引用的公共部分：布局C = layout_c.xml</span><br><span class="line"> <span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">merge</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;@dimen/dp_10&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/textview&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;@dimen/dp_10&quot;</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">merge</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  // 布局B：layout_b.xml</span><br><span class="line">  <span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line">   </span><br><span class="line">      <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:id</span>=<span class="string">&quot;@+id/Button&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;@dimen/dp_10&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">&quot;@layout/layout_c.xml&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>合适选择布局类型：</code></p>
<p>过合理选择布局类型，从而减少嵌套，即：完成 复杂的UI效果时，尽可能选择<code>1个功能复杂的布局</code>（如RelativeLayout）完成，而<code>不要选择多个功能简单的布局</code>（如：LinerLayout）通过嵌套完成</p>
</li>
<li><p><strong><a href="">提高布局的复用性</a></strong></p>
<p><strong>优化原理</strong>：提取布局间的公共部分，通过提高布局的复用性从而减少测量 &amp; 绘制时间</p>
<p><strong>优化方案</strong>：使用 布局标签 <include>，其作用是实现 布局模块化，即 提取布局中的公共部分 供其他布局共用。</p>
<p><strong>使用说明：</strong>通过标签引入抽取的公共部分布局C；标签所需属性 = 公共部分的layout属性，作用 = 指定需引入、包含的布局文件</p>
<p><strong>具体使用</strong><br>抽取布局A、B中的公共部分布局C &amp; 放入到布局B中使用.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">/** </span><br><span class="line"> * 布局B：layout_b.xml</span><br><span class="line"> */  </span><br><span class="line">  <span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line">   </span><br><span class="line">      <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:id</span>=<span class="string">&quot;@+id/Button&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;@dimen/dp_10&quot;</span> /&gt;</span></span><br><span class="line">      </span><br><span class="line">      // 通过<span class="tag">&lt;<span class="name">include</span>&gt;</span>标签引入抽取的公共部分布局C</span><br><span class="line">      // <span class="tag">&lt;<span class="name">include</span>&gt;</span>标签所需属性 = 公共部分的layout属性，作用 = 指定需引入、包含的布局文件</span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">&quot;@layout/layout_c.xml&quot;</span> /&gt;</span></span><br><span class="line">   </span><br><span class="line">  <span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line"> * 公共部分的布局C：layout_c.xml</span><br><span class="line"> */</span><br><span class="line">   <span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line">   </span><br><span class="line">      <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_height</span>=<span class="string">&quot;@dimen/dp_10&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:id</span>=<span class="string">&quot;@+id/textview&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_height</span>=<span class="string">&quot;@dimen/dp_10&quot;</span>/&gt;</span></span><br><span class="line">   </span><br><span class="line">  <span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li><p><strong><a href="">减少测量&amp;绘制的时间</a></strong></p>
<blockquote>
<p>使用 布局标签<code>&lt;ViewStub&gt;</code> &amp; 尽可能少用布局属性 <code>wrap_content</code></p>
</blockquote>
<p><strong>作用</strong>：按需加载 外部引入的布局，属 轻量级View、不占用显示 &amp; 位置<br>应用场景：引入 只在特殊情况下才显示的布局（即 默认不显示），如：进度显示布局、信息出错出现的提示布局等<br><strong>使用说明</strong></p>
<ol>
<li>先设置好预显示的布局</li>
<li>在其他布局通过标签引入外部布局（类似）；注：此时该布局还未被加载显示</li>
<li>只有当ViewStub被设置为可见 / 调用了ViewStub.inflate()时，ViewStub所指向的布局文件才会被inflate 、实例化，最终 显示指向的布局</li>
</ol>
<p><strong>具体使用</strong>：在布局A中引入布局B，只有在特定时刻C中才显示</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// 步骤1：先设置好预显示的布局B = layout_b.xml</span><br><span class="line"> <span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;@dimen/dp_10&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/textview&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;@dimen/dp_10&quot;</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 步骤2：在布局A通过<span class="tag">&lt;<span class="name">ViewStub</span>&gt;</span>标签引入布局B（类似<span class="tag">&lt;<span class="name">include</span>&gt;</span>）；注：此时该布局还未被加载显示</span><br><span class="line">// 布局A：layout_a.xml</span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> &gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/Button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;@dimen/dp_10&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ViewStub</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/Blayout&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout</span>=<span class="string">&quot;@layout/layout_b&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 步骤3：只有当ViewStub被设置为可见 / 调用了ViewStub.inflate()时，ViewStub所指向的布局文件才会被inflate 、实例化，最终 显示<span class="tag">&lt;<span class="name">ViewStub</span>&gt;</span>指向的布局</span><br><span class="line">ViewStub stub = (ViewStub) findViewById(R.id.Blayout);   </span><br><span class="line">stub.inflate();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>ViewStub中的layout布局不能使用merge标签，否则会报错</li>
<li>ViewStub的inflate只能执行一次，显示了之后，就不能再使用ViewStub控制它了</li>
<li>与View.setVisible(View.Gone)的区别：View 的可见性设置为 gone 后，在inflate 时，该View 及其子View依然会被解析；而使用ViewStub就能避免解析其中指定的布局文件，从而节省布局文件的解析时间 &amp; 内存的占用</li>
</ol>
<p>布局属性<code>wrap_content</code> 会增加布局测量时计算成本，应尽可能少用；特别是在已知宽高为固定值时，不使用<code>wrap_content</code>。</p>
</blockquote>
</li>
<li><p>布局调优工具</p>
<ul>
<li><p>Lint</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011240877/article/details/54141714">使用教程</a></p>
</li>
<li><p>Systrace</p>
<p>简介: Android 4.1以上版本提供的性能数据采样 &amp; 分析工具<br>作用:检测 Android系统各个组件随着时间的运行状态 &amp; 提供解决方案</p>
<blockquote>
<ol>
<li>收集 等运行信息，从而帮助开发者更直观地分析系统瓶颈，改进性能<br>检测范围包括：Android 关键子系统（如WindowManagerService 等 Framework 部分关键模块）、服务、View系统</li>
<li>功能包括：跟踪系统的I/O 操作、内核工作队列、CPU 负载等，在 UI 显示性能分析上提供很好的数据，特别是在动画播放不流畅、渲染卡等问题上</li>
</ol>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://gityuan.com/2016/01/17/systrace/">使用教程</a></p>
</li>
</ul>
</li>
</ul>
<h5 id="3、Android性能优化：内存泄露"><a href="#3、Android性能优化：内存泄露" class="headerlink" title="3、Android性能优化：内存泄露"></a><a href="">3、Android性能优化：内存泄露</a></h5><ul>
<li><p><strong><code>1、简介：</code></strong></p>
<ul>
<li>ML(Memory  Leak)</li>
<li>程序在申请内存后，当该内存不需要再使用<strong>但却无法被释放&amp;归还给程序</strong> 的现象</li>
</ul>
</li>
<li><p><strong><code>2、对应用程序的影响</code></strong></p>
<p>容易使得应用程序发生内存溢出，即<code>OOM</code></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220828001331700.png" alt="image-20220828001331700"></p>
</li>
<li><p><strong><code>3、发生内存泄漏的本质原因</code></strong></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220828001421068.png" alt="image-20220828001421068"></p>
<p>注意：</p>
</li>
<li><p><strong><code>4、Android内存管理机制</code></strong></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220828081537409.png" alt="image-20220828081537409"></p>
<p><strong><code>1、针对进程的内存策略</code></strong></p>
<p><strong>内存分配策略：</strong></p>
<p>由ActivityManagerService集中分配所有进程的内存分配</p>
<p>内存回收策略：</p>
<ol>
<li>Application FrameWork决定回收的进程类型</li>
</ol>
</li>
</ul>
<pre><code> ![进程优先级](https://www.processon.com/view/link/630ab73e63768906ff6909b6)

 ![image-20220828083228966](https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220828083228966.png)
</code></pre>
<ol start="2">
<li>Linux内核真正回收具体进程</li>
</ol>
<p><strong><code>2、针对对象、变量 的内存策略</code></strong></p>
<p><strong>内存分配策略</strong><br>对象 / 变量的内存分配 由程序自动 负责，共有3种：静态分配、栈式分配、 &amp; 堆式分配，分别面向静态变量、局部变量 &amp; 对象实例</p>
<table>
<thead>
<tr>
<th>内存分配策略</th>
<th>使用的内存空间</th>
<th>存储的数据</th>
<th>分配策略描述</th>
</tr>
</thead>
<tbody><tr>
<td>静态分配</td>
<td>方法区<br><code>（静态存储区）</code></td>
<td>存储已被虚拟机加载的类信息、常量、静态变量</td>
<td>在程序编译时就已分配好&amp;存在于程序整个运行期间<br><code>（不需回收）</code></td>
</tr>
<tr>
<td>栈式分配区</td>
<td>栈区<code>（Stack）</code></td>
<td>存储方法执行时的局部变量（含教据类型、对象的引用）<br><code>以桢栈形式</code></td>
<td>方法执行时，定义局部变量则由程序自动在栈中分配内存<br>方法执行结来/超出变量境时，则由栈自动释放该部分内存<br>效率高<br>（<code>因栈内存分配运算内置于处理器的指令集中</code>）<br>但分配的内存容量有限</td>
</tr>
<tr>
<td>堆式分配<br>(动态内存分配)</td>
<td>堆区<br>（Heap）</td>
<td>存储Java对象的实例&amp;实例内成员变量<br><code>即采用关键字new出来的对象</code><br><code>实例的成员变量=基本数据类型、引用&amp;引用的对象实体</code></td>
<td>创建对象实例时，有程序分配<br>（<code>由Java垃级回收管理器自动管理；不使用时则回收</code>）<br>访问方式<br>.1在堆中创建1个对象/数组&amp;在栈中定义一个特殊的变量(引用变量)=数组/对象在堆内存中的首地址<br>2.通过引用变量来访问堆内存中的对象/数组</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>基本数据类型、局部变量、</strong>对象的引用变量<strong>都是存放在栈内存中的，用完就消失</strong></p>
<p><strong>new创建的实例化对象及数组，是存放在堆内存中的，用完之后靠垃圾回收机制不定期自动消除</strong></p>
</blockquote>
<p><strong>内存释放</strong>：垃圾回收算法</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220828091450126.png" alt="image-20220828091450126"></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p><strong><code>5、内存泄漏原因&amp;解决方案</code></strong></p>
<ol>
<li><strong>集合类</strong></li>
</ol>
<p><a href="">原因</a>：集合类添加元素后，仍引用着集合元素对象，导致该集合元素对象不可被回收，从而 导致内存泄漏。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 循环申请Object 对象 &amp; 将申请的对象逐个放入到集合List</span></span><br><span class="line">List&lt;Object&gt; objectList = <span class="keyword">new</span> ArrayList&lt;&gt;();        </span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Object o = <span class="keyword">new</span> Object();</span><br><span class="line">            objectList.add(o);</span><br><span class="line">            o = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 虽释放了集合元素引用的本身：o=null）</span></span><br><span class="line"><span class="comment">// 但集合List 仍然引用该对象，故垃圾回收器GC 依然不可回收该对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="null">解决方案</a>:集合类 添加集合元素对象 后，在使用后必须从集合中删除</p>
<blockquote>
<p>由于1个集合中有许多元素，故最简单的方法 = 清空集合对象 &amp; 设置为<code>null</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放objectList</span></span><br><span class="line">       objectList.clear();</span><br><span class="line">       objectList=<span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong><code>Static</code>关键字修饰的成员变量</strong></p>
<blockquote>
<p>被 Static 关键字修饰的成员变量的生命周期 = 应用程序的生命周期</p>
</blockquote>
<p><a href="">原因</a>:使被 Static 关键字修饰的成员变量 引用耗费资源过多的实例（如Context），则容易出现该成员变量的生命周期 &gt; 引用实例生命周期的情况，当引用实例需结束生命周期销毁时，会因静态变量的持有而无法被回收，从而出现内存泄露.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 定义1个静态变量</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> Context mContext;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line"><span class="comment">// 引用的是Activity的context</span></span><br><span class="line"> mContext = context; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 当Activity需销毁时，由于mContext = 静态 &amp; 生命周期 = 应用程序的生命周期，故 Activity无法被回收，从而出现内存泄露</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="null">解决方案</a>:</p>
<p>1、尽量避免 Static 成员变量引用资源耗费过多的实例。若需引用 Context，则尽量使用Applicaiton的Context。</p>
<p>2、使用 弱引用<code>（WeakReference）</code> 代替 强引用 持有实例。</p>
<p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建单例时，需传入一个Context</span></span><br><span class="line"><span class="comment">// 若传入的是Activity的Context，此时单例 则持有该Activity的引用</span></span><br><span class="line"><span class="comment">// 由于单例一直持有该Activity的引用（直到整个应用生命周期结束），即使该Activity退出，该Activity的内存也不会被回收</span></span><br><span class="line"><span class="comment">// 特别是一些庞大的Activity，此处非常容易导致OOM</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleInstanceClass</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleInstanceClass instance;    </span><br><span class="line">    <span class="keyword">private</span> Context mContext;    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleInstanceClass</span><span class="params">(Context context)</span> </span>&#123;        </span><br><span class="line">        <span class="comment">//this.mContext = context; // 传递的是Activity的context</span></span><br><span class="line">        <span class="comment">//解决方式</span></span><br><span class="line">        <span class="keyword">this</span>.mContext = context.getApplicationContext();</span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> SingleInstanceClass <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingleInstanceClass(context);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>非静态内部类 / 匿名类</strong></p>
<blockquote>
<p>非静态内部类 / 匿名类 默认持有 外部类的引用；而静态内部类则不会</p>
<p>3种情况非静态内部类的实例 = 静态、多线程、消息传递机制（Handler）</p>
</blockquote>
<ul>
<li><p><code>非静态内部类的实例 = 静态</code></p>
<p><a href="">原因：</a>若非静态内部类所创建的实例 = 静态（其生命周期 = 应用的生命周期），会因<strong>非静态内部类默认持有外部类的引用</strong> 而导致外部类无法释放，最终造成内存泄露。(即外部类中持有非静态内部类的静态对象)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 背景：</span></span><br><span class="line">   <span class="comment">/*a. 在启动频繁的Activity中，为了避免重复创建相同的数据资源，会在Activity内部创建一个非静态内部类的单例</span></span><br><span class="line"><span class="comment">   b. 每次启动Activity时都会使用该单例的数据*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 非静态内部类的实例的引用</span></span><br><span class="line">    <span class="comment">// 注：设置为静态  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> InnerClass innerClass = <span class="keyword">null</span>; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);   </span><br><span class="line">        <span class="comment">// 保证非静态内部类的实例只有1个</span></span><br><span class="line">        <span class="keyword">if</span> (innerClass == <span class="keyword">null</span>)</span><br><span class="line">            innerClass = <span class="keyword">new</span> InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非静态内部类的定义    </span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;        </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 造成内存泄露的原因：</span></span><br><span class="line">    <span class="comment">// a. 当TestActivity销毁时，因非静态内部类单例的引用（innerClass）的生命周期 = 应用App的生命周期、持有外部类TestActivity的引用</span></span><br><span class="line">    <span class="comment">// b. 故 TestActivity无法被GC回收，从而导致内存泄漏</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="null">解决方案</a>:</p>
<ol>
<li>将非静态内部类设置为：静态内部类（静态内部类默认不持有外部类的引用）</li>
<li>该内部类抽取出来封装成一个单例</li>
<li>尽量 避免 非静态内部类所创建的实例 = 静态</li>
</ol>
</li>
<li><p><code>非静态内部类的实例 = 多线程</code></p>
<blockquote>
<p>多线程的使用方法 = 非静态内部类 / 匿名类；即 线程类 属于 非静态内部类 / 匿名类。</p>
<p>多线程主要使用的是：AsyncTask、实现Runnable接口 &amp; 继承Thread类</p>
</blockquote>
<p><a href="">原因：</a>:</p>
<p>当 工作线程正在处理任务 &amp; 外部类需销毁时， <strong>由于 工作线程实例 持有外部类引用</strong>，将使得外部类无法被垃圾回收器（GC）回收，从而造成 内存泄露.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 方式1：新建Thread子类（内部类）</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;carson：&quot;</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">            setContentView(R.layout.activity_main);</span><br><span class="line">            <span class="comment">// 通过创建的内部类 实现多线程</span></span><br><span class="line">            <span class="keyword">new</span> MyThread().start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 自定义的Thread子类</span></span><br><span class="line">        <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;执行了多线程&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 方式2：匿名Thread内部类</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">     <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;carson：&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过匿名内部类 实现多线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;执行了多线程&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 分析：内存泄露原因</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">  <span class="comment">// 工作线程Thread类属于非静态内部类 / 匿名内部类，运行时默认持有外部类的引用</span></span><br><span class="line">  <span class="comment">// 当工作线程运行时，若外部类MainActivity需销毁</span></span><br><span class="line">  <span class="comment">// 由于此时工作线程类实例持有外部类的引用，将使得外部类无法被垃圾回收器（GC）回收，从而造成 内存泄露</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="null">解决方案</a>:</p>
<ol>
<li><p>存在 ”工作线程实例 持有外部类引用“ 的引用关系</p>
</li>
<li><p>工作线程实例的生命周期 &gt; 外部类的生命周期，即工作线程仍在运行 而 外部类需销毁。</p>
<p>思路：上述条件任意1个不成立。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 共有2个解决方案：静态内部类 &amp; 当外部类结束生命周期时，强制结束线程</span></span><br><span class="line"><span class="comment">// 具体描述如下</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 解决方式1：静态内部类</span></span><br><span class="line"><span class="comment">     * 原理：静态内部类不默认持有外部类的引用，从而使得 “工作线程实例持有外部类引用” 的引用关系不复存在</span></span><br><span class="line"><span class="comment">     * 具体实现：将Thread的子类设置成 静态内部类</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;carson：&quot;</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">            setContentView(R.layout.activity_main);</span><br><span class="line">            <span class="comment">// 通过创建的内部类 实现多线程</span></span><br><span class="line">            <span class="keyword">new</span> MyThread().start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分析1：自定义Thread子类</span></span><br><span class="line">        <span class="comment">// 设置为：静态内部类</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;执行了多线程&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 解决方案2：当外部类结束生命周期时，强制结束线程</span></span><br><span class="line"><span class="comment">     * 原理：使得 工作线程实例的生命周期 与 外部类的生命周期 同步</span></span><br><span class="line"><span class="comment">     * 具体实现：当 外部类（此处以Activity为例） 结束生命周期时（此时系统会调用onDestroy（）），强制结束线程（调用stop（））</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        Thread.stop();</span><br><span class="line">        <span class="comment">// 外部类Activity生命周期结束时，强制结束线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ul>
<pre><code> - `非静态内部类的实例 = 消息传递机制（Handler）`

   [案例]():

   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 方式1：新建Handler子类（内部类）</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;carson：&quot;</span>;</span><br><span class="line">            <span class="keyword">private</span> Handler showhandler;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 主线程创建时便自动创建Looper &amp; 对应的MessageQueue</span></span><br><span class="line">            <span class="comment">// 之后执行Loop()进入消息循环</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">                setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//1. 实例化自定义的Handler类对象-&gt;&gt;分析1</span></span><br><span class="line">                <span class="comment">//注：此处并无指定Looper，故自动绑定当前线程(主线程)的Looper、MessageQueue</span></span><br><span class="line">                showhandler = <span class="keyword">new</span> FHandler();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 启动子线程1</span></span><br><span class="line">                <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// a. 定义要发送的消息</span></span><br><span class="line">                        Message msg = Message.obtain();</span><br><span class="line">                        msg.what = <span class="number">1</span>;<span class="comment">// 消息标识</span></span><br><span class="line">                        msg.obj = <span class="string">&quot;AA&quot;</span>;<span class="comment">// 消息存放</span></span><br><span class="line">                        <span class="comment">// b. 传入主线程的Handler &amp; 向其MessageQueue发送消息</span></span><br><span class="line">                        showhandler.sendMessage(msg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.start();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3. 启动子线程2</span></span><br><span class="line">                <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// a. 定义要发送的消息</span></span><br><span class="line">                        Message msg = Message.obtain();</span><br><span class="line">                        msg.what = <span class="number">2</span>;<span class="comment">// 消息标识</span></span><br><span class="line">                        msg.obj = <span class="string">&quot;BB&quot;</span>;<span class="comment">// 消息存放</span></span><br><span class="line">                        <span class="comment">// b. 传入主线程的Handler &amp; 向其MessageQueue发送消息</span></span><br><span class="line">                        showhandler.sendMessage(msg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.start();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 分析1：自定义Handler子类</span></span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">FHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 通过复写handlerMessage() 从而确定更新UI的操作</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                            Log.d(TAG, <span class="string">&quot;收到线程1的消息&quot;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                            Log.d(TAG, <span class="string">&quot; 收到线程2的消息&quot;</span>);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 方式2：匿名Handler内部类</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">     <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;carson：&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> Handler showhandler;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程创建时便自动创建Looper &amp; 对应的MessageQueue</span></span><br><span class="line">        <span class="comment">// 之后执行Loop()进入消息循环</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">            setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//1. 通过匿名内部类实例化的Handler类对象</span></span><br><span class="line">            <span class="comment">//注：此处并无指定Looper，故自动绑定当前线程(主线程)的Looper、MessageQueue</span></span><br><span class="line">            showhandler = <span class="keyword">new</span>  Handler()&#123;</span><br><span class="line">                <span class="comment">// 通过复写handlerMessage()从而确定更新UI的操作</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                                Log.d(TAG, <span class="string">&quot;收到线程1的消息&quot;</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                                Log.d(TAG, <span class="string">&quot; 收到线程2的消息&quot;</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 启动子线程1</span></span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// a. 定义要发送的消息</span></span><br><span class="line">                    Message msg = Message.obtain();</span><br><span class="line">                    msg.what = <span class="number">1</span>;<span class="comment">// 消息标识</span></span><br><span class="line">                    msg.obj = <span class="string">&quot;AA&quot;</span>;<span class="comment">// 消息存放</span></span><br><span class="line">                    <span class="comment">// b. 传入主线程的Handler &amp; 向其MessageQueue发送消息</span></span><br><span class="line">                    showhandler.sendMessage(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 启动子线程2</span></span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// a. 定义要发送的消息</span></span><br><span class="line">                    Message msg = Message.obtain();</span><br><span class="line">                    msg.what = <span class="number">2</span>;<span class="comment">// 消息标识</span></span><br><span class="line">                    msg.obj = <span class="string">&quot;BB&quot;</span>;<span class="comment">// 消息存放</span></span><br><span class="line">                    <span class="comment">// b. 传入主线程的Handler &amp; 向其MessageQueue发送消息</span></span><br><span class="line">                    showhandler.sendMessage(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

   &gt; - 主线程的`Looper`对象的生命周期 = 该应用程序的生命周期
   &gt; - 在`Java`中，**非静态内部类** &amp; **匿名内部类**都默认持有 外部类的引用

   [参考](https://www.jianshu.com/p/ed9e15eff47a)

   [原因]():

   由于Handler = 非静态内部类 / 匿名内部类（2种使用方式），故又默认持有外部类的引用（即MainActivity实例）。

   由于`Handler` = 非静态内部类 / 匿名内部类（2种使用方式），故又默认持有外部类的引用（即`MainActivity`实例）

   [解决方案]()

   **原理**：静态内部类不默认持有外部类的引用，从而使得 “未被处理 / 正处理的消息 -&gt; Handler实例 -&gt; 外部类” 的引用关系 不存在。

   **具体方案：**将Handler的子类设置成静态内部类。此外，还可使用WeakReference弱引用持有外部类，保证外部类能被回收。因为：弱引用的对象拥有短暂的生命周期，在垃圾回收器线程扫描时，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。

   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;carson：&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Handler showhandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">// 实例化自定义的Handler类对象-&gt;&gt;分析1</span></span><br><span class="line">        <span class="comment">// 注：</span></span><br><span class="line">            <span class="comment">// a. 此处并无指定Looper，故自动绑定当前线程(主线程)的Looper、MessageQueue；</span></span><br><span class="line">            <span class="comment">// b. 定义时需传入持有的Activity实例（弱引用）</span></span><br><span class="line">        showhandler = <span class="keyword">new</span> FHandler(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// a. 定义要发送的消息</span></span><br><span class="line">                Message msg = Message.obtain();</span><br><span class="line">                msg.what = <span class="number">1</span>;<span class="comment">// 消息标识</span></span><br><span class="line">                msg.obj = <span class="string">&quot;AA&quot;</span>;<span class="comment">// 消息存放</span></span><br><span class="line">                showhandler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置为：静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义 弱引用实例</span></span><br><span class="line">        <span class="keyword">private</span> WeakReference&lt;Activity&gt; reference;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在构造方法中传入需持有的Activity实例</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">FHandler</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 使用WeakReference弱引用持有Activity实例</span></span><br><span class="line">            reference = <span class="keyword">new</span> WeakReference&lt;Activity&gt;(activity); &#125;</span><br><span class="line">        <span class="comment">// 通过复写handlerMessage() 从而确定更新UI的操作</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot;收到线程1的消息&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    Log.d(TAG, <span class="string">&quot; 收到线程2的消息&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="4">
<li><p><strong>资源对象使用后未关闭</strong></p>
<p><a href="">原因</a>:</p>
<p>对于资源的使用（如 广播<code>BraodcastReceiver</code>、文件流<code>File</code>、数据库游标<code>Cursor</code>、图片资源<code>Bitmap</code>等），若在<code>Activity</code>销毁时无及时关闭 / 注销这些资源，则这些资源将不会被回收，从而造成内存泄漏</p>
<p><a href="">解决方案</a>:</p>
<p>在Activity销毁时 及时关闭 / 注销资源</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于 广播BraodcastReceiver：注销注册</span></span><br><span class="line">unregisterReceiver()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 文件流File：关闭流</span></span><br><span class="line">InputStream / OutputStream.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于数据库游标cursor：使用后关闭游标</span></span><br><span class="line">cursor.close（）</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 图片资源Bitmap：Android分配给图片的内存只有8M，若1个Bitmap对象占内存较多，当它不再被使用时，应调用recycle()回收此对象的像素所占用的内存；最后再赋为null </span></span><br><span class="line">Bitmap.recycle()；</span><br><span class="line">Bitmap = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于动画（属性动画）</span></span><br><span class="line"><span class="comment">// 将动画设置成无限循环播放repeatCount = “infinite”后</span></span><br><span class="line"><span class="comment">// 在Activity退出时记得停止动画</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><strong>其他情况</strong></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220828161813990.png" alt="image-20220828161813990"></p>
</li>
</ol>
<ol start="6">
<li><p>总结：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e70c23ea7510da25a14138fc25a9a3ba.png" alt="总结"></p>
</li>
</ol>
<ul>
<li><p><strong><code>6、辅助分析内存泄露的工具</code></strong></p>
<p><a target="_blank" rel="noopener" href="https://developer.android.google.cn/studio/profile/android-profiler">Android Profiler  | Android 开发者  | Android Developers (google.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a16c87ecdf6f">Android优化工具Systrace - 简书 (jianshu.com)</a></p>
<p>[dumpsys:](<a target="_blank" rel="noopener" href="https://developer.android.com/studio/command-line/dumpsys?hl=en">dumpsys  | Android Developers</a>) Android内核系统服务相关的计数器。<br>[heapprofd：](<a target="_blank" rel="noopener" href="https://perfetto.dev/docs/design-docs/heapprofd-design">heapprofd: Android Heap Profiler - Perfetto Tracing Docs</a>)Android进程本地内存分析工具。</p>
</li>
<li><p><strong><code>7、总结</code></strong></p>
</li>
</ul>
<h5 id="4、Android性能优化：内存优化"><a href="#4、Android性能优化：内存优化" class="headerlink" title="4、Android性能优化：内存优化"></a><a href="">4、Android性能优化：内存优化</a></h5><ol>
<li><p>内存泄露:见上分析</p>
</li>
<li><p>内存抖动</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/c2a5b5b215996caf83385e6d6b370437.png" alt="img"></p>
<p><strong>尽量避免频繁创建大量、临时的小对象</strong></p>
</li>
<li><p>图片<code>Bitmap</code>相关</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/carson_ho/article/details/79549382">Android性能优化：那些关于Bitmap图片资源优化的小事_Carson带你学Android的博客-CSDN博客</a></p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/image-20220829072715524.png" alt="image-20220829072715524"></p>
</li>
<li><p>代码质量 &amp; 数量</p>
<ul>
<li>优化原因<br>代码本身的质量（如 数据结构、数据类型等） &amp; 数量（代码量的大小）可能会导致大量的内存问题，如占用内存大、内存利用率低等</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/40ecb5de67f58041c808f1a4476698ed.png" alt="img"></p>
</li>
<li><p>日常不正确使用</p>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/e193ab51467c5de82501b787a8357d57.png" alt="img"></p>
</li>
<li><p>小技巧</p>
<p><strong>技巧1：获取当前可使用的内存大小</strong><br>调用 ActivityManager.getMemoryClass（）方法可获取当前应用可用的内存大小（单位 = 兆）</p>
<p><strong>技巧2：获取当前的内存使用情况</strong><br>在应用生命周期的任何阶段，调用 onTrimMemory()获取应用程序 当前内存使用情况（以内存级别进行识别），可根据该方法返回的内存紧张级别参数 来释放内存</p>
<p><strong>技巧3：当视图变为隐藏状态时，则释放内存</strong><br>当用户跳转到不同的应用 &amp; 视图不再显示时, 应释放应用视图所占的资源</p>
<blockquote>
<ol>
<li>注：此时释放所占用的资源能显著的提高系统的缓存处理容量</li>
<li>具体操作：实现当前<code>Activity</code>类的<code>onTrimMemory()</code>后，当用户离开视图时会得到通知；若得到返回的参数 = <code>TRIM_MEMORY_UI_HIDDEN</code> 即代表视图变为隐藏状态，则可释放视图所占用的资源</li>
</ol>
</blockquote>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/dd35b51f50f4ad2e2583707dbec694c8.png" alt="img"></p>
<h5 id="5、Android性能优化：Bitmap图片资源优化"><a href="#5、Android性能优化：Bitmap图片资源优化" class="headerlink" title="5、Android性能优化：Bitmap图片资源优化"></a><a href="">5、Android性能优化：Bitmap图片资源优化</a></h5><p><a target="_blank" rel="noopener" href="https://carsonho.blog.csdn.net/article/details/79549382">Android性能优化：那些关于Bitmap图片资源优化的小事</a></p>
<h5 id="6、Android性能优化：绘制优化"><a href="#6、Android性能优化：绘制优化" class="headerlink" title="6、Android性能优化：绘制优化"></a><a href="">6、Android性能优化：绘制优化</a></h5><p><a target="_blank" rel="noopener" href="https://carsonho.blog.csdn.net/article/details/79674623">Android性能优化：绘制优化</a></p>
<h4 id="6、常用开源框架"><a href="#6、常用开源框架" class="headerlink" title="6、常用开源框架"></a>6、常用开源框架</h4><h5 id="Android实现网络请求的主流方法"><a href="#Android实现网络请求的主流方法" class="headerlink" title="Android实现网络请求的主流方法"></a>Android实现网络请求的主流方法</h5><p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/51f7ecf5b9a606c499ac87c5b4d54d4c.png" alt="img"></p>
<h5 id="网络请求库-与-Android网络请求方法的关系"><a href="#网络请求库-与-Android网络请求方法的关系" class="headerlink" title="网络请求库 与 Android网络请求方法的关系"></a>网络请求库 与 Android网络请求方法的关系</h5><ul>
<li>网络请求库的本质 = 封装了 <strong>网络请求 + 异步 + 数据处理</strong>功能的库</li>
<li>其中，网络请求功能则是采用<code>Android</code>网络请求的原生方法（<code>HttpClient</code>或<code>HttpURLConnection</code>）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/156b09c922bd3e3cda37a4bce78c9c4b.png" alt="img"></p>
<h5 id="主流的网络请求库"><a href="#主流的网络请求库" class="headerlink" title="主流的网络请求库"></a>主流的网络请求库</h5><p><img src="https://raw.githubusercontent.com/dpzxka/typora_pictures/master/5307f5ae81079a75369fa10cd6b3908d.png" alt="img"></p>
<h4 id="7、新技术"><a href="#7、新技术" class="headerlink" title="7、新技术"></a>7、新技术</h4><p><a target="_blank" rel="noopener" href="https://carsonho.blog.csdn.net/article/details/100070713">MVC、MVP &amp; MVVM模式（含实例讲解</a></p>
<p><a target="_blank" rel="noopener" href="https://carsonho.blog.csdn.net/article/details/73250163">JNI 与 NDK到底是什么？（含实例教学）</a></p>
<p><a target="_blank" rel="noopener" href="https://carsonho.blog.csdn.net/article/details/88012315">热修复学习指南</a></p>
<p>插件化</p>
<p><img src="https://camo.githubusercontent.com/25fd33fb30eab376400c46bff4a8ccf5ebf704b739078654f4b926bafc4c2401/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f3934343336352d363966353830386438306330353839382e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="插件化"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">XKADPZ</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://dpzxka.github.io/2022/08/29/Android/Android%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">https://dpzxka.github.io/2022/08/29/Android/Android%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://dpzxka.github.io" target="_blank">小白兔与小猪猪</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/android/">android</a></div><div class="post_share"><div class="social-share" data-image="/img/author.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2022/08/16/Android/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2_10_Android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"><img class="prev-cover" src="/img/author.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android开发艺术探索_10_Android的消息机制</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/02/13/Android/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6/" title="Android之广播机制(五)"><img class="cover" src="/img/author.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-13</div><div class="title">Android之广播机制(五)</div></div></a></div><div><a href="/2022/02/13/Android/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" title="Android之数据存储(六)"><img class="cover" src="/img/author.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-13</div><div class="title">Android之数据存储(六)</div></div></a></div><div><a href="/2022/04/22/Android/Android%E7%9F%A5%E8%AF%86%E7%82%B9/" title="Android 知识点"><img class="cover" src="/img/author.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-22</div><div class="title">Android 知识点</div></div></a></div><div><a href="/2022/07/08/Android/Android%20%E9%9D%A2%E8%AF%95/" title="Android 面试宝典"><img class="cover" src="/img/author.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-08</div><div class="title">Android 面试宝典</div></div></a></div><div><a href="/2022/07/28/Android/Android%2033%E8%AE%B2/" title="Android 33讲"><img class="cover" src="/img/author.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-28</div><div class="title">Android 33讲</div></div></a></div><div><a href="/2022/08/08/Android/Android%20%E7%BE%A4%E8%8B%B1%E4%BC%A0%20%E6%80%BB%E7%BB%93%E8%AE%B0%E5%BD%95/" title="Android 群英传笔记"><img class="cover" src="/img/author.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-08</div><div class="title">Android 群英传笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Android%E7%AC%94%E8%AE%B0%E8%AE%B0%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text">Android笔记记录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">通用编程基础：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.0.3.</span> <span class="toc-text">设计模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">1.2.</span> <span class="toc-text">计算机基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">计算机网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">操作系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80"><span class="toc-number">1.3.</span> <span class="toc-text">编程语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java"><span class="toc-number">1.3.1.</span> <span class="toc-text">java</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android"><span class="toc-number">1.3.2.</span> <span class="toc-text">Android</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">1、四大组件</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Activity"><span class="toc-number">1.3.2.1.0.1.</span> <span class="toc-text">Activity</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">2、常见使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">3、多线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89View"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">4、自定义View</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">5、性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%A6%82%E4%BD%95%E5%85%A8%E9%9D%A2%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.2.5.1.</span> <span class="toc-text">1、如何全面进行性能优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96%EF%BC%88%E5%90%AB-lt-include-gt-%E3%80%81-lt-Viewstub-gt-%E3%80%81-lt-merge-gt-%EF%BC%89"><span class="toc-number">1.3.2.5.2.</span> <span class="toc-text">2、Android性能优化：布局优化（含&lt; include &gt;、&lt; Viewstub &gt;、&lt; merge &gt;）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E3%80%81Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-number">1.3.2.5.3.</span> <span class="toc-text">3、Android性能优化：内存泄露</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E3%80%81Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.2.5.4.</span> <span class="toc-text">4、Android性能优化：内存优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E3%80%81Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9ABitmap%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.2.5.5.</span> <span class="toc-text">5、Android性能优化：Bitmap图片资源优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6%E3%80%81Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E7%BB%98%E5%88%B6%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.2.5.6.</span> <span class="toc-text">6、Android性能优化：绘制优化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E5%B8%B8%E7%94%A8%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6"><span class="toc-number">1.3.2.6.</span> <span class="toc-text">6、常用开源框架</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Android%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E4%B8%BB%E6%B5%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.2.6.1.</span> <span class="toc-text">Android实现网络请求的主流方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%BA%93-%E4%B8%8E-Android%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.2.6.2.</span> <span class="toc-text">网络请求库 与 Android网络请求方法的关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E6%B5%81%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%BA%93"><span class="toc-number">1.3.2.6.3.</span> <span class="toc-text">主流的网络请求库</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E6%96%B0%E6%8A%80%E6%9C%AF"><span class="toc-number">1.3.2.7.</span> <span class="toc-text">7、新技术</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By XKADPZ</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">xkadpz的欢乐乐园</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Algolia</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>